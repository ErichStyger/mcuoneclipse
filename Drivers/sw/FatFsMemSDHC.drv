%-Driver generated by the Component Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Component Wizard
%- If you change these lines, Component Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    19.07.2012
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_SD_Wait Wait until SD operation is completed
%ifdef GPIO_LDD
  %ifdef @GPIO_LDD@OnPortEvent
    %define! Description_%@GPIO_LDD@OnPortEvent Called if defined event on any pin of the port occured. OnPortEvent event and GPIO interrupt must be enabled. See SetPortEventMask() and GetPortEventMask() methods. This event is enabled if <a href="UntitledProperties.html#IntService">Interrupt service/event</a> is Enabled and disabled if <a href="UntitledProperties.html#IntService">Interrupt service/event</a> is Disabled. The event services the event of the inherited component and eventually invokes other events.
  %endif %- @GPIO_LDD@OnPortEvent
%endif %- GPIO_LDD
%ifdef SDHC
  %ifdef @SDHC@OnCardInserted
    %define! Description_%@SDHC@OnCardInserted This event is called when a card is inserted into the slot. The card identification number is retrieved and it is passed to the event. If card detection pin is not available, the DetectCards method calls this event. The event services the event of the inherited component and eventually invokes other events.
  %endif %- @SDHC@OnCardInserted
%endif %- SDHC
%ifdef SDHC
  %ifdef @SDHC@OnCardRemoved
    %define! Description_%@SDHC@OnCardRemoved This event is called after a card is removed. The card identification number is retrieved and it is passed to the event. If card detection pin is not available, the SelectCard method calls this event after a try to select the removed card. The event services the event of the inherited component and eventually invokes other events.
  %endif %- @SDHC@OnCardRemoved
%endif %- SDHC
%ifdef SDHC
  %ifdef @SDHC@OnFinished
    %define! Description_%@SDHC@OnFinished This event is called after an operation, initiated by user, has finished. The event services the event of the inherited component and eventually invokes other events.
  %endif %- @SDHC@OnFinished
%endif %- SDHC
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\FatFsMemSDHCSettings.Inc
%define! Abstract Common\FatFsMemSDHCAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"

typedef struct {
  LDD_TDeviceData *SDHCPtr;     /* SDHC component data */
%ifdef GPIO_LDD
  LDD_TDeviceData *GPIOPtr;     /* GPIO component data */
%endif
  bool Finished;                /* Operation end indication */
  bool Inserted;                /* Card insertion indication */
  uint8_t CardId;               /* Initialized card ID */
  LDD_SDHC_TCardInfo CardInfo;  /* Initialized card info */
} TSDData;

#define %'ModuleName'%.BLOCK_SIZE   512            /* user defined block size */


%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
%-BW_CUSTOM_USERTYPE_END


%-BW_DEFINITION_START
%-INHERITED_EVENT_BEGIN SDHC OnCardInserted
%ifdef @SDHC@OnCardInserted
void %@SDHC@OnCardInserted(LDD_TUserData *UserDataPtr, uint8_t Id);

%endif %- @SDHC@OnCardInserted
%-INHERITED_EVENT_END SDHC OnCardInserted
%-INHERITED_EVENT_BEGIN SDHC OnCardRemoved
%ifdef @SDHC@OnCardRemoved
void %@SDHC@OnCardRemoved(LDD_TUserData *UserDataPtr, uint8_t Id);

%endif %- @SDHC@OnCardRemoved
%-INHERITED_EVENT_END SDHC OnCardRemoved
%-INHERITED_EVENT_BEGIN SDHC OnFinished
%ifdef @SDHC@OnFinished
void %@SDHC@OnFinished(LDD_TUserData *UserDataPtr);

%endif %- @SDHC@OnFinished
%-INHERITED_EVENT_END SDHC OnFinished
%-************************************************************************************************************
%-BW_METHOD_BEGIN CardPresent
%ifdef CardPresent
bool %'ModuleName'%.%CardPresent(void);
%define! RetVal
%include Common\FatFsMemSDHCCardPresent.Inc

%endif %- CardPresent
%-BW_METHOD_END CardPresent
%-INHERITED_EVENT_BEGIN GPIO_LDD OnPortEvent
%if defined(GPIO_LDD) & defined(@GPIO_LDD@OnPortEvent)
void %@GPIO_LDD@OnPortEvent(LDD_TUserData *UserDataPtr);

%endif %- @GPIO_LDD@OnPortEvent
%-INHERITED_EVENT_END GPIO_LDD OnPortEvent
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
LDD_TDeviceData* %'ModuleName'%.%Init(LDD_TUserData *UserDataPtr);
%define! ParUserDataPtr
%define! RetVal
%include Common\FatFsMemSDHCInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
void %'ModuleName'%.%Deinit(LDD_TDeviceData *DeviceDataPtr);
%define! ParDeviceDataPtr
%include Common\FatFsMemSDHCDeinit.Inc

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN Activate
%ifdef Activate
void %'ModuleName'%.%Activate(void);
%include Common\FatFsMemSDHCActivate.Inc

%endif %- Activate
%-BW_METHOD_END Activate
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deactivate
%ifdef Deactivate
void %'ModuleName'%.%Deactivate(void);
%include Common\FatFsMemSDHCDeactivate.Inc

%endif %- Deactivate
%-BW_METHOD_END Deactivate
%-************************************************************************************************************
%-BW_METHOD_BEGIN isWriteProtected
%ifdef isWriteProtected
bool %'ModuleName'%.%isWriteProtected(void);
%define! RetVal
%include Common\FatFsMemSDHCisWriteProtected.Inc

%endif %- isWriteProtected
%-BW_METHOD_END isWriteProtected
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN OnCardInserted
%ifdef OnCardInserted
%INTERFACE OnCardInserted
void %OnCardInserted(LDD_TUserData *UserDataPtr, uint8_t Id);
%define! ParUserDataPtr
%define! ParId
%include Common\FatFsMemSDHCOnCardInserted.Inc

%endif %- OnCardInserted
%-BW_METHOD_END OnCardInserted
%-BW_METHOD_BEGIN OnCardRemoved
%ifdef OnCardRemoved
%INTERFACE OnCardRemoved
void %OnCardRemoved(LDD_TUserData *UserDataPtr, uint8_t Id);
%define! ParUserDataPtr
%define! ParId
%include Common\FatFsMemSDHCOnCardRemoved.Inc

%endif %- OnCardRemoved
%-BW_METHOD_END OnCardRemoved
%-BW_METHOD_BEGIN OnFinished
%ifdef OnFinished
%INTERFACE OnFinished
void %OnFinished(LDD_TUserData *UserDataPtr);
%define! ParUserDataPtr
%include Common\FatFsMemSDHCOnFinished.Inc

%endif %- OnFinished
%-BW_METHOD_END OnFinished
%-BW_METHOD_BEGIN OnPortEvent
%ifdef OnPortEvent
%INTERFACE OnPortEvent
void %OnPortEvent(LDD_TUserData *UserDataPtr);
%define! ParUserDataPtr
%include Common\FatFsMemSDHCOnPortEvent.Inc

%endif %- OnPortEvent
%-BW_METHOD_END OnPortEvent
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\FatFsMemSDHCSettings.Inc
%define! Abstract Common\FatFsMemSDHCAbstract.Inc
%include Common\Header.C
%-
%-
%-BW_EVENT_IMPLEMENT_START

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
/*-----------------------------------------------------------------------*/
/* Low level disk I/O module skeleton for FatFs     (C)ChaN, 2007        */
/*-----------------------------------------------------------------------*/
/* This is a stub disk I/O module that acts as front end of the existing */
/* disk I/O modules and attach it to FatFs module with common interface. */
/*-----------------------------------------------------------------------*/

#include "ff.h"
#include "diskio.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
static volatile DSTATUS Stat = STA_NOINIT; /* Disk status */
static TSDData SD;              /* Application data */

#define %'ModuleName'%.SPEED_INDEX_SLOW    %SpeedIndexSlow    /* set by property, has to correspond to less than 400 kHz. */
#define %'ModuleName'%.SPEED_INDEX_NORMAL  %SpeedIndexNormal  /* set by property, up to 12 MHz. */
#define %'ModuleName'%.SPEED_INDEX_FAST    %SpeedIndexFast    /* set by property, depends on card, but could be as high as 48 MHz. */

%-
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-UNLOCKED
/* Internal method prototypes */
%-INTERNAL_LOC_METHOD_BEG SD_Wait
static void SD_Wait(TSDData *SD, bool *ErrorFlag);
%-INTERNAL_LOC_METHOD_END SD_Wait
%-

%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-INHERITED_EVENT_BEGIN SDHC OnCardInserted
%ifdef @SDHC@OnCardInserted
%include Common\GeneralInternal.inc (OnCardInserted)
void %@SDHC@OnCardInserted(LDD_TUserData *UserDataPtr, uint8_t Id)
{
  TSDData *SD = (TSDData*)UserDataPtr;

  SD->CardId = Id;
  %ifdef OnCardInserted
  %OnCardInserted(UserDataPtr, Id);
  %endif OnCardInserted
}

%endif %- @SDHC@OnCardInserted
%-INHERITED_EVENT_END SDHC OnCardInserted
%-INHERITED_EVENT_BEGIN SDHC OnCardRemoved
%ifdef @SDHC@OnCardRemoved
%include Common\GeneralInternal.inc (OnCardRemoved)
void %@SDHC@OnCardRemoved(LDD_TUserData *UserDataPtr, uint8_t Id)
{
  TSDData *SD = (TSDData*)UserDataPtr;

  SD->CardId = %@SDHC@'ModuleName'%.NO_CARD;
  %ifdef OnCardRemoved
  %OnCardRemoved(UserDataPtr, Id);
  %else
  (void)Id; /* unused */
  %endif OnCardRemoved
}

%endif %- @SDHC@OnCardRemoved
%-INHERITED_EVENT_END SDHC OnCardRemoved
%-INHERITED_EVENT_BEGIN SDHC OnFinished
%ifdef @SDHC@OnFinished
%include Common\GeneralInternal.inc (OnFinished)
void %@SDHC@OnFinished(LDD_TUserData *UserDataPtr)
{
  TSDData *SD = (TSDData*)UserDataPtr;

  SD->Finished = TRUE;
  %ifdef OnFinished
  %OnFinished(UserDataPtr);
  %endif OnFinished
}

%endif %- @SDHC@OnFinished
%-INHERITED_EVENT_END SDHC OnFinished
%-************************************************************************************************************
%-BW_METHOD_BEGIN CardPresent
%ifdef CardPresent
%define! RetVal
%include Common\FatFsMemSDHCCardPresent.Inc
bool %'ModuleName'%.%CardPresent(void)
{
  return SD.Inserted;
}

%endif %- CardPresent
%-BW_METHOD_END CardPresent
%-INHERITED_EVENT_BEGIN GPIO_LDD OnPortEvent
%if defined(GPIO_LDD) & defined(@GPIO_LDD@OnPortEvent)
%include Common\GeneralInternal.inc (OnPortEvent)
void %@GPIO_LDD@OnPortEvent(LDD_TUserData *UserDataPtr)
{
  TSDData *SD = (TSDData*)UserDataPtr;

  SD->Inserted = (%@GPIO_LDD@'ModuleName'%.GetFieldValue(SD->GPIOPtr, SD_CARD_DETECT) != 1);
  %ifdef OnPortEvent
  /* Calling inherited event */
  %OnPortEvent(UserDataPtr);
  %endif OnPortEvent
}

%endif %- @GPIO_LDD@OnPortEvent
%-INHERITED_EVENT_END GPIO_LDD OnPortEvent
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG SD_Wait
%define! ParSD
%define! ParErrorFlag
%include Common\GeneralInternalGlobal.inc (SD_Wait)
static void SD_Wait(TSDData *SD, bool *ErrorFlag)
{
  %@Timeout@'ModuleName'%.CounterHandle timeout;
  bool isTimeout = FALSE;      /* Timeout flag */
  LDD_SDHC_TError Error;     /* SDHC error */

  timeout = %@Timeout@'ModuleName'%.GetCounter(1000/%@Timeout@'ModuleName'%.TICK_PERIOD_MS); /* set up timeout counter */
  while (!SD->Finished && !isTimeout){
    isTimeout = %@Timeout@'ModuleName'%.CounterExpired(timeout);
  }
  SD->Finished = FALSE;
  %@Timeout@'ModuleName'%.LeaveCounter(timeout);
  Error = SDHC1_GetError(SD->SDHCPtr, NULL);
  if (Error != LDD_SDHC_ERR_OK) {
    //SD_ErrorHandler(SD, Error);
    *ErrorFlag = TRUE;
  }
}

%-INTERNAL_METHOD_END SD_Wait
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%define! ParUserDataPtr
%define! RetVal
%include Common\FatFsMemSDHCInit.Inc
LDD_TDeviceData* %'ModuleName'%.%Init(LDD_TUserData *UserDataPtr)
{
  bool Error = FALSE;

  (void)UserDataPtr; /* not used */
  SD.SDHCPtr = 0;
%ifdef GPIO_LDD
  SD.GPIOPtr = 0;
%endif
  SD.Finished = FALSE;
  SD.Inserted = FALSE;
  SD.CardId = %@SDHC@'ModuleName'%.NO_CARD;

%ifdef GPIO_LDD
  /* Enable pull-up on GPIO pin used for SD card detection */
  %CDPinSelectPullupCode
  %CDPinEnablePullupCode
  SD.GPIOPtr = %@GPIO_LDD@'ModuleName'%.Init(&SD);
%endif
  SD.SDHCPtr = %@SDHC@'ModuleName'%.Init(&SD);
%ifdef GPIO_LDD
  SD.Inserted = (%@GPIO_LDD@'ModuleName'%.GetFieldValue(SD.GPIOPtr, %CDFieldName) != 1);
%else
  SD.Inserted = FALSE;
%endif
  SD_Wait(&SD, &Error); /* Wait for card reset to finish */
  if (!Error && SD.Inserted) {
    if (%@SDHC@'ModuleName'%.DetectCards(SD.SDHCPtr)!=ERR_OK) {
      Error = TRUE;
    }
    SD_Wait(&SD, &Error);
    if (!Error && SD.CardId != %@SDHC@'ModuleName'%.NO_CARD) {
      /* card detected - selecting card... */
      Error = %@SDHC@'ModuleName'%.SelectCard(SD.SDHCPtr, SD.CardId)!=ERR_OK;
      SD_Wait(&SD, &Error);
    }
    if (!Error) {
      /* card selected - requesting card info... */
      Error = %@SDHC@'ModuleName'%.GetCardInfo(SD.SDHCPtr, &SD.CardInfo)!=ERR_OK;
      SD_Wait(&SD, &Error);
    }
    if (!Error) {
      /* switching gears for higher speed */
      Error = %@SDHC@'ModuleName'%.SelectBusClock(SD.SDHCPtr, (%@SDHC@'ModuleName'%.TBusClock)%'ModuleName'%.SPEED_INDEX_NORMAL)!=ERR_OK;
      SD_Wait(&SD, &Error);
    }
    if (!Error && SD.CardInfo.Caps.HighSpeed) {
      Error = %@SDHC@'ModuleName'%.SelectBusClock(SD.SDHCPtr, (%@SDHC@'ModuleName'%.TBusClock)%'ModuleName'%.SPEED_INDEX_FAST)!=ERR_OK;
      SD_Wait(&SD, &Error);
      /* running at high speed (high slew rate on all the SDHC pins should be set) */
    }
    if (!Error) {
      if (SD.CardInfo.Caps.DataWidths&LDD_SDHC_CARD_DATA_WIDTH_8_BIT) {
        Error = %@SDHC@'ModuleName'%.SetDataWidth(SD.SDHCPtr, LDD_SDHC_CARD_DATA_WIDTH_8_BIT)!=ERR_OK;
      } else if (SD.CardInfo.Caps.DataWidths&LDD_SDHC_CARD_DATA_WIDTH_4_BIT) {
        Error = %@SDHC@'ModuleName'%.SetDataWidth(SD.SDHCPtr, LDD_SDHC_CARD_DATA_WIDTH_4_BIT)!=ERR_OK;
      } else if (SD.CardInfo.Caps.DataWidths&LDD_SDHC_CARD_DATA_WIDTH_1_BIT) {
        Error = %@SDHC@'ModuleName'%.SetDataWidth(SD.SDHCPtr, LDD_SDHC_CARD_DATA_WIDTH_1_BIT)!=ERR_OK;
      }
      SD_Wait(&SD, &Error);
      /* selected highest possible data width */
    }
  }
  return &SD;
}

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
%define! ParDeviceDataPtr
%include Common\FatFsMemSDHCDeinit.Inc
void %'ModuleName'%.%Deinit(LDD_TDeviceData *DeviceDataPtr)
{
  (void)DeviceDataPtr; /* not used */
  /* Deinit components/devices */
  %@SDHC@'ModuleName'%.Deinit(SD.SDHCPtr);
%ifdef GPIO_LDD
  %@GPIO_LDD@'ModuleName'%.Deinit(SD.GPIOPtr);
%endif
}

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN Activate
%ifdef Activate
%include Common\FatFsMemSDHCActivate.Inc
void %'ModuleName'%.%Activate(void)
{
  /* nothing needed right now */
}

%endif %- Activate
%-BW_METHOD_END Activate
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deactivate
%ifdef Deactivate
%include Common\FatFsMemSDHCDeactivate.Inc
void %'ModuleName'%.%Deactivate(void)
{
  /* nothing needed right now */
}

%endif %- Deactivate
%-BW_METHOD_END Deactivate
%-************************************************************************************************************
%-BW_METHOD_BEGIN isWriteProtected
%ifdef isWriteProtected
%define! RetVal
%include Common\FatFsMemSDHCisWriteProtected.Inc
bool %'ModuleName'%.%isWriteProtected(void)
{
%if defined(WP)
  %if %WPLowActive='yes'
  return %@WP@'ModuleName'%.GetVal()==0;
  %else
  return %@WP@'ModuleName'%.GetVal()!=0;
  %endif
%else
  return FALSE; /* no card write protection pin available */
%endif
}

%endif %- isWriteProtected
%-BW_METHOD_END isWriteProtected
%-BW_IMPLEMENT_END
/* END %ModuleName. */
static uint32_t SD_ByteToCardAddress(LDD_SDHC_TCardInfo *CardInfo, uint32_t Address) {
  const uint32_t BlockSizeExp = 9;

  return (CardInfo->Caps.HighCapacity ? Address >> BlockSizeExp : Address);
}

static bool SD_TransferBlock(TSDData *SD, bool Read, uint32_t Address, uint8_t *Buffer) {
  bool Error = FALSE;
  const uint16_t BlockSize = 512;
  const uint16_t BlockCount = 1;
  uint32_t CardAddr = SD_ByteToCardAddress(&SD->CardInfo, Address); /* Read block address */
  LDD_SDHC_TBufferDesc BufferDesc;

  /* Init read buffer descriptor */
  BufferDesc.DataPtr = Buffer;
  BufferDesc.Size = BlockSize;
  /* Read card data block */
  if (%@SDHC@'ModuleName'%.TransferBlocks(SD->SDHCPtr, (Read ? LDD_SDHC_READ : LDD_SDHC_WRITE), CardAddr, &BufferDesc, BlockCount)!=ERR_OK) {
    return TRUE; /* error */
  }
  SD_Wait(SD, &Error);
  return Error;
}
/*-----------------------------------------------------------------------*/
/* Initialize a Drive                                                    */
DSTATUS disk_initialize (
        uint8_t drv                                              %>40 /* Physical drive number (0..) */
)
{
  bool Error = FALSE;

  if (drv!=0) return STA_NOINIT;                                 %>40 /* Supports only single drive */
  if (Stat & STA_NODISK) return Stat;                            %>40 /* No card in the socket */

  if (!Error && SD.Inserted) {
    if (SD.SDHCPtr!=NULL) {
      %@SDHC@'ModuleName'%.Deinit(SD.SDHCPtr);
      SD.SDHCPtr = %@SDHC@'ModuleName'%.Init(&SD);
      SD_Wait(&SD, &Error);
    }
    if (%@SDHC@'ModuleName'%.DetectCards(SD.SDHCPtr)!=ERR_OK) {
      Error = TRUE;
    }
    SD_Wait(&SD, &Error);
    if (!Error && SD.CardId != %@SDHC@'ModuleName'%.NO_CARD) {
      /* card detected - selecting card... */
      if (%@SDHC@'ModuleName'%.SelectCard(SD.SDHCPtr, SD.CardId)!=ERR_OK) {
        Error = TRUE;
      }
      SD_Wait(&SD, &Error);
    }
    if (!Error) {
      /* card selected - requesting card info... */
      if (%@SDHC@'ModuleName'%.GetCardInfo(SD.SDHCPtr, &SD.CardInfo)!=ERR_OK) {
        Error = TRUE;
      }
      SD_Wait(&SD, &Error);
    }
    if (!Error) {
      /* switching gears for higher speed */
      Error = %@SDHC@'ModuleName'%.SelectBusClock(SD.SDHCPtr, FATMEM_SPEED_INDEX_NORMAL)!=ERR_OK;
      SD_Wait(&SD, &Error);
    }
    if (!Error && SD.CardInfo.Caps.HighSpeed) {
      Error = %@SDHC@'ModuleName'%.SelectBusClock(SD.SDHCPtr, FATMEM_SPEED_INDEX_FAST)!=ERR_OK;
      SD_Wait(&SD, &Error);
      /* running at high speed (high slew rate on all the SDHC pins should be set) */
    }
    if (!Error) {
      if (SD.CardInfo.Caps.DataWidths&LDD_SDHC_CARD_DATA_WIDTH_8_BIT) {
        Error = %@SDHC@'ModuleName'%.SetDataWidth(SD.SDHCPtr, LDD_SDHC_CARD_DATA_WIDTH_8_BIT)!=ERR_OK;
      } else if (SD.CardInfo.Caps.DataWidths&LDD_SDHC_CARD_DATA_WIDTH_4_BIT) {
        Error = %@SDHC@'ModuleName'%.SetDataWidth(SD.SDHCPtr, LDD_SDHC_CARD_DATA_WIDTH_4_BIT)!=ERR_OK;
      } else if (SD.CardInfo.Caps.DataWidths&LDD_SDHC_CARD_DATA_WIDTH_1_BIT) {
        Error = %@SDHC@'ModuleName'%.SetDataWidth(SD.SDHCPtr, LDD_SDHC_CARD_DATA_WIDTH_1_BIT)!=ERR_OK;
      }
      SD_Wait(&SD, &Error);
    }
  }

  Stat &= ~STA_NOINIT;                                           %>40 /* Clear STA_NOINIT */
  return Stat;
}
/*-----------------------------------------------------------------------*/
/* Return Disk Status                                                    */
DSTATUS disk_status (
        uint8_t drv                                              %>40 /* Physical drive number (0..) */
)
{
  if (drv!=0) return STA_NOINIT;                                 %>40 /* Supports only single drive */
  return Stat;
}
/*-----------------------------------------------------------------------*/
/* Read Sector(s)                                                        */
DRESULT disk_read (
        uint8_t drv,                                             %>40 /* Physical drive number (0..) */
        uint8_t *buff,                                           %>40 /* Data buffer to store read data */
        uint32_t sector,                                         %>40 /* Sector address (LBA) */
        uint8_t count                                            %>40 /* Number of sectors to read (1..255) */
)
{
  if (drv!=0 || !count) return RES_PARERR;
  if (Stat & STA_NOINIT) return RES_NOTRDY;

  if (count == 1) {                                              %>40 /* Single block read */
    if (SD_TransferBlock(&SD, TRUE, sector*%'ModuleName'%.BLOCK_SIZE, buff)) {
      return RES_ERROR;
    }
    count = 0;
  } else { /* read multiple blocks */
    do {
      if (SD_TransferBlock(&SD, TRUE, sector*%'ModuleName'%.BLOCK_SIZE, buff)) {
        break;
      }
      sector++;
      buff += %'ModuleName'%.BLOCK_SIZE;
    } while(--count);
  }
  return count ? RES_ERROR : RES_OK;
}
/*-----------------------------------------------------------------------*/
/* Write Sector(s)                                                       */
#if _READONLY == 0
DRESULT disk_write (
        uint8_t drv,                                             %>40 /* Physical drive number (0..) */
        const uint8_t *buff,                                     %>40 /* Data to be written */
        uint32_t sector,                                         %>40 /* Sector address (LBA) */
        uint8_t count                                            %>40 /* Number of sectors to write (1..255) */
)
{
  if (drv!=0 || !count) return RES_PARERR;
  if (Stat & STA_NOINIT) return RES_NOTRDY;
  if (Stat & STA_PROTECT) return RES_WRPRT;

  if (count==1) {                                                %>40 /* Single block read */
    if (SD_TransferBlock(&SD, FALSE, sector*%'ModuleName'%.BLOCK_SIZE, (uint8_t*)buff)) {
      return RES_ERROR;
    }
    count = 0;
  } else { /* read multiple blocks */
    do {
      if (SD_TransferBlock(&SD, FALSE, sector*%'ModuleName'%.BLOCK_SIZE, (uint8_t*)buff)) {
        break;
      }
      sector++;
      buff += %'ModuleName'%.BLOCK_SIZE;
    } while(--count);
  }
  return count ? RES_ERROR : RES_OK;
}
#endif /* _READONLY */
/*-----------------------------------------------------------------------*/
/* Miscellaneous Functions                                               */
static bool chk_power(void) { return 1;}
static void power_off(void) {}
static void power_on(void) {}
/*-----------------------------------------------------------------------*/
DRESULT disk_ioctl (
        uint8_t drv,                                             %>40 /* Physical drive number (0..) */
        uint8_t ctrl,                                            %>40 /* Control code */
        void *buff                                               %>40 /* Buffer to send/receive control data */
)
{
  bool Error = FALSE;
  DRESULT res = RES_OK;
  uint8_t *ptr = (uint8_t*)buff;

  if (drv!=0) return RES_PARERR;

  if (ctrl == CTRL_POWER) {
    switch (*ptr) {
      case 0:                                                    %>40 /* Sub control code == 0 (POWER_OFF) */
        if (chk_power()) {
          power_off();                                           %>40 /* Power off */
        }
        break;
      case 1:                                                    %>40 /* Sub control code == 1 (POWER_ON) */
        power_on();                                              %>40 /* Power on */
        break;
      case 2:                                                    %>40 /* Sub control code == 2 (POWER_GET) */
        *(ptr+1) = (uint8_t)chk_power();
        break;
      default:
        res = RES_PARERR;
    } /* switch */
  } else {
    if (Stat & STA_NOINIT) {
      return RES_NOTRDY;
    }
    switch (ctrl) {
      case CTRL_SYNC :                                           %>40 /* Make sure that no pending write process. Do not remove this or written sector might not left updated. */
        %'ModuleName'%.%Activate();
        SD_Wait(&SD, &Error);
        if (Error) {
          res = RES_ERROR;
        }
        break;
      case MMC_GET_READ_BL_LEN:                                  %>40 /* Block Length */
        *(uint16_t*)ptr = SD.CardInfo.BlockLength;
        break;
      case MMC_GET_SDC_VERSION:                                  %>40 /* get CSD Version (1 byte: 1 for 1.xx or MMC, 2 for 2.0 */
        *ptr = 0;
        res = RES_PARERR; /* NYI or does not exist */
        break;
      case GET_SECTOR_COUNT:                                     %>40 /* Get number of sectors on the disk (uint32_t) */
        *(uint32_t*)buff = SD.CardInfo.BlockCount;
        break;
      case GET_SECTOR_SIZE:                                      %>40 /* Get R/W sector size (uint16_t) */
        *(uint16_t*)buff = %'ModuleName'%.BLOCK_SIZE;
        break;
      case GET_BLOCK_SIZE:                                       %>40 /* Get erase block size in unit of sector (uint32_t) */
        *(uint32_t*)buff = 0;
        res = RES_PARERR; /* NYI or does not exist */
        break;
      case MMC_GET_TYPE:                                         %>40 /* Get card type flags (1 byte) */
        if (SD.CardInfo.Type==LDD_SDHC_SD) {
          *ptr = CT_SD1;
        } else if (SD.CardInfo.Type==LDD_SDHC_SDIO) {
          *ptr = CT_SD2;
        } else if (SD.CardInfo.Type==LDD_SDHC_MMC) {
          *ptr = CT_MMC;
        } else if (SD.CardInfo.Type==LDD_SDHC_SDCOMBO) {
          *ptr = CT_SDC;
        } else if (SD.CardInfo.Type==LDD_SDHC_CE_ATA) {
          *ptr = CT_ATA;
        } else {
          *ptr = 0; /* unknown ? */
          res = RES_PARERR;
        }
        break;

      case MMC_GET_CSD:                                          %>40 /* Receive CSD as a data block (16 bytes) */
        *ptr = 0;
        res = RES_PARERR; /* NYI or does not exist */
        break;

      case MMC_GET_CID:                                          %>40 /* Receive CID as a data block (16 bytes) */
        *ptr = 0;
        res = RES_PARERR; /* NYI or does not exist */
        break;

      case MMC_GET_OCR:                                          %>40 /* Receive OCR as an R3 resp (4 bytes) */
       *ptr = 0;
       res = RES_PARERR; /* NYI or does not exist */
       break;

      case MMC_GET_SDSTAT:                                       %>40 /* Receive SD status as a data block (64 bytes) */
        *ptr = 0;
        res = RES_PARERR; /* NYI or does not exist */
        break;

      case MMC_GET_DRIVER_VERSION:                               %>40 /* 1 byte: return: 0 SPI driver, 1 LLD SDHC driver */
        *ptr = 1;
        break;

      case MMC_GET_LLD_INFO:
        /* ptr[0] is the command, ptr[1] is the size of data buffer, followed by the data buffer */
        switch(ptr[0]) {
          case MMC_GET_LLD_CMD_HIGH_CAPACITY:
            ptr[2] = SD.CardInfo.Caps.HighCapacity ? 1 : 0;
            break;
          case MMC_GET_LLD_CMD_HIGH_SPEED:
            ptr[2] = SD.CardInfo.Caps.HighSpeed ? 1 : 0;
            break;
          case MMC_GET_LLD_CMD_LOW_VOLTAGE:
            ptr[2] = SD.CardInfo.Caps.LowVoltage ? 1 : 0;
            break;
          case MMC_GET_LLD_CMD_DATA_WIDTHS:
            ptr[2] = SD.CardInfo.Caps.DataWidths;
            break;
          case MMC_GET_LLD_CMD_OPERATIONS:
            ptr[2] = SD.CardInfo.Caps.Operations;
            break;
          default:
            res = RES_PARERR;
            break;
        }
        break;

      default:
        res = RES_PARERR;
    } /* switch */
    %'ModuleName'%.%Deactivate();
  }
  return res;
}


%-BW_METHOD_BEGIN OnCardInserted
%ifdef OnCardInserted
%IMPLEMENTATION OnCardInserted
%define! ParUserDataPtr
%define! ParId
%include Common\FatFsMemSDHCOnCardInserted.Inc
void %OnCardInserted(LDD_TUserData *UserDataPtr, uint8_t Id)
{
  /* Write your code here ... */
}

%endif %- OnCardInserted
%-BW_METHOD_END OnCardInserted
%-BW_METHOD_BEGIN OnCardRemoved
%ifdef OnCardRemoved
%IMPLEMENTATION OnCardRemoved
%define! ParUserDataPtr
%define! ParId
%include Common\FatFsMemSDHCOnCardRemoved.Inc
void %OnCardRemoved(LDD_TUserData *UserDataPtr, uint8_t Id)
{
  /* Write your code here ... */
}

%endif %- OnCardRemoved
%-BW_METHOD_END OnCardRemoved
%-BW_METHOD_BEGIN OnFinished
%ifdef OnFinished
%IMPLEMENTATION OnFinished
%define! ParUserDataPtr
%include Common\FatFsMemSDHCOnFinished.Inc
void %OnFinished(LDD_TUserData *UserDataPtr)
{
  /* Write your code here ... */
}

%endif %- OnFinished
%-BW_METHOD_END OnFinished
%-BW_METHOD_BEGIN OnPortEvent
%ifdef OnPortEvent
%IMPLEMENTATION OnPortEvent
%define! ParUserDataPtr
%include Common\FatFsMemSDHCOnPortEvent.Inc
void %OnPortEvent(LDD_TUserData *UserDataPtr)
{
  /* Write your code here ... */
}

%endif %- OnPortEvent
%-BW_METHOD_END OnPortEvent
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
  /* Write code here ... */
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This component is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
