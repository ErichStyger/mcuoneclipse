%-Driver generated by the Bean Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Bean Wizard
%- If you change these lines, Bean Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    01.07.2009
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_WriteBlockPage Writes a block with pages of data to the EEPROM
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\24AA_EEPROMSettings.Inc
%define! Abstract Common\24AA_EEPROMAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited components */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"

/* supported device ID's */
#define %'ModuleName'%.DEVICE_ID_8       8 /* 24AA08, 24LC08 */
#define %'ModuleName'%.DEVICE_ID_32     32 /* 24AA08, 24LC32 */
#define %'ModuleName'%.DEVICE_ID_256   256 /* 24AA256, 24LC256, 24FC256 */
#define %'ModuleName'%.DEVICE_ID_512   512 /* 24AA512, 24LC512, 24FC256 */
#define %'ModuleName'%.DEVICE_ID_1025 1025 /* 24AA1025, 24LC1025, 24FC1025 */
/* actual device */
%if %Device = '8'
  #define %'ModuleName'%.DEVICE_ID      %'ModuleName'%.DEVICE_ID_8
%elif %Device = '32'
  #define %'ModuleName'%.DEVICE_ID      %'ModuleName'%.DEVICE_ID_32
%elif %Device = '256'
  #define %'ModuleName'%.DEVICE_ID      %'ModuleName'%.DEVICE_ID_256
%elif (%Device = '512')
  #define %'ModuleName'%.DEVICE_ID      %'ModuleName'%.DEVICE_ID_512
%elif (%Device = '1025')
  #define %'ModuleName'%.DEVICE_ID      %'ModuleName'%.DEVICE_ID_1025
%else
  #error "unknown Device ID %Device?"
%endif

#define %'ModuleName'%.BLOCK_BUF_SIZE %BlockBufSize              %>40 /* buffer used for block read/write. Max is 128. Keep it small to reduce stack consumption. */

#if %'ModuleName'%.DEVICE_ID==%'ModuleName'%.DEVICE_ID_8
  #define %'ModuleName'%.MAX_I2C_ADDR_MASK 0                     %>40 /* A2|A1|A0 are not used */
  #define %'ModuleName'%.MAX_ADDRESS       0x03FF                %>40 /* 8 kBit is 1KByte */
  #define %'ModuleName'%.ADDRT             word                  %>40 /* a word/16bit is enough to hold the address */
  #define %'ModuleName'%.PAGE_SIZE         16                    %>40 /* maximum page size (for page/block operation) */
#elif %'ModuleName'%.DEVICE_ID==%'ModuleName'%.DEVICE_ID_32
  #define %'ModuleName'%.MAX_I2C_ADDR_MASK 7                     %>40 /* A2|A1|A0 form the I2C device address => address cannot be more than 7 (8 devices) */
  #define %'ModuleName'%.MAX_ADDRESS       0x0FFF                %>40 /* 32 kBit are 4KByte */
  #define %'ModuleName'%.ADDRT             word                  %>40 /* a word/16bit is enough to hold the address */
  #define %'ModuleName'%.PAGE_SIZE         8                     %>40 /* maximum page size (for page/block operation) */
#elif %'ModuleName'%.DEVICE_ID==%'ModuleName'%.DEVICE_ID_256
  #define %'ModuleName'%.MAX_I2C_ADDR_MASK 7                     %>40 /* A2|A1|A0 form the I2C device address => address cannot be more than 7 (8 devices) */
  #define %'ModuleName'%.MAX_ADDRESS       0x7FFF                %>40 /* 256 kBit are 32KByte */
  #define %'ModuleName'%.ADDRT             word                  %>40 /* a word/16bit is enough to hold the address */
  #define %'ModuleName'%.PAGE_SIZE         64                    %>40 /* maximum page size (for page/block operation) */
#elif %'ModuleName'%.DEVICE_ID==%'ModuleName'%.DEVICE_ID_512
  #define %'ModuleName'%.MAX_I2C_ADDR_MASK 7                     %>40 /* A2|A1|A0 form the I2C device address => address cannot be more than 7 (8 devices) */
  #define %'ModuleName'%.MAX_ADDRESS       0xFFFF                %>40 /* 512 kBit are 64KByte */
  #define %'ModuleName'%.ADDRT             word                  %>40 /* a word/16bit is enough to hold the address */
  #define %'ModuleName'%.PAGE_SIZE         128                   %>40 /* maximum page size (for page/block operation) */
#elif %'ModuleName'%.DEVICE_ID==%'ModuleName'%.DEVICE_ID_1025
  #define %'ModuleName'%.MAX_I2C_ADDR_MASK 3                     %>40 /* A1|A0 form the I2C device address => address cannot be more than 3 (4 devices) */
  #define %'ModuleName'%.MAX_ADDRESS       0x1FFFF               %>40 /* 1024 kBit are 128KByte */
  #define %'ModuleName'%.ADDRT             dword                 %>40 /* a longword/32bit is needed to hold the address */
  #define %'ModuleName'%.PAGE_SIZE         128                   %>40 /* maximum page size (for page/block operation) */
#else
  #error "unknown device?"
#endif

%if %DoAcknowledgePolling = 'yes'
#define %'ModuleName'%.DO_ACKNOWLEDGE_POLLING    1               %>40 /* Perform acknowledge polling in the driver */
#define %'ModuleName'%.PAGE_WRITE_TIME_MS        %PageWriteTimeMs%>40 /* Page Write Time as per data sheet */
%else
#define %'ModuleName'%.DO_ACKNOWLEDGE_POLLING    0               %>40 /* No acknowledge polling in the driver */
%endif
%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

#ifndef __BWUserType_%'ModuleName'_Address
#define __BWUserType_%'ModuleName'_Address
  typedef  %'ModuleName'%.ADDRT %'ModuleName'%.Address;          %>40/* A type large enought to hold the address, depending on the EEPROM used. */
#endif

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%ifdef ParseCommand
#define %'ModuleName'%.PARSE_COMMAND_ENABLED  1  /* set to 1 if method ParseCommand() is present, 0 otherwise */
%else
#define %'ModuleName'%.PARSE_COMMAND_ENABLED  0 /* set to 1 if method ParseCommand() is present, 0 otherwise */
%endif %- ParseCommand

%-
%-BW_CUSTOM_USERTYPE_END
%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteByte
%ifdef WriteByte
byte %'ModuleName'%.%WriteByte(%'ModuleName'_Address addr, byte data);
%define! Paraddr
%define! Pardata
%define! RetVal
%include Common\24AA_EEPROMWriteByte.Inc

%endif %- WriteByte
%-BW_METHOD_END WriteByte
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadByte
%ifdef ReadByte
byte %'ModuleName'%.%ReadByte(%'ModuleName'_Address addr, byte *data);
%define! Paraddr
%define! Pardata
%define! RetVal
%include Common\24AA_EEPROMReadByte.Inc

%endif %- ReadByte
%-BW_METHOD_END ReadByte
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadBlock
%ifdef ReadBlock
byte %'ModuleName'%.%ReadBlock(%'ModuleName'_Address addr, byte *data, word dataSize);
%define! Paraddr
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\24AA_EEPROMReadBlock.Inc

%endif %- ReadBlock
%-BW_METHOD_END ReadBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteBlock
%ifdef WriteBlock
byte %'ModuleName'%.%WriteBlock(%'ModuleName'_Address addr, byte *data, word dataSize);
%define! Paraddr
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\24AA_EEPROMWriteBlock.Inc

%endif %- WriteBlock
%-BW_METHOD_END WriteBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN Test
%ifdef Test
byte %'ModuleName'%.%Test(void);
%define! RetVal
%include Common\24AA_EEPROMTest.Inc

%endif %- Test
%-BW_METHOD_END Test
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteProtect
%ifdef WriteProtect
void %'ModuleName'%.%WriteProtect(void);
%include Common\24AA_EEPROMWriteProtect.Inc

%endif %- WriteProtect
%-BW_METHOD_END WriteProtect
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteUnprotect
%ifdef WriteUnprotect
void %'ModuleName'%.%WriteUnprotect(void);
%include Common\24AA_EEPROMWriteUnprotect.Inc

%endif %- WriteUnprotect
%-BW_METHOD_END WriteUnprotect
%-************************************************************************************************************
%-BW_METHOD_BEGIN SelectDevice
%ifdef SelectDevice
byte %'ModuleName'%.%SelectDevice(byte addrI2C);
%define! ParaddrI2C
%define! RetVal
%include Common\24AA_EEPROMSelectDevice.Inc

%endif %- SelectDevice
%-BW_METHOD_END SelectDevice
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
byte %'ModuleName'%.%ParseCommand(const unsigned char *cmd, bool *handled, const %@Shell@'ModuleName'%.StdIOType *io);
%define! Parcmd
%define! Parhandled
%define! Pario
%define! RetVal
%include Common\MAG3110ParseCommand.Inc

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetSelectedDevice
%ifdef GetSelectedDevice
byte %'ModuleName'%.%GetSelectedDevice(void);
%define! RetVal
%include Common\24AA_EEPROMGetSelectedDevice.Inc

%endif %- GetSelectedDevice
%-BW_METHOD_END GetSelectedDevice
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG WriteBlockPage
byte %'ModuleName'%.WriteBlockPage(%'ModuleName'_Address addr, byte *data, word dataSize);
%define! Paraddr
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\GeneralInternal.inc (WriteBlockPage)

%-INTERNAL_METHOD_END WriteBlockPage
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\24AA_EEPROMSettings.Inc
%define! Abstract Common\24AA_EEPROMAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%if defined(Timeout)
#define %'ModuleName'%.TIMEOUT_BYTE_MS        %timeoutByteMs  /* number of milli seconds as specified in properties for byte write */
#define %'ModuleName'%.TIMEOUT_BYTE_TICKS     (%'ModuleName'%.TIMEOUT_BYTE_MS/(%@Timeout@'ModuleName'%.TICK_PERIOD_MS))
#define %'ModuleName'%.TIMEOUT_BLOCK_MS       %timeoutBlockMs  /* number of milli seconds as specified in properties for block write */
#define %'ModuleName'%.TIMEOUT_BLOCK_TICKS    (%'ModuleName'%.TIMEOUT_BLOCK_MS/(%@Timeout@'ModuleName'%.TICK_PERIOD_MS))
%endif
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%-
%ifdef SelectDevice
static byte %'ModuleName'%.I2CAddress = (%DeviceAddress&%'ModuleName'%.MAX_I2C_ADDR_MASK);%>40 /* current I2C address used */
%else
#define %'ModuleName'%.I2CAddress (%DeviceAddress&%'ModuleName'%.MAX_I2C_ADDR_MASK)%>40 /* address defined by the A2|A1|A0 pins */
%endif %- SelectDevice

/* macros for the control byte: */
#define %'ModuleName'%.CTRL_NBL       (0x0A<<3)                  %>40 /* control byte high nibble. Typically this is 1010 (shifted by one to the right) */
#if %'ModuleName'%.DEVICE_ID==%'ModuleName'%.DEVICE_ID_8
  #define %'ModuleName'%.CTRL_ADDR      0                        %>40 /* no additional address bits */
  /* define control byte as 1010|Bx|B1|B0 */
  #define %'ModuleName'%.BANK_0         (0<<2)                   %>40 /* B0 bit (0) inside the CTRL_BYTE: 1010|B0|A1|A0 */
  #define %'ModuleName'%.BANK_1         (1<<2)                   %>40 /* B0 bit (1) inside the CTRL_BYTE: 1010|B0|A1|A0 */
  #define %'ModuleName'%.CTRL_BYTE      (%'ModuleName'%.CTRL_NBL|%'ModuleName'%.CTRL_ADDR)%>40 /* 1010|B0|A1|A0 */
  #define %'ModuleName'%.DEVICE_ADDR(addr) \
    (((addr)&0x100)? \
        (%'ModuleName'%.CTRL_BYTE|%'ModuleName'%.BANK_1) \
      : (%'ModuleName'%.CTRL_BYTE|%'ModuleName'%.BANK_0) )       %>40 /* 7bit address of device used to select device */
#elif (%'ModuleName'%.DEVICE_ID==%'ModuleName'%.DEVICE_ID_32) || (%'ModuleName'%.DEVICE_ID==%'ModuleName'%.DEVICE_ID_256) || (%'ModuleName'%.DEVICE_ID==%'ModuleName'%.DEVICE_ID_512)
  #define %'ModuleName'%.CTRL_ADDR      %'ModuleName'%.I2CAddress%>40 /* address inside control byte */
  /* define control byte as 1010|A2|A1|A0 */
  #define %'ModuleName'%.CTRL_BYTE         (%'ModuleName'%.CTRL_NBL|%'ModuleName'%.CTRL_ADDR)%>40 /* 1010|A2|A1|A0 */
  #define %'ModuleName'%.DEVICE_ADDR(addr) %'ModuleName'%.CTRL_BYTE%>40 /* 7bit address of device used to select device */
#elif %'ModuleName'%.DEVICE_ID==%'ModuleName'%.DEVICE_ID_1025
  #define %'ModuleName'%.CTRL_ADDR      %'ModuleName'%.I2CAddress%>40 /* address inside control byte */
  /* define control byte as 1010|Bx|A1|A0 */
  #define %'ModuleName'%.BANK_0         (0<<2)                   %>40 /* B0 bit (0) inside the CTRL_BYTE: 1010|B0|A1|A0 */
  #define %'ModuleName'%.BANK_1         (1<<2)                   %>40 /* B0 bit (1) inside the CTRL_BYTE: 1010|B0|A1|A0 */
  #define %'ModuleName'%.CTRL_BYTE      (%'ModuleName'%.CTRL_NBL|%'ModuleName'%.CTRL_ADDR)%>40 /* 1010|B0|A1|A0 */
  #define %'ModuleName'%.DEVICE_ADDR(addr) \
    (((addr)&0x10000)? \
        (%'ModuleName'%.CTRL_BYTE|%'ModuleName'%.BANK_1) \
      : (%'ModuleName'%.CTRL_BYTE|%'ModuleName'%.BANK_0) )       %>40 /* 7bit address of device used to select device */
#endif

%if defined(Shell)
static uint8_t PrintStatus(const %@Shell@'ModuleName'%.StdIOType *io) {
  unsigned char buf[32];

  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"%'ModuleName'", (unsigned char*)"\r\n", io->stdOut);

  %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"0x");
  %@Utility@'ModuleName'%.strcatNum8Hex(buf, sizeof(buf), (uint8_t)%'ModuleName'%.DEVICE_ADDR(0));
  %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)" (for memory @0x00)\r\n");
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  I2C Addr", buf, io->stdOut);

  %@Utility@'ModuleName'%.Num16uToStr(buf, sizeof(buf), (uint16_t)%'ModuleName'%.DEVICE_ID);
  %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  Type", buf, io->stdOut);

  return ERR_OK;
}

static uint8_t PrintHelp(const %@Shell@'ModuleName'%.StdIOType *io) {
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"%'ModuleName'", (unsigned char*)"Group of %'ModuleName' commands\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  help|status", (unsigned char*)"Print help or status information\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  read 0x<addr>", (unsigned char*)"Read a byte from an address\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  write 0x<addr> 0x<value>", (unsigned char*)"Write a byte to an address\r\n", io->stdOut);
  return ERR_OK;
}

%endif
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteByte
%ifdef WriteByte
%define! Paraddr
%define! Pardata
%define! RetVal
%include Common\24AA_EEPROMWriteByte.Inc
byte %'ModuleName'%.%WriteByte(%'ModuleName'_Address addr, byte data)
{
  uint8_t res, block[3];
%if defined(Timeout)
#if %'ModuleName'%.DO_ACKNOWLEDGE_POLLING && %'ModuleName'%.TIMEOUT_BYTE_TICKS>0
  %@Timeout@'ModuleName'%.CounterHandle timeout;
  bool isTimeout;
#endif
%endif

  res = %@I2C@'ModuleName'%.SelectSlave(%'ModuleName'%.DEVICE_ADDR(addr));
  if (res != ERR_OK) {
    (void)%@I2C@'ModuleName'%.UnselectSlave();
    return res;
  }
  block[0] = (uint8_t)(addr>>8);                                 %>40 /* high byte of address */
  block[1] = (uint8_t)(addr&0xff);                               %>40 /* low byte of address */
  block[2] = data; /* switch to read mode */
  res = %@I2C@'ModuleName'%.WriteBlock(block, sizeof(block), %@I2C@'ModuleName'%.SEND_STOP);%>40 /* send address and data */
  if (res != ERR_OK) {
    (void)%@I2C@'ModuleName'%.UnselectSlave();
    return res;
  }
#if %'ModuleName'%.DO_ACKNOWLEDGE_POLLING
  /* do acknowledge polling */
  //%@Wait@'ModuleName'%.WaitOSms(%'ModuleName'%.PAGE_WRITE_TIME_MS);
  block[0] = 0xff; /* dummy value */
%if defined(Timeout)
#if %'ModuleName'%.TIMEOUT_BYTE_TICKS>0
    timeout = %@Timeout@'ModuleName'%.GetCounter(%'ModuleName'%.TIMEOUT_BYTE_TICKS); /* set up timeout counter */
    if (timeout==%@Timeout@'ModuleName'%.OUT_OF_HANDLE) {
      (void)%@I2C@'ModuleName'%.UnselectSlave();
      return ERR_FAILED;
    }
#endif
%endif
  do {
%if defined(Timeout)
#if %'ModuleName'%.TIMEOUT_BYTE_TICKS>0
    isTimeout = %@Timeout@'ModuleName'%.CounterExpired(timeout);
    if (isTimeout) {
      break; /* break while() */
    }
#endif
%endif
    res = %@I2C@'ModuleName'%.WriteBlock(block, 1, %@I2C@'ModuleName'%.SEND_STOP);%>40 /* send address and data */
  } while(res!=ERR_OK); /* wait until we get an ACK */
%if defined(Timeout)
#if %'ModuleName'%.TIMEOUT_BYTE_TICKS>0
    %@Timeout@'ModuleName'%.LeaveCounter(timeout);
    if (isTimeout) {
      res = ERR_FAILED;
    }
#endif
%endif
#endif
  if (res != ERR_OK) {
    (void)%@I2C@'ModuleName'%.UnselectSlave();
    return res;
  }
  return %@I2C@'ModuleName'%.UnselectSlave();
}

%endif %- WriteByte
%-BW_METHOD_END WriteByte
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadByte
%ifdef ReadByte
%define! Paraddr
%define! Pardata
%define! RetVal
%include Common\24AA_EEPROMReadByte.Inc
byte %'ModuleName'%.%ReadByte(%'ModuleName'_Address addr, byte *data)
{
  uint8_t res;
#if %'ModuleName'%.DEVICE_ID!=%'ModuleName'%.DEVICE_ID_8
  uint8_t addr16[2];                                             %>40 /* big endian address on I2C bus needs to be 16bit */

  addr16[0] = (uint8_t)(addr>>8); /* 16 bit address must be in big endian format */
  addr16[1] = (uint8_t)(addr&0xff);
#endif
  res = %@I2C@'ModuleName'%.SelectSlave(%'ModuleName'%.DEVICE_ADDR(addr));
  if (res != ERR_OK) {
    (void)%@I2C@'ModuleName'%.UnselectSlave();
    return res;
  }
#if %'ModuleName'%.DEVICE_ID==%'ModuleName'%.DEVICE_ID_8
  res = %@I2C@'ModuleName'%.WriteBlock(&addr, 1, %@I2C@'ModuleName'%.DO_NOT_SEND_STOP);%>40 /* send 8bit address */
#else /* use 16bit address */
  res = %@I2C@'ModuleName'%.WriteBlock(&addr16, 2, %@I2C@'ModuleName'%.DO_NOT_SEND_STOP);%>40 /* send 16bit address */
#endif
  if (res != ERR_OK) {
    (void)%@I2C@'ModuleName'%.UnselectSlave();
    return res;
  }
  res = %@I2C@'ModuleName'%.ReadBlock(data, 1, %@I2C@'ModuleName'%.SEND_STOP);%>40 /* read data byte from bus */
  if (res != ERR_OK) {
    (void)%@I2C@'ModuleName'%.UnselectSlave();
    return res;
  }
  return %@I2C@'ModuleName'%.UnselectSlave();
}

%endif %- ReadByte
%-BW_METHOD_END ReadByte
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadBlock
%ifdef ReadBlock
%define! Paraddr
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\24AA_EEPROMReadBlock.Inc
byte %'ModuleName'%.%ReadBlock(%'ModuleName'_Address addr, byte *data, word dataSize)
{
  uint8_t res;
#if %'ModuleName'%.DEVICE_ID!=%'ModuleName'%.DEVICE_ID_8
  uint8_t addr16[2];                                             %>40 /* big endian address on I2C bus needs to be 16bit */

  addr16[0] = (uint8_t)(addr>>8); /* 16 bit address must be in big endian format */
  addr16[1] = (uint8_t)(addr&0xff);
#endif
  res = %@I2C@'ModuleName'%.SelectSlave(%'ModuleName'%.DEVICE_ADDR(addr));
  if (res != ERR_OK) {
    (void)%@I2C@'ModuleName'%.UnselectSlave();
    return res;
  }
#if %'ModuleName'%.DEVICE_ID==%'ModuleName'%.DEVICE_ID_8
  res = %@I2C@'ModuleName'%.WriteBlock(&addr, 1, %@I2C@'ModuleName'%.DO_NOT_SEND_STOP);%>40 /* send 8bit address */
#else
  res = %@I2C@'ModuleName'%.WriteBlock(&addr16, 2, %@I2C@'ModuleName'%.DO_NOT_SEND_STOP);%>40 /* send 16bit address */
#endif
  if (res != ERR_OK) {
    (void)%@I2C@'ModuleName'%.UnselectSlave();
    return res;
  }
  res = %@I2C@'ModuleName'%.ReadBlock(data, dataSize, %@I2C@'ModuleName'%.SEND_STOP);
  if (res != ERR_OK) {
    (void)%@I2C@'ModuleName'%.UnselectSlave();
    return res;
  }
  return %@I2C@'ModuleName'%.UnselectSlave();
}

%endif %- ReadBlock
%-BW_METHOD_END ReadBlock
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG WriteBlockPage
%define! Paraddr
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\GeneralInternal.inc (WriteBlockPage)
#ifdef __HIWARE__
#pragma MESSAGE DISABLE C1855 /* recursive function call */
#endif
byte %'ModuleName'%.WriteBlockPage(%'ModuleName'_Address addr, byte *data, word dataSize)
{
%if defined(Timeout)
#if %'ModuleName'%.DO_ACKNOWLEDGE_POLLING && %'ModuleName'%.TIMEOUT_BLOCK_TICKS>0
  %@Timeout@'ModuleName'%.CounterHandle timeout;
  bool isTimeout;
#endif
%endif
  uint8_t res, i, *p, block[%'ModuleName'%.BLOCK_BUF_SIZE+2];    %>40 /* additional 2 bytes for the address */
  uint16_t eepromPage = (uint16_t)(addr/%'ModuleName'%.PAGE_SIZE);
  uint8_t offset = (uint8_t)(addr%%%'ModuleName'%.PAGE_SIZE);

  if (dataSize==0 || dataSize>%'ModuleName'%.BLOCK_BUF_SIZE) {
    return ERR_OVERFLOW;                                         %>40 /* you may increase the buffer size in the properties? */
  }
  if (dataSize>%'ModuleName'%.PAGE_SIZE) {
    uint16_t size;

    size = (uint16_t)(%'ModuleName'%.PAGE_SIZE-offset);
    if (size!=0) {
      res = %'ModuleName'%.WriteBlock(addr, data, size);         %>40 /* first page write */
      if (res != ERR_OK) {
        return res;
      }
      data += size; /* increment data pointer */
      addr += size; /* increment address */
      dataSize -= size; /* reduce size */
    }
    /* write multiple block of PAGE_SIZE */
    while (dataSize>%'ModuleName'%.PAGE_SIZE) {
      res = %'ModuleName'%.WriteBlock(addr, data, %'ModuleName'%.PAGE_SIZE);
      if (res != ERR_OK) {
        return res;
      }
      data += %'ModuleName'%.PAGE_SIZE; /* increment data pointer */
      addr += %'ModuleName'%.PAGE_SIZE; /* increment address */
      dataSize -= %'ModuleName'%.PAGE_SIZE; /* reduce size */
    }
    /* write remainder (if any) */
    if (dataSize>0) {
      return %'ModuleName'%.WriteBlock(addr, data, dataSize);
    }
    return ERR_OK;
  }
  if (offset+dataSize <= %'ModuleName'%.PAGE_SIZE) {             %>40 /* no page boundary crossing */
    res = %@I2C@'ModuleName'%.SelectSlave(%'ModuleName'%.DEVICE_ADDR(addr));
    if (res != ERR_OK) {
      (void)%@I2C@'ModuleName'%.UnselectSlave();
      return res;
    }
    block[0] = (uint8_t)(addr>>8);                               %>40 /* high byte of address */
    block[1] = (uint8_t)(addr&0xff);                             %>40 /* low byte of address */
    /* copy block */
    p = &block[2]; i = (uint8_t)dataSize;
    while(i>0) {
      *p++ = *data++;
      i--;
    }
    res = %@I2C@'ModuleName'%.WriteBlock(block, dataSize+2, %@I2C@'ModuleName'%.SEND_STOP);%>40 /* send address and data */
    if (res != ERR_OK) {
      (void)%@I2C@'ModuleName'%.UnselectSlave();
      return res;
    }
#if %'ModuleName'%.DO_ACKNOWLEDGE_POLLING
    /* do acknowledge polling */
    //%@Wait@'ModuleName'%.WaitOSms(%'ModuleName'%.PAGE_WRITE_TIME_MS);
%if defined(Timeout)
#if %'ModuleName'%.TIMEOUT_BLOCK_TICKS>0
    timeout = %@Timeout@'ModuleName'%.GetCounter(%'ModuleName'%.TIMEOUT_BLOCK_TICKS); /* set up timeout counter */
    if (timeout==%@Timeout@'ModuleName'%.OUT_OF_HANDLE) {
      (void)%@I2C@'ModuleName'%.UnselectSlave();
      return ERR_OVERFLOW;
    }
#endif
%endif
    block[0] = 0xff; /* dummy value */
    do {
      res = %@I2C@'ModuleName'%.WriteBlock(block, 1, %@I2C@'ModuleName'%.SEND_STOP);%>40 /* send address and data */
%if defined(Timeout)
#if %'ModuleName'%.TIMEOUT_BLOCK_TICKS>0
      isTimeout = %@Timeout@'ModuleName'%.CounterExpired(timeout);
      if (isTimeout) {
        res = ERR_FAULT;
        break;
      }
#endif
%endif
    } while(res!=ERR_OK); /* wait until we get an ACK */
%if defined(Timeout)
#if %'ModuleName'%.TIMEOUT_BLOCK_TICKS>0
    %@Timeout@'ModuleName'%.LeaveCounter(timeout);
    if (isTimeout) {
      res = ERR_FAILED;
    }
#endif
%endif
    if (res != ERR_OK) {
      (void)%@I2C@'ModuleName'%.UnselectSlave();
      return res;
    }
    return %@I2C@'ModuleName'%.UnselectSlave();
#endif
  } else { /* crossing page boundaries: make two page writes */
    res = %'ModuleName'%.WriteBlock(addr, data, (uint16_t)(%'ModuleName'%.PAGE_SIZE-offset));%>40 /* first page write */
    if (res != ERR_OK) {
      return res;
    }
    res = %'ModuleName'%.WriteBlock((%'ModuleName'_Address)((eepromPage+1)*%'ModuleName'%.PAGE_SIZE),
       data+(%'ModuleName'%.PAGE_SIZE-offset),
       (uint16_t)(dataSize-(%'ModuleName'%.PAGE_SIZE-offset)));  %>40 /* first page write */
    if (res != ERR_OK) {
      return res;
    }
  }
  return res;
}
#ifdef __HIWARE__
  #pragma MESSAGE DEFAULT C1855 /* recursive function call */
#endif

%-INTERNAL_METHOD_END WriteBlockPage
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteBlock
%ifdef WriteBlock
%define! Paraddr
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\24AA_EEPROMWriteBlock.Inc
byte %'ModuleName'%.%WriteBlock(%'ModuleName'_Address addr, byte *data, word dataSize)
{
  int32_t size;

  if (dataSize<=%'ModuleName'%.BLOCK_BUF_SIZE) { /* fits into internal buffer */
    return %'ModuleName'%.WriteBlock(addr, data, dataSize);
  }
  size = dataSize;
  while(size>=%'ModuleName'%.BLOCK_BUF_SIZE) { /* write in chunks %'ModuleName'%.BLOCK_BUF_SIZE */
    if (%'ModuleName'%.WriteBlock(addr, data, %'ModuleName'%.BLOCK_BUF_SIZE)!=ERR_OK) {
      return ERR_FAILED;
    }
    addr += %'ModuleName'%.BLOCK_BUF_SIZE;
    data += %'ModuleName'%.BLOCK_BUF_SIZE;
    size -= %'ModuleName'%.BLOCK_BUF_SIZE;
  }
  if (size>0) { /* write remainder which is < EE241_BLOCK_BUF_SIZE  */
    if (%'ModuleName'%.WriteBlock(addr, data, size)!=ERR_OK) {
      return ERR_FAILED;
    }
  }
  return ERR_OK;
}

%endif %- WriteBlock
%-BW_METHOD_END WriteBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN Test
%ifdef Test
%define! RetVal
%include Common\24AA_EEPROMTest.Inc
#include <string.h> /* for strcmp() */
static void Err(void) {
  static uint8_t errCnt = 0;

  errCnt++;
}

byte %'ModuleName'%.%Test(void)
{
  uint8_t res, val, data[16];

  res = %'ModuleName'%.WriteByte(0x0000, 0);
  if (res != ERR_OK) {
    Err();
    return res;
  }
  res = %'ModuleName'%.WriteByte(0x0001, 1);
  if (res != ERR_OK) {
    Err();
    return res;
  }
  res = %'ModuleName'%.WriteByte(0x0002, 2);
  if (res != ERR_OK) {
    Err();
    return res;
  }
  res = %'ModuleName'%.WriteByte(0x0003, 3);
  if (res != ERR_OK) {
    Err();
    return res;
  }
  res = %'ModuleName'%.WriteByte(0x0004, 4);
  if (res != ERR_OK) {
    Err();
    return res;
  }
  res = %'ModuleName'%.WriteByte(0x0010, 5);
  if (res != ERR_OK) {
    Err();
    return res;
  }

  res = %'ModuleName'%.ReadByte(0x0000, &val);
  if (res != ERR_OK) {
    Err();
    return res;
  }
  if (val != 0) {
    Err();
    return ERR_FAULT;
  }
  res = %'ModuleName'%.ReadByte(0x0001, &val);
  if (res != ERR_OK) {
    Err();
    return res;
  }
  if (val != 1) {
    Err();
    return ERR_FAULT;
  }
  res = %'ModuleName'%.ReadByte(0x0002, &val);
  if (res != ERR_OK) {
    Err();
    return res;
  }
  if (val != 2) {
    Err();
    return ERR_FAULT;
  }
  res = %'ModuleName'%.ReadByte(0x0003, &val);
  if (res != ERR_OK) {
    Err();
    return res;
  }
  if (val != 3) {
    Err();
    return ERR_FAULT;
  }
  res = %'ModuleName'%.ReadByte(0x0004, &val);
  if (res != ERR_OK) {
    Err();
    return res;
  }
  if (val != 4) {
    Err();
    return ERR_FAULT;
  }
  res = %'ModuleName'%.ReadByte(0x0010, &val);
  if (res != ERR_OK) {
    Err();
    return res;
  }
  if (val != 5) {
    Err();
    return ERR_FAULT;
  }
  res = %'ModuleName'%.WriteBlock(0x10, (uint8_t*)"Hello", sizeof("Hello"));
  if (res != ERR_OK) {
    Err();
    return res;
  }
  res = %'ModuleName'%.ReadBlock(0x10, data, sizeof(data));
  if (res != ERR_OK) {
    Err();
    return res;
  }
  if (strcmp((char*)"Hello", (char*)data) != 0) {
    Err();
    return ERR_FAULT;
  }
  /* testing crossing page boundary */
  res = %'ModuleName'%.WriteBlock(%'ModuleName'%.PAGE_SIZE-5, (uint8_t*)"Hello World!", sizeof("Hello World!"));
  if (res != ERR_OK) {
    Err();
    return res;
  }
  res = %'ModuleName'%.ReadBlock(%'ModuleName'%.PAGE_SIZE-5, data, sizeof(data));
  if (res != ERR_OK) {
    Err();
    return res;
  }
  if (strcmp((char*)"Hello World!", (char*)data) != 0) return ERR_FAULT;
#if %'ModuleName'%.DEVICE_ID==%'ModuleName'%.DEVICE_ID_1025
  /* testing writing to second bank */
  res = %'ModuleName'%.WriteBlock(0x10005, (uint8_t*)"Hello bank 1!", sizeof("Hello bank 1!"));
  if (res != ERR_OK) {
    Err();
    return res;
  }
  res = %'ModuleName'%.ReadBlock(0x10005, data,(uint8_t*) sizeof(data));
  if (res != ERR_OK) {
    Err();
    return res;
  }
  if (strcmp((char*)"Hello bank 1!", (char*)data) != 0) {
    Err();
    return ERR_FAULT;
  }
#endif
  return ERR_OK;
}

%endif %- Test
%-BW_METHOD_END Test
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteProtect
%ifdef WriteProtect
%include Common\24AA_EEPROMWriteProtect.Inc
void %'ModuleName'%.%WriteProtect(void)
{
%ifdef WP
  %@WP@'ModuleName'%.SetVal();                                   %>40 /* Tie pin to Vcc/High level to protect the memory */
%else
  #warning "There is no WP (Write Protect) pin defined?"
%endif
}

%endif %- WriteProtect
%-BW_METHOD_END WriteProtect
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteUnprotect
%ifdef WriteUnprotect
%include Common\24AA_EEPROMWriteUnprotect.Inc
void %'ModuleName'%.%WriteUnprotect(void)
{
%ifdef WP
  %@WP@'ModuleName'%.ClrVal();                                   %>40 /* Tie pin to Vss/Low level to allow writing to the memory */
%else
  #warning "There is no WP (write protect) pin defined?"
%endif
}

%endif %- WriteUnprotect
%-BW_METHOD_END WriteUnprotect
%-************************************************************************************************************
%-BW_METHOD_BEGIN SelectDevice
%ifdef SelectDevice
%define! ParaddrI2C
%define! RetVal
%include Common\24AA_EEPROMSelectDevice.Inc
byte %'ModuleName'%.%SelectDevice(byte addrI2C)
{
  if (addrI2C>%'ModuleName'%.MAX_I2C_ADDR_MASK) {
    return ERR_VALUE;                                            %>40 /* Device address too large for device address pins available. */
  }
  %'ModuleName'%.I2CAddress = addrI2C;
  return ERR_OK;
}

%endif %- SelectDevice
%-BW_METHOD_END SelectDevice
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetSelectedDevice
%ifdef GetSelectedDevice
%define! RetVal
%include Common\24AA_EEPROMGetSelectedDevice.Inc
byte %'ModuleName'%.%GetSelectedDevice(void)
{
 return %'ModuleName'%.I2CAddress;
}

%endif %- GetSelectedDevice
%-BW_METHOD_END GetSelectedDevice
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
%define! Parcmd
%define! Parhandled
%define! Pario
%define! RetVal
%include Common\24AA_EEPROMParseCommand.Inc
byte %'ModuleName'%.%ParseCommand(const unsigned char *cmd, bool *handled, const %@Shell@'ModuleName'%.StdIOType *io)
{
  const unsigned char *p;
  uint16_t addr16;
  uint8_t val8, buf[8];

  if (%@Utility@'ModuleName'%.strcmp((char*)cmd, %@Shell@'ModuleName'%.CMD_HELP)==0 || %@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' help")==0) {
    *handled = TRUE;
    return PrintHelp(io);
  } else if ((%@Utility@'ModuleName'%.strcmp((char*)cmd, %@Shell@'ModuleName'%.CMD_STATUS)==0) || (%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' status")==0)) {
    *handled = TRUE;
    return PrintStatus(io);
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, (char*)"%'ModuleName' read ", sizeof("%'ModuleName' read ")-1)==0) {
    p = cmd+sizeof("%'ModuleName' read ")-1;
    if (%@Utility@'ModuleName'%.ScanHex16uNumber(&p, &addr16)==ERR_OK) {
      if (%'ModuleName'%.%ReadByte(addr16, &val8)==ERR_OK) {
        %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"0x");
        %@Utility@'ModuleName'%.strcatNum8Hex(buf, sizeof(buf), val8);
        %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
        %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
      } else {
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"**** read failed!\r\n", io->stdErr);
      }
    } else {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"**** wrong address\r\n", io->stdErr);
    }
    *handled = TRUE;
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, (char*)"%'ModuleName' write ", sizeof("%'ModuleName' write ")-1)==0) {
    p = cmd+sizeof("%'ModuleName' write ")-1;
    if (%@Utility@'ModuleName'%.ScanHex16uNumber(&p, &addr16)==ERR_OK) {
      if (%@Utility@'ModuleName'%.ScanHex8uNumber(&p, &val8)==ERR_OK) {
        if (%'ModuleName'%.%WriteByte(addr16, val8)!=ERR_OK) {
          %@Shell@'ModuleName'%.SendStr((unsigned char*)"**** write failed!\r\n", io->stdErr);
        }
      } else {
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"**** wrong value\r\n", io->stdErr);
      }
    } else {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"**** wrong address\r\n", io->stdErr);
    }
    *handled = TRUE;
  }
  return ERR_OK;
}

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
  /* Write code here ... */
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This bean is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
