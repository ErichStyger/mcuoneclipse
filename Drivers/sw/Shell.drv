%-Driver generated by the Component Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Component Wizard
%- If you change these lines, Component Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    30.09.2010
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_SendSeparatedStrings Prints a string using an I/O function, formated for the 'help' command
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\ShellSettings.Inc
%define! Abstract Common\ShellAbstract.Inc
%include Common\Header.h

%if (CPUfamily = "Kinetis")
%if (defined(PEversionDecimal) && (PEversionDecimal <=0 '1283'))
%- MCU10.3 is 1283
#include "PE_LDD.h" /* hack for Processor Expert (e.g. in MCU10.3) and LDD: PE_LDD.h includes at the end all shared modules, causing a recursive header file include conflict */
/* PE version is %PEversionDecimal */
%endif
%endif

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited components */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"

#define %'ModuleName'_8_3_SIZE       sizeof("12345678.txt") /* length of a 8.3 file name (13 including the zero byte) */
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"
#include <stddef.h> /* for size_t */

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

#ifndef __BWUserType_%'ModuleName'_StdIO_OutErr_FctType
#define __BWUserType_%'ModuleName'_StdIO_OutErr_FctType
  typedef void (*%'ModuleName'%.StdIO_OutErr_FctType)(byte);     %>40/* Callback for an output or error I/O function */
#endif
#ifndef __BWUserType_%'ModuleName'_StdIO_In_FctType
#define __BWUserType_%'ModuleName'_StdIO_In_FctType
  typedef void (*%'ModuleName'%.StdIO_In_FctType)(byte *);       %>40/* Callback for an I/O input function. */
#endif
#ifndef __BWUserType_%'ModuleName'_StdIO_KeyPressed_FctType
#define __BWUserType_%'ModuleName'_StdIO_KeyPressed_FctType
  typedef bool (*%'ModuleName'%.StdIO_KeyPressed_FctType)(void); %>40/* Callback which returns true if a key has been pressed */
#endif
#ifndef __BWUserType_%'ModuleName'_StdIOType
#define __BWUserType_%'ModuleName'_StdIOType
  typedef struct {                                               %>40/* Record containing input, output and error callback (stdin, stdout, stderr). */
    %'ModuleName'_StdIO_In_FctType stdIn;                        %>40/* standard input */
    %'ModuleName'_StdIO_OutErr_FctType stdOut;                   %>40/* standard output */
    %'ModuleName'_StdIO_OutErr_FctType stdErr;                   %>40/* standard error */
    %'ModuleName'_StdIO_KeyPressed_FctType keyPressed;           %>40/* key pressed callback */
  } %'ModuleName'_StdIOType;
#endif
#ifndef __BWUserType_%'ModuleName'_ConstStdIOType
#define __BWUserType_%'ModuleName'_ConstStdIOType
  typedef const %'ModuleName'%.StdIOType %'ModuleName'%.ConstStdIOType;%>40/* constant StdIOType */
#endif
#ifndef __BWUserType_%'ModuleName'_ParseCommandCallback
#define __BWUserType_%'ModuleName'_ParseCommandCallback
  typedef byte (*%'ModuleName'%.ParseCommandCallback)(const byte *cmd, bool *handled, const %'ModuleName'%.StdIOType *io);%>40/* Callback for parsing a shell command */
#endif
#ifndef __BWUserType_%'ModuleName'_ConstStdIOTypePtr
#define __BWUserType_%'ModuleName'_ConstStdIOTypePtr
  typedef const %'ModuleName'%.ConstStdIOType *%'ModuleName'%.ConstStdIOTypePtr;%>40/* Pointer to constant standard I/O descriptor */
#endif
#ifndef __BWUserType_%'ModuleName'_ConstParseCommandCallback
#define __BWUserType_%'ModuleName'_ConstParseCommandCallback
  typedef const %'ModuleName'%.ParseCommandCallback %'ModuleName'%.ConstParseCommandCallback;%>40/* Callback for parsing a shell command */
#endif

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
#define %'ModuleName'%.DASH_LINE "--------------------------------------------------------------"
/* predefined commands */
#define %'ModuleName'%.CMD_HELP   "help"
#define %'ModuleName'%.CMD_STATUS "status"
%-BW_CUSTOM_USERTYPE_END


%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendStr
%ifdef SendStr
void %'ModuleName'%.%SendStr(const byte *str, %'ModuleName'_StdIO_OutErr_FctType io);
%define! Parstr
%define! Pario
%include Common\ShellSendStr.Inc

%endif %- SendStr
%-BW_METHOD_END SendStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
byte %'ModuleName'%.%ParseCommand(const unsigned char *cmd, bool *handled, %'ModuleName'_ConstStdIOType *io);
%define! Pario
%define! Parcmd
%define! Parhandled
%define! RetVal
%include Common\ShellParseCommand.Inc

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum32s
%ifdef SendNum32s
void %'ModuleName'%.%SendNum32s(long val, %'ModuleName'_StdIO_OutErr_FctType io);
%define! Parval
%define! Pario
%include Common\ShellSendNum32s.Inc

%endif %- SendNum32s
%-BW_METHOD_END SendNum32s
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum16s
%ifdef SendNum16s
void %'ModuleName'%.%SendNum16s(int16_t val, %'ModuleName'_StdIO_OutErr_FctType io);
%define! Parval
%define! Pario
%include Common\ShellSendNum16s.Inc

%endif %- SendNum16s
%-BW_METHOD_END SendNum16s
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintPrompt
%ifdef PrintPrompt
void %'ModuleName'%.%PrintPrompt(%'ModuleName'_ConstStdIOType *io);
%define! Pario
%include Common\ShellPrintPrompt.Inc

%endif %- PrintPrompt
%-BW_METHOD_END PrintPrompt
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadLine
%ifdef ReadLine
bool %'ModuleName'%.%ReadLine(byte *buf, size_t bufSize, %'ModuleName'_ConstStdIOType *io);
%define! Parbuf
%define! ParbufSize
%define! Pario
%define! RetVal
%include Common\ShellReadLine.Inc

%endif %- ReadLine
%-BW_METHOD_END ReadLine
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintStatus
%ifdef PrintStatus
byte %'ModuleName'%.%PrintStatus(%'ModuleName'_ConstStdIOType *io);
%define! Pario
%define! RetVal
%include Common\ShellPrintStatus.Inc

%endif %- PrintStatus
%-BW_METHOD_END PrintStatus
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintCommandFailed
%ifdef PrintCommandFailed
void %'ModuleName'%.%PrintCommandFailed(const unsigned char *cmd, %'ModuleName'_ConstStdIOType *io);
%define! Pario
%define! Parcmd
%include Common\ShellPrintCommandFailed.Inc

%endif %- PrintCommandFailed
%-BW_METHOD_END PrintCommandFailed
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseWithCommandTable
%ifdef ParseWithCommandTable
byte %'ModuleName'%.%ParseWithCommandTable(const unsigned char *cmd, %'ModuleName'_ConstStdIOType *io, %'ModuleName'_ConstParseCommandCallback *parseCallback);
%define! Parcmd
%define! Pario
%define! ParparseCallback
%define! RetVal
%include Common\ShellParseWithCommandTable.Inc

%endif %- ParseWithCommandTable
%-BW_METHOD_END ParseWithCommandTable
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetStdio
%ifdef GetStdio
%'ModuleName'_ConstStdIOTypePtr %'ModuleName'%.%GetStdio(void);
%define! RetVal
%include Common\ShellGetStdio.Inc

%endif %- GetStdio
%-BW_METHOD_END GetStdio
%-************************************************************************************************************
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum32u
%ifdef SendNum32u
void %'ModuleName'%.%SendNum32u(dword val, %'ModuleName'_StdIO_OutErr_FctType io);
%define! Parval
%define! Pario
%include Common\ShellSendNum32u.Inc

%endif %- SendNum32u
%-BW_METHOD_END SendNum32u
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum16u
%ifdef SendNum16u
void %'ModuleName'%.%SendNum16u(word val, %'ModuleName'_StdIO_OutErr_FctType io);
%define! Parval
%define! Pario
%include Common\ShellSendNum16u.Inc

%endif %- SendNum16u
%-BW_METHOD_END SendNum16u
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum8u
%ifdef SendNum8u
void %'ModuleName'%.%SendNum8u(byte val, %'ModuleName'_StdIO_OutErr_FctType io);
%define! Parval
%define! Pario
%include Common\ShellSendNum8u.Inc

%endif %- SendNum8u
%-BW_METHOD_END SendNum8u
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum8s
%ifdef SendNum8s
void %'ModuleName'%.%SendNum8s(signed char val, %'ModuleName'_StdIO_OutErr_FctType io);
%define! Parval
%define! Pario
%include Common\ShellSendNum8s.Inc

%endif %- SendNum8s
%-BW_METHOD_END SendNum8s
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
void %'ModuleName'%.%Init(void);
%include Common\ShellInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN RequestSerial
%ifdef RequestSerial
void %'ModuleName'%.%RequestSerial(void);
%include Common\ShellRequestSerial.Inc

%endif %- RequestSerial
%-BW_METHOD_END RequestSerial
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReleaseSerial
%ifdef ReleaseSerial
void %'ModuleName'%.%ReleaseSerial(void);
%include Common\ShellReleaseSerial.Inc

%endif %- ReleaseSerial
%-BW_METHOD_END ReleaseSerial
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendHelpStr
%ifdef SendHelpStr
void %'ModuleName'%.%SendHelpStr(const byte *strCmd, const byte *strHelp, %'ModuleName'_StdIO_OutErr_FctType io);
%define! ParstrCmd
%define! Pario
%define! ParstrHelp
%include Common\ShellSendHelpStr.Inc

%endif %- SendHelpStr
%-BW_METHOD_END SendHelpStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendStatusStr
%ifdef SendStatusStr
void %'ModuleName'%.%SendStatusStr(const byte *strItem, const byte *strStatus, %'ModuleName'_StdIO_OutErr_FctType io);
%define! ParstrItem
%define! ParstrStatus
%define! Pario
%include Common\ShellSendStatusStr.Inc

%endif %- SendStatusStr
%-BW_METHOD_END SendStatusStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadChar
%ifdef ReadChar
void %'ModuleName'%.%ReadChar(byte *c);
%define! Parc
%include Common\ShellReadChar.Inc

%endif %- ReadChar
%-BW_METHOD_END ReadChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendChar
%ifdef SendChar
void %'ModuleName'%.%SendChar(byte ch);
%define! Parch
%include Common\ShellSendChar.Inc

%endif %- SendChar
%-BW_METHOD_END SendChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN KeyPressed
%ifdef KeyPressed
bool %'ModuleName'%.%KeyPressed(void);
%define! RetVal
%include Common\ShellKeyPressed.Inc

%endif %- KeyPressed
%-BW_METHOD_END KeyPressed
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
void %'ModuleName'%.%Deinit(void);
%include Common\ShellDeinit.Inc

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetSemaphore
%ifdef GetSemaphore
void* %'ModuleName'%.%GetSemaphore(void);
%define! RetVal
%include Common\ShellGetSemaphore.Inc

%endif %- GetSemaphore
%-BW_METHOD_END GetSemaphore
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadAndParseWithCommandTable
%ifdef ReadAndParseWithCommandTable
byte %'ModuleName'%.%ReadAndParseWithCommandTable(byte *cmdBuf, size_t cmdBufSize, %'ModuleName'_ConstStdIOType *io, %'ModuleName'_ConstParseCommandCallback *parseCallback);
%define! ParcmdBuf
%define! ParcmdBufSize
%define! Pario
%define! ParparseCallback
%define! RetVal
%include Common\ShellReadAndParseWithCommandTable.Inc

%endif %- ReadAndParseWithCommandTable
%-BW_METHOD_END ReadAndParseWithCommandTable
%-************************************************************************************************************
%-BW_METHOD_BEGIN IterateTable
%ifdef IterateTable
byte %'ModuleName'%.%IterateTable(const unsigned char *cmd, bool *handled, %'ModuleName'_ConstStdIOType *io, %'ModuleName'_ConstParseCommandCallback *parserTable);
%define! Parcmd
%define! Pario
%define! Parhandled
%define! ParparserTable
%define! RetVal
%include Common\ShellIterateTable.Inc

%endif %- IterateTable
%-BW_METHOD_END IterateTable
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\ShellSettings.Inc
%define! Abstract Common\ShellAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%if defined(OperatingSystemId) & OperatingSystemId = 'FreeRTOS' & %ConsoleSempahore='yes'
#include "FreeRTOS.h"
#include "semphr.h"

%endif
#ifdef __HC08__
  #pragma MESSAGE DISABLE C3303 /* implicit concatenation of strings */
#endif
%if defined(OperatingSystemId) & OperatingSystemId = 'FreeRTOS' & %ConsoleSempahore='yes'
static xSemaphoreHandle ShellSem = NULL; /* Semaphore to protect shell SCI access */
%endif
%-
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-UNLOCKED
/* Internal method prototypes */
%-INTERNAL_LOC_METHOD_BEG SendSeparatedStrings
static void SendSeparatedStrings(const byte *strA, const byte *strB, byte tabChar, byte tabPos, %'ModuleName'_StdIO_OutErr_FctType io);
%-INTERNAL_LOC_METHOD_END SendSeparatedStrings
%-

%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendStr
%ifdef SendStr
%define! Parstr
%define! Pario
%include Common\ShellSendStr.Inc
/*!
 * \brief Prints a string using I/O callbacks
 * \param[in] str String (zero terminated) to be printed
 * \param[in] io I/O function to be used for printing
 */
void %'ModuleName'%.%SendStr(const byte *str, %'ModuleName'_StdIO_OutErr_FctType io)
{
  while(*str!='\0') {
    io(*str++);
  }
}

%endif %- SendStr
%-BW_METHOD_END SendStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum32s
%ifdef SendNum32s
%define! Parval
%define! Pario
%include Common\ShellSendNum32s.Inc
void %'ModuleName'%.%SendNum32s(long val, %'ModuleName'_StdIO_OutErr_FctType io)
{
  unsigned char buf[sizeof("-1234567890")];

  %@Utility@'ModuleName'%.Num32sToStr(buf, sizeof(buf), val);
  %'ModuleName'%.%SendStr(buf, io);
}

%endif %- SendNum32s
%-BW_METHOD_END SendNum32s
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum32u
%ifdef SendNum32u
%define! Parval
%define! Pario
%include Common\ShellSendNum32u.Inc
void %'ModuleName'%.%SendNum32u(dword val, %'ModuleName'_StdIO_OutErr_FctType io)
{
  unsigned char buf[sizeof("1234567890")];

  %@Utility@'ModuleName'%.Num32uToStr(buf, sizeof(buf), val);
  %'ModuleName'%.%SendStr(buf, io);
}

%endif %- SendNum32u
%-BW_METHOD_END SendNum32u
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum16s
%ifdef SendNum16s
%define! Parval
%define! Pario
%include Common\ShellSendNum16s.Inc
void %'ModuleName'%.%SendNum16s(int16_t val, %'ModuleName'_StdIO_OutErr_FctType io)
{
  unsigned char buf[sizeof("-12345")];

  %@Utility@'ModuleName'%.Num16sToStr(buf, sizeof(buf), val);
  %'ModuleName'%.%SendStr(buf, io);
}

%endif %- SendNum16s
%-BW_METHOD_END SendNum16s
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum16u
%ifdef SendNum16u
%define! Parval
%define! Pario
%include Common\ShellSendNum16u.Inc
void %'ModuleName'%.%SendNum16u(word val, %'ModuleName'_StdIO_OutErr_FctType io)
{
  unsigned char buf[sizeof("12345")];

  %@Utility@'ModuleName'%.Num16uToStr(buf, sizeof(buf), val);
  %'ModuleName'%.%SendStr(buf, io);
}

%endif %- SendNum16u
%-BW_METHOD_END SendNum16u
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum8u
%ifdef SendNum8u
%define! Parval
%define! Pario
%include Common\ShellSendNum8u.Inc
void %'ModuleName'%.%SendNum8u(byte val, %'ModuleName'_StdIO_OutErr_FctType io)
{
  unsigned char buf[sizeof("123")];

  %@Utility@'ModuleName'%.Num8uToStr(buf, sizeof(buf), val);
  %'ModuleName'%.%SendStr(buf, io);
}

%endif %- SendNum8u
%-BW_METHOD_END SendNum8u
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum8s
%ifdef SendNum8s
%define! Parval
%define! Pario
%include Common\ShellSendNum8s.Inc
void %'ModuleName'%.%SendNum8s(signed char val, %'ModuleName'_StdIO_OutErr_FctType io)
{
  unsigned char buf[sizeof("-123")];

  %@Utility@'ModuleName'%.Num8sToStr(buf, sizeof(buf), val);
  %'ModuleName'%.%SendStr(buf, io);
}

%endif %- SendNum8s
%-BW_METHOD_END SendNum8s
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
%define! Pario
%define! Parcmd
%define! Parhandled
%define! RetVal
%include Common\ShellParseCommand.Inc
byte %'ModuleName'%.%ParseCommand(const unsigned char *cmd, bool *handled, %'ModuleName'_ConstStdIOType *io)
{
  if (%@Utility@'ModuleName'%.strcmp((char*)cmd, %'ModuleName'%.CMD_HELP)==0 || %@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' help")==0) {
    %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
    %'ModuleName'%.%SendStr((unsigned char*)%'ModuleName'%.DASH_LINE, io->stdOut);
    %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
    %'ModuleName'%.%SendStr((unsigned char*)"%ProjectNameStr", io->stdOut);
    %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
    %'ModuleName'%.%SendStr((unsigned char*)%'ModuleName'%.DASH_LINE, io->stdOut);
    %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
    %'ModuleName'%.%SendHelpStr((unsigned char*)"%'ModuleName'", (const unsigned char*)"Group of %'ModuleName' commands\r\n", io->stdOut);
%if defined(PrintStatus)
    %'ModuleName'%.%SendHelpStr((unsigned char*)"  help|status", (const unsigned char*)"Print help or status information\r\n", io->stdOut);
%else %- only help
    %'ModuleName'%.%SendHelpStr((unsigned char*)"  help", (const unsigned char*)"Prints help\r\n", io->stdOut);
%endif
    *handled = TRUE;
    return ERR_OK;
%if defined(PrintStatus)
  } else if ((%@Utility@'ModuleName'%.strcmp((char*)cmd, %'ModuleName'%.CMD_STATUS)==0) || (%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' status")==0)) {
    *handled = TRUE;
    return %'ModuleName'%.%PrintStatus(io);
%endif
  }
  return ERR_OK; /* no error */
}

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintPrompt
%ifdef PrintPrompt
%define! Pario
%include Common\ShellPrintPrompt.Inc
void %'ModuleName'%.%PrintPrompt(%'ModuleName'_ConstStdIOType *io)
{
  %'ModuleName'%.%SendStr((unsigned char*)%Prompt, io->stdOut);
}

%endif %- PrintPrompt
%-BW_METHOD_END PrintPrompt
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadLine
%ifdef ReadLine
%define! Parbuf
%define! ParbufSize
%define! Pario
%define! RetVal
%include Common\ShellReadLine.Inc
bool %'ModuleName'%.%ReadLine(byte *buf, size_t bufSize, %'ModuleName'_ConstStdIOType *io)
{
  byte c;

  if (io->keyPressed()) {
    for(;;) {                                                    %>40/* while not '\r' or '\n' */
      c = '\0';                                                  %>40/* initialize character */
      io->stdIn(&c);                                             %>40/* read character */
      *buf = (byte)c;                                            %>40/* append character to the string */
      if (c=='\0') { /* nothing in rx buffer? */
        break; /* get out of loop */
      }
%if %EchoEnabled='yes'
      io->stdOut(c);                                             %>40/* echo character */
%endif
      buf++;
      bufSize--;
      if ((c=='\r') || (c=='\n')) {
        break;
      }
      if (bufSize <= 1) {                                        %>40/* buffer full */
        break;
      }
    } /* for */
    *buf = '\0';                                                 %>40/* zero terminate string */
    return TRUE;
  } else {
    return FALSE;
  }
}

%endif %- ReadLine
%-BW_METHOD_END ReadLine
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintStatus
%ifdef PrintStatus
%define! Pario
%define! RetVal
%include Common\ShellPrintStatus.Inc
byte %'ModuleName'%.%PrintStatus(%'ModuleName'_ConstStdIOType *io)
{
  %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
  %'ModuleName'%.%SendStr((unsigned char*)%'ModuleName'%.DASH_LINE, io->stdOut);
  %'ModuleName'%.%SendStr((unsigned char*)"\r\nSYSTEM STATUS\r\n", io->stdOut);
  %'ModuleName'%.%SendStr((unsigned char*)%'ModuleName'%.DASH_LINE, io->stdOut);
  %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
  %'ModuleName'%.%SendStatusStr((const unsigned char*)"Firmware", (const unsigned char*)__DATE__, io->stdOut);
  %'ModuleName'%.%SendStr((unsigned char*)" ", io->stdOut);
  %'ModuleName'%.%SendStr((unsigned char*)__TIME__, io->stdOut);
  %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
  return ERR_OK;
}

%endif %- PrintStatus
%-BW_METHOD_END PrintStatus
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintCommandFailed
%ifdef PrintCommandFailed
%define! Pario
%define! Parcmd
%include Common\ShellPrintCommandFailed.Inc
void %'ModuleName'%.%PrintCommandFailed(const unsigned char *cmd, %'ModuleName'_ConstStdIOType *io)
{
  %'ModuleName'%.%SendStr((unsigned char*)"*** Failed or unknown command: ", io->stdErr);
  %'ModuleName'%.%SendStr(cmd, io->stdErr);
  %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdErr);
  %'ModuleName'%.%SendStr((unsigned char*)"*** Type ", io->stdErr);
  %'ModuleName'%.%SendStr((unsigned char*)%'ModuleName'%.CMD_HELP, io->stdErr);
  %'ModuleName'%.%SendStr((unsigned char*)" to get a list of available commands\r\n", io->stdErr);
}

%endif %- PrintCommandFailed
%-BW_METHOD_END PrintCommandFailed
%-************************************************************************************************************
%-BW_METHOD_BEGIN IterateTable
%ifdef IterateTable
%define! Parcmd
%define! Pario
%define! Parhandled
%define! ParparserTable
%define! RetVal
%include Common\ShellIterateTable.Inc
byte %'ModuleName'%.%IterateTable(const unsigned char *cmd, bool *handled, %'ModuleName'_ConstStdIOType *io, %'ModuleName'_ConstParseCommandCallback *parserTable)
{
  byte res = ERR_OK;

  if (parserTable==NULL) { /* no table??? */
    return ERR_FAILED;
  }
  /* iterate through all parser functions in table */
  while(*parserTable!=NULL) {
    if ((*parserTable)(cmd, handled, io)!=ERR_OK) {
      %'ModuleName'%.PrintCommandFailed(cmd, io);
      res = ERR_FAILED;
    }
    parserTable++;
  }
  return res;
}

%endif %- IterateTable
%-BW_METHOD_END IterateTable
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseWithCommandTable
%ifdef ParseWithCommandTable
%define! Parcmd
%define! Pario
%define! ParparseCallback
%define! RetVal
%include Common\ShellParseWithCommandTable.Inc
byte %'ModuleName'%.%ParseWithCommandTable(const unsigned char *cmd, %'ModuleName'_ConstStdIOType *io, %'ModuleName'_ConstParseCommandCallback *parseCallback)
{
  byte res = ERR_OK;
  bool handled;
%if %SilentModePrefixChar<>''
  bool silent;
%endif
%if %MultiCommandEnabled='yes'
  byte buf[%MaxSubCommandStringSize];
  uint8_t i;
  bool parseBuffer, finished;
%endif

  if (*cmd=='\0') { /* empty command */
    return ERR_OK;
  }
  /* parse first shell commands */
  handled = FALSE;
%if %SilentModePrefixChar<>''
  silent = (bool)(*cmd=='%SilentModePrefixChar');
  if (silent) {
    cmd++; /* skip '#' */
  }
%endif
%if %MultiCommandEnabled='yes'
  parseBuffer = FALSE;
  finished = FALSE;
  i = 0;
  for(;;) { /* breaks */
    if (i>sizeof(buf)-2) {
      res = ERR_FAILED;
      break; /* buffer overflow */
    }
    buf[i] = *cmd;
    cmd++; i++;
    if (buf[i-1] == '%MultiCmdSeparationChar') { /* found separator */
      buf[i-1] = '\0';
      parseBuffer = TRUE;
    } else if (buf[i-1]=='\0') {
      parseBuffer = TRUE;
      finished = TRUE;
    }
    if (parseBuffer) {
      (void)%'ModuleName'%.IterateTable(buf, &handled, io, parseCallback); /* iterate through all parser functions in table */
      if (!handled) { /* no handler has handled the command? */
        %'ModuleName'%.PrintCommandFailed(buf, io);
        res = ERR_FAILED;
        break; /* get out of loop */
      }
      parseBuffer = FALSE;
      i = 0; /* restart */
    }
    if (finished) {
      break; /* get out of loop */
    }
  } /* for */
%else
  (void)%'ModuleName'%.IterateTable(cmd, &handled, io, parseCallback); /* iterate through all parser functions in table */
  if (!handled) { /* no handler has handled the command? */
    %'ModuleName'%.PrintCommandFailed(cmd, io);
    res = ERR_FAILED;
  }
%endif
%if %SilentModePrefixChar<>''
  if (!silent) {
    %'ModuleName'%.PrintPrompt(io);
  }
%else
  %'ModuleName'%.PrintPrompt(io);
%endif
  return res;
}

%endif %- ParseWithCommandTable
%-BW_METHOD_END ParseWithCommandTable
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetStdio
%ifdef GetStdio
%define! RetVal
%include Common\ShellGetStdio.Inc
%'ModuleName'_ConstStdIOTypePtr %'ModuleName'%.%GetStdio(void)
{
  static %'ModuleName'_ConstStdIOType %'ModuleName'%.stdio =
  {
    (%'ModuleName'_StdIO_In_FctType)%'ModuleName'_ReadChar, /* stdin */
    (%'ModuleName'_StdIO_OutErr_FctType)%'ModuleName'_SendChar, /* stdout */
    (%'ModuleName'_StdIO_OutErr_FctType)%'ModuleName'_SendChar, /* stderr */
    %'ModuleName'_KeyPressed /* if input is not empty */
  };

  return &%'ModuleName'%.stdio;
}

%endif %- GetStdio
%-BW_METHOD_END GetStdio
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadAndParseWithCommandTable
%ifdef ReadAndParseWithCommandTable
%define! ParcmdBuf
%define! ParcmdBufSize
%define! Pario
%define! ParparseCallback
%define! RetVal
%include Common\ShellReadAndParseWithCommandTable.Inc
byte %'ModuleName'%.%ReadAndParseWithCommandTable(byte *cmdBuf, size_t cmdBufSize, %'ModuleName'_ConstStdIOType *io, %'ModuleName'_ConstParseCommandCallback *parseCallback)
{
  byte res = ERR_OK;
  size_t len;

  /* IMPORTANT NOTE: this function *appends* to the buffer, so the buffer needs to be initialized first! */
  len = %@Utility@'ModuleName'%.strlen((const char*)cmdBuf);
  if (%'ModuleName'%.ReadLine(cmdBuf+len, cmdBufSize-len, io)) {
    len = %@Utility@'ModuleName'%.strlen((const char*)cmdBuf);   %>40/* length of buffer string */
    if (len==0) { /* error case */
      return ERR_FAILED;
    } else if (len==1 && (cmdBuf[0]=='\n' || cmdBuf[0]=='\r')) { %>40/* eat preceding newline characters */
      cmdBuf[0] = '\0';
    }
    if (len>=cmdBufSize-1) {                                     %>40/* buffer overflow? Parse what we have, will be likely return an error */
      res = %'ModuleName'%.%ParseWithCommandTable(cmdBuf, io, parseCallback);
      cmdBuf[0] = '\0'; /* start again */
      res = ERR_OVERFLOW;
    } else if (cmdBuf[len-1]=='\n' || cmdBuf[len-1]=='\r') {     %>40/* line end: parse command */
      cmdBuf[len-1] = '\0';                                      %>40/* remove line end character for parser */
      res = %'ModuleName'%.%ParseWithCommandTable(cmdBuf, io, parseCallback);
      cmdBuf[0] = '\0';                                          %>40/* start again */
    } else {
      /* continue to append to buffer */
    }
  }
  return res;
}

%endif %- ReadAndParseWithCommandTable
%-BW_METHOD_END ReadAndParseWithCommandTable
%-************************************************************************************************************
%-BW_METHOD_BEGIN RequestSerial
%ifdef RequestSerial
%include Common\ShellRequestSerial.Inc
void %'ModuleName'%.%RequestSerial(void)
{
%if defined(OperatingSystemId) & OperatingSystemId = 'FreeRTOS' & %ConsoleSempahore='yes'
  (void)xSemaphoreTakeRecursive(ShellSem, portMAX_DELAY);
%endif
}

%endif %- RequestSerial
%-BW_METHOD_END RequestSerial
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReleaseSerial
%ifdef ReleaseSerial
%include Common\ShellReleaseSerial.Inc
void %'ModuleName'%.%ReleaseSerial(void)
{
%if defined(OperatingSystemId) & OperatingSystemId = 'FreeRTOS' & %ConsoleSempahore='yes'
  (void)xSemaphoreGiveRecursive(ShellSem);
%endif
}

%endif %- ReleaseSerial
%-BW_METHOD_END ReleaseSerial
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetSemaphore
%ifdef GetSemaphore
%define! RetVal
%include Common\ShellGetSemaphore.Inc
void* %'ModuleName'%.%GetSemaphore(void)
{
%if defined(OperatingSystemId) & OperatingSystemId = 'FreeRTOS' & %ConsoleSempahore='yes'
  return ShellSem;
%else
  return NULL;
%endif
}

%endif %- GetSemaphore
%-BW_METHOD_END GetSemaphore
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG SendSeparatedStrings
%define! ParstrA
%define! ParstrB
%define! PartabChar
%define! PartabPos
%define! Pario
%include Common\GeneralInternalGlobal.inc (SendSeparatedStrings)
static void SendSeparatedStrings(const byte *strA, const byte *strB, byte tabChar, byte tabPos, %'ModuleName'_StdIO_OutErr_FctType io)
{
  /* write command part */
  while(*strA!='\0' && tabPos>0) {
    io(*strA++);
    tabPos--;
  }
  /* fill up until ';' */
  while(tabPos>0) {
    io(' ');
    tabPos--;
  }
  /* write separator */
  io(tabChar);
  io(' ');
  /* write help text */
  %'ModuleName'%.%SendStr(strB, io);
}

%-INTERNAL_METHOD_END SendSeparatedStrings
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendHelpStr
%ifdef SendHelpStr
%define! ParstrCmd
%define! Pario
%define! ParstrHelp
%include Common\ShellSendHelpStr.Inc
void %'ModuleName'%.%SendHelpStr(const byte *strCmd, const byte *strHelp, %'ModuleName'_StdIO_OutErr_FctType io)
{
  #define HELP_SEMICOLON_POS  %HelpSemicolonPos /* position of the ';' after the command string */
  SendSeparatedStrings(strCmd, strHelp, ';', HELP_SEMICOLON_POS, io);
}

%endif %- SendHelpStr
%-BW_METHOD_END SendHelpStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendStatusStr
%ifdef SendStatusStr
%define! ParstrItem
%define! ParstrStatus
%define! Pario
%include Common\ShellSendStatusStr.Inc
void %'ModuleName'%.%SendStatusStr(const byte *strItem, const byte *strStatus, %'ModuleName'_StdIO_OutErr_FctType io)
{
  #define STATUS_COLON_POS  %StatusColonPos /* position of the ':' after the item string */
  SendSeparatedStrings(strItem, strStatus, ':', STATUS_COLON_POS, io);
}

%endif %- SendStatusStr
%-BW_METHOD_END SendStatusStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadChar
%ifdef ReadChar
%define! Parc
%include Common\ShellReadChar.Inc
void %'ModuleName'%.%ReadChar(byte *c)
{
%if defined(Serial)
%if defined(OperatingSystemId) & OperatingSystemId = 'FreeRTOS' & %ConsoleSempahore='yes'
  (void)xSemaphoreTakeRecursive(ShellSem, portMAX_DELAY);
%endif
%if defined(Serial)
  if (%@Serial@'ModuleName'%.RecvChar((uint8_t *)c) != ERR_OK) {
    /* failed to receive character: return a zero character */
    *c = '\0';
  }
%endif
%if defined(OperatingSystemId) & OperatingSystemId = 'FreeRTOS' & %ConsoleSempahore='yes'
  (void)xSemaphoreGiveRecursive(ShellSem);
%endif
%else
  *c = '\0';
  return; /* no serial component set up in properties */
%endif
}

%endif %- ReadChar
%-BW_METHOD_END ReadChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendChar
%ifdef SendChar
%define! Parch
%include Common\ShellSendChar.Inc
void %'ModuleName'%.%SendChar(byte ch)
{
%if defined(Serial)
%if defined(OperatingSystemId) & OperatingSystemId = 'FreeRTOS' & %ConsoleSempahore='yes'
  (void)xSemaphoreTakeRecursive(ShellSem, portMAX_DELAY);
%endif
 %if defined(Serial)
  %if BlockingSend='yes'
  while (%@Serial@'ModuleName'%.SendChar((uint8_t)ch)==ERR_TXFULL){}%>40/* Send char */
  %else
  (void)%@Serial@'ModuleName'%.SendChar((uint8_t)ch);            %>40/* non blocking send */
  %endif
 %endif
%if defined(OperatingSystemId) & OperatingSystemId = 'FreeRTOS' & %ConsoleSempahore='yes'
  (void)xSemaphoreGiveRecursive(ShellSem);
%endif
%else
  (void)ch;                                                      %>40/* avoid compiler warning about unused argument */
  return;                                                        %>40/* no serial component set up in properties */
%endif
}

%endif %- SendChar
%-BW_METHOD_END SendChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN KeyPressed
%ifdef KeyPressed
%define! RetVal
%include Common\ShellKeyPressed.Inc
bool %'ModuleName'%.%KeyPressed(void)
{
%if defined(Serial)
  bool res;

%if defined(OperatingSystemId) & OperatingSystemId = 'FreeRTOS' & %ConsoleSempahore='yes'
  (void)xSemaphoreTakeRecursive(ShellSem, portMAX_DELAY);
%endif
%if defined(Serial)
  res = (bool)((%@Serial@'ModuleName'%.GetCharsInRxBuf()==0U) ? FALSE : TRUE); /* true if there are characters in receive buffer */
%endif
%if defined(OperatingSystemId) & OperatingSystemId = 'FreeRTOS' & %ConsoleSempahore='yes'
  (void)xSemaphoreGiveRecursive(ShellSem);
%endif
  return res;
%else
  return FALSE; /* no serial component set up in properties */
%endif
}

%endif %- KeyPressed
%-BW_METHOD_END KeyPressed
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%include Common\ShellInit.Inc
void %'ModuleName'%.%Init(void)
{
%if defined(OperatingSystemId) & OperatingSystemId = 'FreeRTOS' & %ConsoleSempahore='yes'
  ShellSem = xSemaphoreCreateRecursiveMutex();
  if (ShellSem==NULL) { /* semaphore creation failed */
    for(;;) {} /* error, not enough memory? */
  }
%endif
}

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
%include Common\ShellDeinit.Inc
void %'ModuleName'%.%Deinit(void)
{
%if defined(OperatingSystemId) & OperatingSystemId = 'FreeRTOS' & %ConsoleSempahore='yes'
  vSemaphoreDelete(ShellSem);
  ShellSem = NULL;
%endif
}

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
  %'ModuleName'%.Init(); /* initialize shell */
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This component is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
