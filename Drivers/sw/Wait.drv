%-Driver generated by the Bean Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Bean Wizard
%- If you change these lines, Bean Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    14.06.2008
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\WaitSettings.Inc
%define! Abstract Common\WaitAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"
%include sw\CommonSupport.prg
%-
%if defined(OperatingSystemId) & OperatingSystemId = 'FreeRTOS'
/* include RTOS header files */
#include "FreeRTOS.h" /* for vTaskDelay() */
#include "task.h"
%endif

#ifdef __cplusplus
extern "C" {
#endif

%if defined(ManualClockValues) & ManualClockValues='yes'
#undef CPU_BUS_CLK_HZ         %>%CTAB /* if already defined in "%ProcessorModule.h" */
#define CPU_BUS_CLK_HZ          %'CpuBusClkHz'UL      %>%CTAB /*!< CPU clock frequency (normal operation) */

#undef CPU_BUS_CLK_HZ_HIGH    %>%CTAB /* if already defined in "%ProcessorModule.h" */
#define CPU_BUS_CLK_HZ_HIGH     %'CpuBusClkHzHigh'UL  %>%CTAB /*!< CPU clock frequency in high speed mode */

#undef CPU_BUS_CLK_HZ_SLOW    %>%CTAB /* if already defined in "%ProcessorModule.h" */
#define CPU_BUS_CLK_HZ_SLOW     %'CpuBusClkHzSlow'UL  %>%CTAB /*!< CPU clock frequency in low speed mode */

#undef CPU_BUS_CLK_HZ_LOW     %>%CTAB /* if already defined in "%ProcessorModule.h" */
#define CPU_BUS_CLK_HZ_LOW      %'CpuBusClkHzLow'UL   %>%CTAB /*!< CPU clock frequency in slow speed mode */
%endif

%if ndefined(LowClock_kHz) & ndefined(SlowClock_kHz)
  %define WaitUseMacroVersion  /* static clock: use inline version */
%endif
%-
%ifdef COMPILER_HIX
/* disable some compiler messages, as our inlined macros may generate some of them */
#pragma MESSAGE DISABLE C4000 /* Condition always TRUE */
#pragma MESSAGE DISABLE C4001 /* Condition always FALSE */
%endif
%-
#define %'ModuleName'%.NofCyclesMs(ms, hz)  ((ms)*((hz)/1000))               %>%CTAB /* calculates the needed cycles based on bus clock frequency */
%if (CPU_FAMILY = "ColdFireV1")
%- ColdFire is too fast for a single instruction range: add plus 1 cycle to keep timing accurate enough
#define %'ModuleName'%.NofCyclesUs(us, hz)  (1+(((us)*(((hz)/1000)/1000))))      %>%CTAB /* calculates the needed cycles based on bus clock frequency */
#define %'ModuleName'%.NofCyclesNs(ns, hz)  (1+(((ns)*(((hz)/1000)/1000))/1000)) %>%CTAB /* calculates the needed cycles based on bus clock frequency */
%else
#define %'ModuleName'%.NofCyclesUs(us, hz)  ((us)*(((hz)/1000)/1000))        %>%CTAB /* calculates the needed cycles based on bus clock frequency */
#define %'ModuleName'%.NofCyclesNs(ns, hz)  (((ns)*(((hz)/1000)/1000))/1000) %>%CTAB /* calculates the needed cycles based on bus clock frequency */
%endif


#define %'ModuleName'%.WAIT_C(cycles) \
     ( (cycles)<=10 ? \
          %'ModuleName'%.Wait10Cycles() \
        : %'ModuleName'%.WaitCycles((word)cycles) \
      )  %>%CTAB /*!< wait for some cycles */

%if (CPU_FAMILY = "HCS08") | (CPU_FAMILY = "HC08") | (CPU_FAMILY = "RS08") | (CPU_FAMILY = "HCS12X") | (CPU_FAMILY = "HCS12")
#pragma MESSAGE DISABLE C5908 /* Constant switch expression */
#define %'ModuleName'%.WAIT_CYCLES(cycles) \
  switch(cycles) { \
    case 10: asm("nop"); \
    case  9: asm("nop"); \
    case  8: asm("nop"); \
    case  7: asm("nop"); \
    case  6: asm("nop"); \
    case  5: asm("nop"); \
    case  4: asm("nop"); \
    case  3: asm("nop"); \
    case  2: asm("nop"); \
    case  1: asm("nop"); break;\
    default: WAIT1_WAIT_C(cycles); break; \
  } /*!< wait for some cycles */
%endif /* %if (CPU_FAMILY = "HCS08") | (CPU_FAMILY = "HC08") | (CPU_FAMILY = "RS08") | (CPU_FAMILY = "HCS12X") | (CPU_FAMILY = "HCS12") */
%-
%-
%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
%-BW_CUSTOM_USERTYPE_END
%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN Wait10Cycles
%ifdef Wait10Cycles
void %'ModuleName'%.%Wait10Cycles(void);
%include Common\WaitWait10Cycles.Inc

%endif %- Wait10Cycles
%-BW_METHOD_END Wait10Cycles
%-************************************************************************************************************
%-BW_METHOD_BEGIN Wait100Cycles
%ifdef Wait100Cycles
void %'ModuleName'%.%Wait100Cycles(void);
%include Common\WaitWait100Cycles.Inc

%endif %- Wait100Cycles
%-BW_METHOD_END Wait100Cycles
%-************************************************************************************************************
%-BW_METHOD_BEGIN WaitCycles
%ifdef WaitCycles
void %'ModuleName'%.%WaitCycles(word cycles);
%define! Parcycles
%include Common\WaitWaitCycles.Inc

%endif %- WaitCycles
%-BW_METHOD_END WaitCycles
%-************************************************************************************************************
%-BW_METHOD_BEGIN Waitms
%ifdef Waitms
void %'ModuleName'%.%Waitms(word ms);
%define! Parms
%include Common\WaitWaitms.Inc

%endif %- Waitms
%-BW_METHOD_END Waitms
%-************************************************************************************************************
%-BW_METHOD_BEGIN Waitus
%ifdef Waitus
%if defined(WaitUseMacroVersion)
/* we are having a static clock configuration: implement as macro/inlined version */
#define %'ModuleName'%.Waitus(us)  \
       (  ((%'ModuleName'%.NofCyclesUs((us),CPU_BUS_CLK_HZ)==0)||(us)==0) ? \
          (void)0 : \
          ( ((us)/1000)==0 ? (void)0 : %'ModuleName'%.Waitms((word)((us)/1000))) \
          , (%'ModuleName'%.NofCyclesUs(((us)%%1000), CPU_BUS_CLK_HZ)==0) ? (void)0 : \
            %'ModuleName'%.WAIT_C(%'ModuleName'%.NofCyclesUs(((us)%%1000), CPU_BUS_CLK_HZ)) \
       )
%else
void %'ModuleName'%.%Waitus(word us);
%endif
%define! Parus
%include Common\WaitWaitus.Inc

%endif %- Waitus
%-BW_METHOD_END Waitus
%-************************************************************************************************************
%-BW_METHOD_BEGIN Waitns
%ifdef Waitns
%if defined(WaitUseMacroVersion)
/* we are having a static clock configuration: implement as macro/inlined version */
#define %'ModuleName'%.Waitns(ns)  \
       (  ((%'ModuleName'%.NofCyclesNs((ns), CPU_BUS_CLK_HZ)==0)||(ns)==0) ? \
          (void)0 : \
          %'ModuleName'%.Waitus((ns)/1000) \
          , (%'ModuleName'%.NofCyclesNs((ns)%%1000, CPU_BUS_CLK_HZ)==0) ? \
              (void)0 : \
              %'ModuleName'%.WAIT_C(%'ModuleName'%.NofCyclesNs(((ns)%%1000), CPU_BUS_CLK_HZ)) \
       )
%else
void %'ModuleName'%.%Waitns(word ns);
%endif
%define! Parns
%include Common\WaitWaitns.Inc

%endif %- Waitns
%-BW_METHOD_END Waitns
%-************************************************************************************************************
%-BW_METHOD_BEGIN WaitOSms
%ifdef WaitOSms
%if defined(RTOS) %-RTOS defined in properties, e.g. uCOS-II
#define %'ModuleName'%.%WaitOSms(ms) \
  (void)%@RTOS@'ModuleName'%.OSTimeDlyHMSM(0,0,(ms)/1000,(ms)%%1000)
%else
#define %'ModuleName'%.%WaitOSms(ms) \
%if defined(OperatingSystemId) & OperatingSystemId = 'FreeRTOS'
  vTaskDelay(ms/portTICK_RATE_MS)
%else
  %'ModuleName'%.%Waitms(ms) /* no RTOS used, so use normal wait */
%endif
%endif
%include Common\WaitWaitOSms.Inc

#ifdef __cplusplus
}  /* extern "C" */
#endif

%endif %- WaitOSms
%-BW_METHOD_END WaitOSms
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\WaitSettings.Inc
%define! Abstract Common\WaitAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%if (CPU_FAMILY = "ColdFireV1")
/* tell the compiler not to inline functions in this module, as they are timing critical */
#pragma dont_inline on
%endif

%-
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN Wait10Cycles
%ifdef Wait10Cycles
%include Common\WaitWait10Cycles.Inc
%if (CPU_FAMILY = "Kinetis") & %Compiler = "GNUC"
__attribute__((naked)) void %'ModuleName'%.%Wait10Cycles(void)
%else
void %'ModuleName'%.%Wait10Cycles(void)
%endif
{
  /* This function will wait 10 CPU cycles (including call overhead). */
%if (CPU_FAMILY = "HCS08") | (CPU_FAMILY = "HC08")
  asm {
      ; BSR to here  ;  [5]
      ; RTS would be    [6]
  }
%elif (CPU_FAMILY = "RS08")
  asm {
      ; jsr to here [4]
      nop          ;[1]
      nop          ;[1]
      nop          ;[1]
      ; rts         [3]
  }
%elif (CPU_FAMILY = "HCS12X") | (CPU_FAMILY = "HCS12")
  asm {
      ; call to here   [7]
      ; RTC would be   [7]
  }
%elif (CPU_FAMILY = "ColdFireV1") | (CPU_FAMILY = "MCF")
  asm {
                       %>%CTAB /* [3] JSR to here on the caller side */
    nop                %>%CTAB /* [1]  */
    nop                %>%CTAB /* [1]  */
                       %>%CTAB /* [5] for RTS, return from subroutine */
  }
%elif (CPU_FAMILY = "Kinetis")
  /* NOTE: Cortex-M0 and M4 have 1 cycle for a NOP */
  /* Compiler is %Compiler */
%if %Compiler = "GNUC"
  asm (
   /* bl Wai10Cycles() to here: [4] */
   "nop   \n\t" /* [1] */
   "nop   \n\t" /* [1] */
   "nop   \n\t" /* [1] */
   "bx lr \n\t" /* [3] */
  );
%elif (%Compiler = "IARARM")
  /* bl Wai10Cycles() to here: [4] */
  asm("nop");   /* [1] */
  asm("nop");   /* [1] */
  asm("nop");   /* [1] */
  asm("bx lr"); /* [3] */
%elif (%Compiler = "ARM_CC") %- Keil/ARM compiler
  __asm {
    nop                %>%CTAB /* [1] */
    nop                %>%CTAB /* [1] */
    nop                %>%CTAB /* [1] */
    /*bx lr*/          %>%CTAB /* [3] */
  }
%else
  asm {
    nop                %>%CTAB /* [1] */
    nop                %>%CTAB /* [1] */
    nop                %>%CTAB /* [1] */
    bx lr              %>%CTAB /* [3] */
  }
%endif
%elif (CPU_FAMILY = "56800")
  /* JSR to here is 4-5 cycles */
  /* RTS is 8 cycles */
  #warning "unsupported CPU family %CPUfamily"
%else
  #warning "unsupported CPU family %CPUfamily"
  volatile byte i = 0; /* just something to wait, NOT the requested 10 cycles */
%endif
}

%endif %- Wait10Cycles
%-BW_METHOD_END Wait10Cycles
%-BW_METHOD_BEGIN Wait100Cycles
%ifdef Wait100Cycles
%include Common\WaitWait100Cycles.Inc
%if (%Compiler = "IARARM")
  /* Implemented in assembly file, as IAR does not support labels in HLI */
%else
%if (CPU_FAMILY = "Kinetis") & %Compiler = "GNUC"
__attribute__((naked)) void %'ModuleName'%.%Wait100Cycles(void)
%elif (CPU_FAMILY = "Kinetis") & (%Compiler = "ARM_CC") %- Keil/ARM compiler
__asm void %'ModuleName'%.%Wait100Cycles(void)
%else
void %'ModuleName'%.%Wait100Cycles(void)
%endif
{
  /* This function will spend 100 CPU cycles (including call overhead). */
%if (CPU_FAMILY = "HCS08") | (CPU_FAMILY = "HC08")
  asm {
      ; BSR to here  ;  [5]
      PSHH            ; [2], reserve space on stack
      LDA #13         ; [2], n
      TSX             ; [2]
      STA 0,X         ; [2]
    Label:
      DBNZ X,Label    ; 13*[6] =[78]
      PULH            ; [3]
      ; RTS would be    [6]
  }
%elif (CPU_FAMILY = "RS08")
  asm {
      ; jsr to here [4]
      LDA #23      ;[2]
    Label:
      DECA         ;[1]
      BNE Label    ;[3]
      ; rts         [3]
  }
%elif (CPU_FAMILY = "HCS12X") | (CPU_FAMILY = "HCS12")
  asm {
      ; call to here   [7]
      LDAB  #22      ; [1]
  Label:
      DBNE B, Label  ; [3]
      ; RTC would be   [7]
  }
%elif (CPU_FAMILY = "ColdFireV1") | (CPU_FAMILY = "MCF")
  asm {
                       %>%CTAB /* [3] JSR to here on the caller side */
    move.l #31,d1      %>%CTAB /* [1] number of iterations */
  loop:
    subq.l #1,d1       %>%CTAB /* [1] decrement d1 */
    bne.b loop         %>%CTAB /* [2] repeat 31x=([1]+[2])*31=[93] */
                       %>%CTAB /* [5] return from subroutine */
  }
%elif (CPU_FAMILY = "Kinetis")
%if %Compiler = "GNUC"
  asm (
   /* bl to here:               [4] */
   "movs r0, #0 \n\t"        /* [1] */
   "loop:       \n\t"
   "nop         \n\t"        /* [1] */
   "nop         \n\t"        /* [1] */
   "nop         \n\t"        /* [1] */
   "nop         \n\t"        /* [1] */
   "nop         \n\t"        /* [1] */
   "add r0,#1   \n\t"        /* [1] */
   "cmp r0,#9   \n\t"        /* [1] */
   "bls loop    \n\t"        /* [3] taken, [1] not taken */
   "nop         \n\t"        /* [1] */
   "bx lr       \n\t"        /* [3] */
  );
%elif (%Compiler = "IARARM")
  /* need to implement in assembly, as IAR does not support labels in HLI */
%elif (%Compiler = "ARM_CC") %- Keil/ARM compiler
   /* bl to here:    [4] */
    movs r0, #0   /* [1] */
loop
    nop           /* [1] */
    nop           /* [1] */
    nop           /* [1] */
    nop           /* [1] */
    nop           /* [1] */
    adds r0,r0,#1 /* [1] */
    cmp r0,#9     /* [1] */
    bls loop      /* [3] taken, [1] not taken */
    nop           /* [1] */
    bx lr         /* [3] */
%else
  asm {
   /* bl Wai10Cycles() to here: [4] */
    movs r0, #0 /* [1] */
   loop:
    nop         /* [1] */
    nop         /* [1] */
    nop         /* [1] */
    nop         /* [1] */
    nop         /* [1] */
    add r0,#1   /* [1] */
    cmp r0,#9   /* [1] */
    bls loop    /* [3] taken, [1] not taken */
    nop         /* [1] */
    bx lr       /* [3] */
  }
%endif
%elif (CPU_FAMILY = "56800")
  /* JSR to here is 4-5 cycles */
  asm {
    move.w #11, A  /* 2 cycles  */
    /* burn 100-5-2-8=85 cycles. Doing this with 11*8=88 cycles */
    do A, label    /* 8 cycles */
    label:
  }
  /* RTS is 8 cycles */
%else
  #warning "unsupported CPU family %CPUfamily"
  volatile byte i;
  for(i=0; i<50; i++); /* just something to wait, NOT the requested 100 cycles */
%endif
}
%endif  %-(%Compiler = "IARARM")

%endif %- Wait100Cycles
%-BW_METHOD_END Wait100Cycles
%-************************************************************************************************************
%-BW_METHOD_BEGIN WaitCycles
%ifdef WaitCycles
%define! Parcycles
%include Common\WaitWaitCycles.Inc
void %'ModuleName'%.%WaitCycles(word cycles)
{
  while(cycles > 100) {
    %'ModuleName'%.%Wait100Cycles();
    cycles -= 100;
  }
  while(cycles > 10) {
    %'ModuleName'%.%Wait10Cycles();
    cycles -= 10;
  }
}

%endif %- WaitCycles
%-BW_METHOD_END WaitCycles
%-************************************************************************************************************
%-BW_METHOD_BEGIN Waitms
%ifdef Waitms
%define! Parms
%include Common\WaitWaitms.Inc
%ifdef COMPILER_HIX
#pragma MESSAGE DISABLE C5905 /* multiplication with one */
%endif
void %'ModuleName'%.%Waitms(word ms)
{
%if (CPU_FAMILY = "Kinetis") | (CPU_FAMILY = "HCS08") | (CPU_FAMILY = "HC08") | (CPU_FAMILY = "RS08")  | (CPU_FAMILY = "HCS12X") | (CPU_FAMILY = "HCS12")
  word msCycles; /* cycles for 1 ms */

%if defined(LowClock_kHz) | defined(SlowClock_kHz)
  /* dynamic clock/speed configuration */
  if (CpuMode == HIGH_SPEED) {
    msCycles = %'ModuleName'%.NofCyclesMs(1, CPU_BUS_CLK_HZ_HIGH);
 %if defined(LowClock_kHz)
  %if defined(SlowClock_kHz)
  } else if (CpuMode == LOW_SPEED) {
  %else
  } else { /* LOW_SPEED */
  %endif
    msCycles = %'ModuleName'%.NofCyclesMs(1, CPU_BUS_CLK_HZ_LOW);
 %endif
 %if defined(SlowClock_kHz)
  } else { /* SLOW_SPEED */
    msCycles = %'ModuleName'%.NofCyclesMs(1, CPU_BUS_CLK_HZ_SLOW);
 %endif
  }
%else
  /* static clock/speed configuration */
%if (CPU_FAMILY = "Kinetis")
  msCycles = %'ModuleName'%.NofCyclesMs(1, CPU_CORE_CLK_HZ);
%else
  msCycles = %'ModuleName'%.NofCyclesMs(1, CPU_BUS_CLK_HZ);
%endif
%endif
  while(ms>0) {
    %'ModuleName'%.WaitCycles(msCycles);
  %if WatchdogEnabled='yes'
    %if defined(Watchdog)
    %@Watchdog@'ModuleName'%.Clear();                            %>40/* kick the dog in order not to timeout */
    %elif defined(WatchdogLDD)
    (void)%@WatchdogLDD@'ModuleName'%.Clear(%@WatchdogLDD@'ModuleName'%.DeviceData);%>40/* kick the dog in order not to timeout */
    %endif
  %endif
    ms--;
  }
%else
  if (ms>0) {
    %'ProcessorModule'%.%Delay100usFunction((word)(ms*10)); /* Use function in CPU component. If you get a compiler error here, this typically means that the method is not enabled. Enable this method in the CPU component */
  }
%endif
}
%ifdef COMPILER_HIX
#pragma MESSAGE DEFAULT C5905 /* multiplication with one */
%endif
%endif %- Waitms
%-BW_METHOD_END Waitms
%-************************************************************************************************************
%-BW_METHOD_BEGIN Waitus
%ifdef Waitus
%define! Parus
%include Common\WaitWaitus.Inc
%if defined(WaitUseMacroVersion)
/* implemented as macro version. See header file. */
%else
%ifdef COMPILER_HIX
#pragma MESSAGE DISABLE C5905 /* multiplication with one */
%endif
void %'ModuleName'%.%Waitus(word us)
{
%if defined(LowClock_kHz) | defined(SlowClock_kHz)
  /* dynamic clock/speed configuration */
  if (CpuMode == HIGH_SPEED) {
    %'ModuleName'%.WaitCycles((word)%'ModuleName'%.NofCyclesUs(us, CPU_BUS_CLK_HZ_HIGH));
 %if defined(LowClock_kHz)
  %if defined(SlowClock_kHz)
  } else if (CpuMode == LOW_SPEED) {
  %else
  } else { /* LOW_SPEED */
  %endif
    %'ModuleName'%.WaitCycles((word)%'ModuleName'%.NofCyclesUs(us, CPU_BUS_CLK_HZ_LOW));
 %endif
 %if defined(SlowClock_kHz)
  } else { /* SLOW_SPEED */
    %'ModuleName'%.WaitCycles((word)%'ModuleName'%.NofCyclesUs(us, CPU_BUS_CLK_HZ_SLOW));
 %endif
  }
%else
  /* static clock/speed configuration */
  %'ModuleName'%.WaitCycles((word)%'ModuleName'%.NofCyclesUs(us, CPU_BUS_CLK_HZ));
%endif
}
%ifdef COMPILER_HIX
#pragma MESSAGE DEFAULT C5905 /* multiplication with one */
%endif
%endif
%endif %- Waitus
%-BW_METHOD_END Waitus
%-************************************************************************************************************
%-BW_METHOD_BEGIN Waitns
%ifdef Waitns
%define! Parns
%include Common\WaitWaitns.Inc
%if defined(WaitUseMacroVersion)
/* implemented as macro version. See header file. */
%else
%ifdef COMPILER_HIX
#pragma MESSAGE DISABLE C5905 /* multiplication with one */
%endif
void %'ModuleName'%.%Waitns(word ns)
{
%if defined(LowClock_kHz) | defined(SlowClock_kHz)
  /* dynamic clock/speed configuration */
  if (CpuMode == HIGH_SPEED) {
    %'ModuleName'%.WaitCycles((word)%'ModuleName'%.NofCyclesNs(ns, CPU_BUS_CLK_HZ_HIGH));
 %if defined(LowClock_kHz)
  %if defined(SlowClock_kHz)
  } else if (CpuMode == LOW_SPEED) {
  %else
  } else { /* LOW_SPEED */
  %endif
    %'ModuleName'%.WaitCycles((word)%'ModuleName'%.NofCyclesNs(ns, CPU_BUS_CLK_HZ_LOW));
 %endif
 %if defined(SlowClock_kHz)
  } else { /* SLOW_SPEED */
    %'ModuleName'%.WaitCycles((word)%'ModuleName'%.NofCyclesNs(ns, CPU_BUS_CLK_HZ_SLOW));
 %endif
  }
%else
  %'ModuleName'%.WaitCycles((word)%'ModuleName'%.NofCyclesNs(ns, CPU_BUS_CLK_HZ));
%endif
}
%ifdef COMPILER_HIX
#pragma MESSAGE DEFAULT C5905 /* multiplication with one */
%endif
%endif
%endif %- Waitns
%-BW_METHOD_END Waitns
%-************************************************************************************************************
%-BW_METHOD_BEGIN WaitOSms
%ifdef WaitOSms
%include Common\WaitWaitOSms.Inc
#if 0
void %'ModuleName'%.%WaitOSms(void)
{
  /* Method is implemented as macro in the header file */
}
#endif

%endif %- WaitOSms
%-BW_METHOD_END WaitOSms
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
%CODE_BEGIN
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%if (%Compiler = "IARARM")
%- need to implement the handler in assembly, as IAR does not support inline assembly with labels?
%FILE %'DirRel_Code'%'ModuleName'%.%Wait100Cycles.s
  /* use code segment, and we are generating ARM thumb code: */
  RSEG    CODE:CODE(2)
  thumb

  /* external interface declaration; */
  PUBLIC %'ModuleName'%.%Wait100Cycles

/*-----------------------------------------------------------*/
%'ModuleName'%.%Wait100Cycles:
  /* bl to here:  [4] */
  movs r0,#0   /* [1] load loop counter */
  loop:        /* 9*[10] */
  nop          /* [1] */
  nop          /* [1] */
  nop          /* [1] */
  nop          /* [1] */
  nop          /* [1] */
  adds r0,#1   /* [1] increment loop counter */
  cmp r0,#9    /* [1] 9*10 cycles */
  bls loop     /* [3] for taken, [1] for not taken */
  nop          /* additional nop to fill up to 100 cycles */
  bx lr        /* return to caller */
/*-----------------------------------------------------------*/
  END
%endif %- (%Compiler = "IARARM")
%else %- Language (& Compiler)
  %error^ This bean is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
