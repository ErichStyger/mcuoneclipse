%-Driver generated by the Bean Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Bean Wizard
%- If you change these lines, Bean Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    22.10.2008
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\GDisplaySettings.Inc
%define! Abstract Common\GDisplayAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
#define %'ModuleName'%.RGB565(R,G,B)     ((%'ModuleName'_PixelColor)((((R)&0x1f)<<11)+(((G)&0x3f)<<5)+((B)&0x1f)))%>40/* convert RGB into 565 color format */

#define %'ModuleName'%.COLOR_PIXEL_SET          %@Display@'ModuleName'%.COLOR_PIXEL_SET       /* value for a pixel set */
#define %'ModuleName'%.COLOR_PIXEL_CLR          %@Display@'ModuleName'%.COLOR_PIXEL_CLR       /* value for a pixel cleared */
%if %InvertedPixels='yes'
#define %'ModuleName'%.COLOR_BLACK              %@Display@'ModuleName'%.COLOR_WHITE           /* white color */
#define %'ModuleName'%.COLOR_WHITE              %@Display@'ModuleName'%.COLOR_BLACK           /* black color */
#define %'ModuleName'%.COLOR_RED                (~%@Display@'ModuleName'%.COLOR_RED)          /* red color */
#define %'ModuleName'%.COLOR_BRIGHT_RED         (~%@Display@'ModuleName'%.COLOR_BRIGHT_RED)   /* bright red color */
#define %'ModuleName'%.COLOR_DARK_RED           (~%@Display@'ModuleName'%.COLOR_DARK_RED)     /* dark red color */
#define %'ModuleName'%.COLOR_GREEN              (~%@Display@'ModuleName'%.COLOR_GREEN)        /* green color */
#define %'ModuleName'%.COLOR_DARK_GREEN         (~%@Display@'ModuleName'%.COLOR_DARK_GREEN)   /* dark green color */
#define %'ModuleName'%.COLOR_BRIGHT_GREEN       (~%@Display@'ModuleName'%.COLOR_BRIGHT_GREEN) /* bright green color */
#define %'ModuleName'%.COLOR_BLUE               (~%@Display@'ModuleName'%.COLOR_BLUE)         /* blue color */
#define %'ModuleName'%.COLOR_BRIGHT_BLUE        (~%@Display@'ModuleName'%.COLOR_BRIGHT_BLUE)  /* bright blue color */
#define %'ModuleName'%.COLOR_DARK_BLUE          (~%@Display@'ModuleName'%.COLOR_DARK_BLUE)    /* dark blue color */
#define %'ModuleName'%.COLOR_YELLOW             (~%@Display@'ModuleName'%.COLOR_YELLOW)       /* yellow color */
#define %'ModuleName'%.COLOR_BRIGHT_YELLOW      (~%@Display@'ModuleName'%.COLOR_BRIGHT_YELLOW)/* bright yellow color */
#define %'ModuleName'%.COLOR_ORANGE             (~%@Display@'ModuleName'%.COLOR_ORANGE)       /* orange color */
#define %'ModuleName'%.COLOR_GREY               (~%@Display@'ModuleName'%.COLOR_GREY)         /* grey color */
#define %'ModuleName'%.COLOR_BRIGHT_GREY        (~%@Display@'ModuleName'%.COLOR_BRIGHT_GREY)  /* bright grey color */
%else
#define %'ModuleName'%.COLOR_BLACK              %@Display@'ModuleName'%.COLOR_BLACK           /* black color */
#define %'ModuleName'%.COLOR_WHITE              %@Display@'ModuleName'%.COLOR_WHITE           /* white color */
#define %'ModuleName'%.COLOR_RED                %@Display@'ModuleName'%.COLOR_RED             /* red color */
#define %'ModuleName'%.COLOR_BRIGHT_RED         %@Display@'ModuleName'%.COLOR_BRIGHT_RED      /* bright red color */
#define %'ModuleName'%.COLOR_DARK_RED           %@Display@'ModuleName'%.COLOR_DARK_RED        /* dark red color */
#define %'ModuleName'%.COLOR_GREEN              %@Display@'ModuleName'%.COLOR_GREEN           /* green color */
#define %'ModuleName'%.COLOR_DARK_GREEN         %@Display@'ModuleName'%.COLOR_DARK_GREEN      /* dark green color */
#define %'ModuleName'%.COLOR_BRIGHT_GREEN       %@Display@'ModuleName'%.COLOR_BRIGHT_GREEN    /* bright green color */
#define %'ModuleName'%.COLOR_BLUE               %@Display@'ModuleName'%.COLOR_BLUE            /* blue color */
#define %'ModuleName'%.COLOR_BRIGHT_BLUE        %@Display@'ModuleName'%.COLOR_BRIGHT_BLUE     /* bright blue color */
#define %'ModuleName'%.COLOR_DARK_BLUE          %@Display@'ModuleName'%.COLOR_DARK_BLUE       /* dark blue color */
#define %'ModuleName'%.COLOR_YELLOW             %@Display@'ModuleName'%.COLOR_YELLOW          /* yellow color */
#define %'ModuleName'%.COLOR_BRIGHT_YELLOW      %@Display@'ModuleName'%.COLOR_BRIGHT_YELLOW   /* bright yellow color */
#define %'ModuleName'%.COLOR_ORANGE             %@Display@'ModuleName'%.COLOR_ORANGE          /* orange color */
#define %'ModuleName'%.COLOR_GREY               %@Display@'ModuleName'%.COLOR_GREY            /* grey color */
#define %'ModuleName'%.COLOR_BRIGHT_GREY        %@Display@'ModuleName'%.COLOR_BRIGHT_GREY     /* bright grey color */
%endif

typedef %@Display@'ModuleName'%.PixelDim   %'ModuleName'%.PixelDim;%>40/* Display specific type for a pixel coordinate. */
typedef %@Display@'ModuleName'%.PixelColor %'ModuleName'%.PixelColor;%>40/* Display specific color type. */
typedef %@Display@'ModuleName'%.PixelCount %'ModuleName'%.PixelCount;%>40/* Type able to hold the number of pixels for the display. */

/* wrappers for the low level display orientation enumeration and type */
typedef %@Display@'ModuleName'%.DisplayOrientation %'ModuleName'%.DisplayOrientation;
#define %'ModuleName'%.ORIENTATION_PORTRAIT     %@Display@'ModuleName'%.ORIENTATION_PORTRAIT
#define %'ModuleName'%.ORIENTATION_PORTRAIT180  %@Display@'ModuleName'%.ORIENTATION_PORTRAIT180
#define %'ModuleName'%.ORIENTATION_LANDSCAPE    %@Display@'ModuleName'%.ORIENTATION_LANDSCAPE
#define %'ModuleName'%.ORIENTATION_LANDSCAPE180 %@Display@'ModuleName'%.ORIENTATION_LANDSCAPE180

%-BW_CUSTOM_USERTYPE_END
%if %UseMemBuffer='yes'

%ifdef Orientation
%if %Orientation='Landscape'
/* Landscape */
%elif %Orientation='Landscape180'
/* Landscape180 */
%elif %Orientation='Portrait'
/* Portrait */
%elif %Orientation='Portrait180'
/* Portrait180 */
%endif
%endif

#define %'ModuleName'%.BUF_BYTE(x,y)  /* how to access a byte in the display buf[][] */ \
%if %@Display@BitsPerPixel='1'
  %if %Orientation='Landscape'
    %if   %@Display@BytesInRows='yes' & %@Display@BytesInXdirection='yes'
      %@Display@'ModuleName'%.DisplayBuf[y][(x)/8]
    %elif %@Display@BytesInRows='no'  & %@Display@BytesInXdirection='no'
      %@Display@'ModuleName'%.DisplayBuf[y][(x)/8]
    %elif %@Display@BytesInRows='no'  & %@Display@BytesInXdirection='yes' %- Nokia display, ChLCD 132x64
      %@Display@'ModuleName'%.DisplayBuf[(y)/8][x]
    %elif %@Display@BytesInRows='yes' & %@Display@BytesInXdirection='no'  %- CanYourBadgeDoThis LED matrix
      %@Display@'ModuleName'%.DisplayBuf[(x)/8][y]
    %endif
  %elif %Orientation='Landscape180'
    %if   %@Display@BytesInRows='yes' & %@Display@BytesInXdirection='yes'
      %@Display@'ModuleName'%.DisplayBuf[%@Display@'ModuleName'%.GetShorterSide()-1-(y)][(%@Display@'ModuleName'%.GetLongerSide()-1-(x))/8]
    %elif %@Display@BytesInRows='no'  & %@Display@BytesInXdirection='no'
      %@Display@'ModuleName'%.DisplayBuf[%@Display@'ModuleName'%.GetShorterSide()-1-(y)][(%@Display@'ModuleName'%.GetLongerSide()-1-(x))/8]
    %elif %@Display@BytesInRows='no'  & %@Display@BytesInXdirection='yes'
      %@Display@'ModuleName'%.DisplayBuf[(%@Display@'ModuleName'%.GetShorterSide()-1-(y))/8][%@Display@'ModuleName'%.GetLongerSide()-1-(x)]
    %elif %@Display@BytesInRows='yes' & %@Display@BytesInXdirection='no'
      %@Display@'ModuleName'%.DisplayBuf[(%@Display@'ModuleName'%.GetLongerSide()-1-(x))/8][%@Display@'ModuleName'%.GetShorterSide()-1-(y)]
    %endif
  %elif %Orientation='Portrait'
    %if   %@Display@BytesInRows='yes' & %@Display@BytesInXdirection='yes'
      //%@Display@'ModuleName'%.DisplayBuf[%@Display@'ModuleName'%.GetWidth()-1-(x)][(%@Display@'ModuleName'%.GetHeight()-1-(y))/8]
    %elif %@Display@BytesInRows='no'  & %@Display@BytesInXdirection='no'
      //%@Display@'ModuleName'%.DisplayBuf[%@Display@'ModuleName'%.GetWidth()-1-(x)][(%@Display@'ModuleName'%.GetHeight()-1-(y))/8]
    %elif %@Display@BytesInRows='no'  & %@Display@BytesInXdirection='yes'
      %@Display@'ModuleName'%.DisplayBuf[(%@Display@'ModuleName'%.GetShorterSide()-1-(x))/8][(y)]
    %elif %@Display@BytesInRows='yes' & %@Display@BytesInXdirection='no'
      %@Display@'ModuleName'%.DisplayBuf[(y)/8][%@Display@'ModuleName'%.GetLongerSide()-1-(x)]
    %endif
  %elif %Orientation='Portrait180'
    %if   %@Display@BytesInRows='yes' & %@Display@BytesInXdirection='yes'
      //%@Display@'ModuleName'%.DisplayBuf[%@Display@'ModuleName'%.GetWidth()-1-(x)][(%@Display@'ModuleName'%.GetHeight()-1-(y))/8]
    %elif %@Display@BytesInRows='no'  & %@Display@BytesInXdirection='no'
      //%@Display@'ModuleName'%.DisplayBuf[%@Display@'ModuleName'%.GetWidth()-1-(x)][(%@Display@'ModuleName'%.GetHeight()-1-(y))/8]
    %elif %@Display@BytesInRows='no'  & %@Display@BytesInXdirection='yes' %- Kent 132x64
      %@Display@'ModuleName'%.DisplayBuf[(x)/8][%@Display@'ModuleName'%.GetLongerSide()-1-(y)]
    %elif %@Display@BytesInRows='yes' & %@Display@BytesInXdirection='no'
      //%@Display@'ModuleName'%.DisplayBuf[(y)/8][%@Display@'ModuleName'%.GetWidth()-1-(x)]
    %endif
  %endif
%elif %@Display@BitsPerPixel='8'
  %if %@Display@BytesInRows='yes'
  %@Display@'ModuleName'%.DisplayBuf[y][x]
  %else
  %@Display@'ModuleName'%.DisplayBuf[x][y]
  %endif
%else
  /* not supported yet! */
%endif

%if %@Display@BitsPerPixel='1'
#define %'ModuleName'%.BUF_BYTE_PIXEL_BIT_NO(x,y) /* pixel bit number inside display buffer byte (0 is LSB, 7 MSB) */ \
  %if %Orientation='Landscape'
    %if   %@Display@BytesInRows='yes' & %@Display@MSBfirst='yes'
      ((byte)(7-((x)%%8)))
    %elif %@Display@BytesInRows='yes' & %@Display@MSBfirst='no'
      ((byte)((x)%%8))
    %elif %@Display@BytesInRows='no' & %@Display@MSBfirst='no'  %- Kent 132x64, Nokia
      ((byte)((y)%%8))
    %elif %@Display@BytesInRows='no' & %@Display@MSBfirst='yes'
      ((byte)(7-((y)%%8)))
    %endif
  %elif %Orientation='Landscape180'
    %if   %@Display@BytesInRows='yes' & %@Display@MSBfirst='yes'
      ((byte)(7-((%@Display@'ModuleName'%.GetWidth()-1-(x))%%8)))
    %elif %@Display@BytesInRows='yes' & %@Display@MSBfirst='no'
      ((byte)((%@Display@'ModuleName'%.GetWidth()-1-(x))%%8))
    %elif %@Display@BytesInRows='no' & %@Display@MSBfirst='no' %- Kent 132x64, Nokia
      ((byte)(7-((y)%%8)))
    %elif %@Display@BytesInRows='no' & %@Display@MSBfirst='yes'
      ((byte)(7-((%@Display@'ModuleName'%.GetHeight()-1-(y))%%8)))
    %endif
  %elif %Orientation='Portrait'
    %if   %@Display@BytesInRows='yes' & %@Display@MSBfirst='yes'
      ((byte)(7-((%@Display@'ModuleName'%.GetHeight()-1-(y))%%8)))
    %elif %@Display@BytesInRows='yes' & %@Display@MSBfirst='no'
      ((byte)((%@Display@'ModuleName'%.GetHeight()-1-(y))%%8))
    %elif %@Display@BytesInRows='no' & %@Display@MSBfirst='no' %- Kent 132x64, Nokia
      ((byte)(7-((x)%%8)))
    %elif %@Display@BytesInRows='no' & %@Display@MSBfirst='yes'
      ((byte)(7-((%@Display@'ModuleName'%.GetWidth()-1-(x))%%8)))
    %endif
  %elif %Orientation='Portrait180'
    %if   %@Display@BytesInRows='yes' & %@Display@MSBfirst='yes'
      //((byte)(7-((%@Display@'ModuleName'%.GetHeight()-1-(y))%%8)))
    %elif %@Display@BytesInRows='yes' & %@Display@MSBfirst='no'
      //((byte)((%@Display@'ModuleName'%.GetHeight()-1-(y))%%8))
    %elif %@Display@BytesInRows='no' & %@Display@MSBfirst='no' %- Kent 132x64, Nokia
      ((byte)((x)%%8))
    %elif %@Display@BytesInRows='no' & %@Display@MSBfirst='yes'
      //((byte)(7-((x)%%8)))
    %endif
  %endif
%endif

#define %'ModuleName'%.BUF_BYTE_PIXEL_MASK(x,y)  /* pixel mask for an individual bit inside a display buffer byte */ \
%if %@Display@BitsPerPixel='1'
  (1<<%'ModuleName'%.BUF_BYTE_PIXEL_BIT_NO(x,y))
%elif %@Display@BitsPerPixel='8'
  0xff
%else
  /* not supported yet! */
%endif

#define %'ModuleName'%.BUF_BYTE_GET_PIXEL(x,y)  /* extract a pixel */ \
%if %@Display@BitsPerPixel='1'
  ((%'ModuleName'%.BUF_BYTE(x,y)&%'ModuleName'%.BUF_BYTE_PIXEL_MASK(x,y))>>%'ModuleName'%.BUF_BYTE_PIXEL_BIT_NO(x,y))
%elif %@Display@BitsPerPixel='8'
  %'ModuleName'%.BUF_BYTE(x,y)
%else
  /* not supported yet! */
%endif

%endif %- %@Display@WindowCapability='no'
%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN Clear
%ifdef Clear
void %'ModuleName'%.%Clear(void);
%include Common\GDisplayClear.Inc

%endif %- Clear
%-BW_METHOD_END Clear
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetPixel
%ifdef SetPixel
void %'ModuleName'%.%SetPixel(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y);
%define! Parx
%define! Pary
%include Common\GDisplaySetPixel.Inc

%endif %- SetPixel
%-BW_METHOD_END SetPixel
%-************************************************************************************************************
%-BW_METHOD_BEGIN ClrPixel
%ifdef ClrPixel
void %'ModuleName'%.%ClrPixel(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y);
%define! Parx
%define! Pary
%include Common\GDisplayClrPixel.Inc

%endif %- ClrPixel
%-BW_METHOD_END ClrPixel
%-************************************************************************************************************
%-BW_METHOD_BEGIN NegPixel
%ifdef NegPixel
void %'ModuleName'%.%NegPixel(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y);
%define! Parx
%define! Pary
%include Common\GDisplayNegPixel.Inc

%endif %- NegPixel
%-BW_METHOD_END NegPixel
%-************************************************************************************************************
%-BW_METHOD_BEGIN UpdateFull
%ifdef UpdateFull
#define %'ModuleName'%.%UpdateFull()   %@Display@'ModuleName'%.UpdateFull()
%include Common\GDisplayUpdateFull.Inc

%endif %- UpdateFull
%-BW_METHOD_END UpdateFull
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetPixel
%ifdef GetPixel
%'ModuleName'_PixelColor %'ModuleName'%.%GetPixel(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y);
%define! Parx
%define! Pary
%define! RetVal
%include Common\GDisplayGetPixel.Inc

%endif %- GetPixel
%-BW_METHOD_END GetPixel
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawFilledBox
%ifdef DrawFilledBox
void %'ModuleName'%.%DrawFilledBox(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim width, %'ModuleName'_PixelDim height, %'ModuleName'_PixelColor color);
%define! Parx
%define! Pary
%define! Parwidth
%define! Parheight
%define! Parcolor
%include Common\GDisplayDrawFilledBox.Inc

%endif %- DrawFilledBox
%-BW_METHOD_END DrawFilledBox
%-************************************************************************************************************
%-BW_METHOD_BEGIN PutPixel
%ifdef PutPixel
void %'ModuleName'%.%PutPixel(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelColor color);
%define! Parx
%define! Pary
%define! Parcolor
%include Common\GDisplayPutPixel.Inc

%endif %- PutPixel
%-BW_METHOD_END PutPixel
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawBox
%ifdef DrawBox
void %'ModuleName'%.%DrawBox(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim width, %'ModuleName'_PixelDim height, %'ModuleName'_PixelDim lineWidth, %'ModuleName'_PixelColor color);
%define! Parx
%define! Pary
%define! Parwidth
%define! Parheight
%define! Parcolor
%define! ParlineWidth
%include Common\GDisplayDrawBox.Inc

%endif %- DrawBox
%-BW_METHOD_END DrawBox
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawMonoBitmap
%ifdef DrawMonoBitmap
void %'ModuleName'%.%DrawMonoBitmap(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, PIMAGE image, %'ModuleName'_PixelColor pixelColor, %'ModuleName'_PixelColor backgroundColor);
%define! Parx
%define! Pary
%define! Parimage
%define! ParpixelColor
%define! ParbackgroundColor
%include Common\GDisplayDrawMonoBitmap.Inc

%endif %- DrawMonoBitmap
%-BW_METHOD_END DrawMonoBitmap
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawHLine
%ifdef DrawHLine
void %'ModuleName'%.%DrawHLine(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim length, %'ModuleName'_PixelColor color);
%define! Parx
%define! Pary
%define! Parlength
%define! Parcolor
%include Common\GDisplayDrawHLine.Inc

%endif %- DrawHLine
%-BW_METHOD_END DrawHLine
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawVLine
%ifdef DrawVLine
void %'ModuleName'%.%DrawVLine(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim length, %'ModuleName'_PixelColor color);
%define! Parx
%define! Pary
%define! Parlength
%define! Parcolor
%include Common\GDisplayDrawVLine.Inc

%endif %- DrawVLine
%-BW_METHOD_END DrawVLine
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawBarChart
%ifdef DrawBarChart
void %'ModuleName'%.%DrawBarChart(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim width, %'ModuleName'_PixelDim height, byte *data, byte nofData, %'ModuleName'_PixelColor barColor, byte borderWidth, %'ModuleName'_PixelColor borderColor, byte borderSpace);
%define! Parx
%define! Pary
%define! Parwidth
%define! Parheight
%define! Pardata
%define! ParnofData
%define! ParborderWidth
%define! ParbarColor
%define! ParborderColor
%define! ParborderSpace
%include Common\GDisplayDrawBarChart.Inc

%endif %- DrawBarChart
%-BW_METHOD_END DrawBarChart
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawColorBitmap
%ifdef DrawColorBitmap
void %'ModuleName'%.%DrawColorBitmap(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, PIMAGE image);
%define! Parx
%define! Pary
%define! Parimage
%include Common\GDisplayDrawColorBitmap.Inc

%endif %- DrawColorBitmap
%-BW_METHOD_END DrawColorBitmap
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawLine
%ifdef DrawLine
void %'ModuleName'%.%DrawLine(%'ModuleName'_PixelDim xstart, %'ModuleName'_PixelDim ystart, %'ModuleName'_PixelDim xend, %'ModuleName'_PixelDim yend, %'ModuleName'_PixelColor color);
%define! Parcolor
%define! Parxstart
%define! Parystart
%define! Parxend
%define! Paryend
%include Common\GDisplayDrawLine.Inc

%endif %- DrawLine
%-BW_METHOD_END DrawLine
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawCircle
%ifdef DrawCircle
void %'ModuleName'%.%DrawCircle(%'ModuleName'_PixelDim x0, %'ModuleName'_PixelDim y0, %'ModuleName'_PixelDim radius, %'ModuleName'_PixelColor color);
%define! Parx0
%define! Pary0
%define! Parradius
%define! Parcolor
%include Common\GDisplayDrawCircle.Inc

%endif %- DrawCircle
%-BW_METHOD_END DrawCircle
%-************************************************************************************************************
%-BW_METHOD_BEGIN Draw65kBitmap
%ifdef Draw65kBitmap
void %'ModuleName'%.%Draw65kBitmap(%'ModuleName'_PixelDim x1, %'ModuleName'_PixelDim y1, %'ModuleName'_PixelDim x2, %'ModuleName'_PixelDim y2, word *bmp, bool compressed);
%define! Parx1
%define! Pary1
%define! Parx2
%define! Pary2
%define! Parcompressed
%define! Parbmp
%include Common\GDisplayDraw65kBitmap.Inc

%endif %- Draw65kBitmap
%-BW_METHOD_END Draw65kBitmap
%-************************************************************************************************************
%-BW_METHOD_BEGIN Draw256BitmapLow
%ifdef Draw256BitmapLow
void %'ModuleName'%.%Draw256BitmapLow(%'ModuleName'_PixelDim x1, %'ModuleName'_PixelDim y1, %'ModuleName'_PixelDim x2, %'ModuleName'_PixelDim y2, byte *bmp, bool compressed);
%define! Parx1
%define! Pary1
%define! Parx2
%define! Pary2
%define! Parcompressed
%define! Parbmp
%include Common\GDisplayDraw256BitmapLow.Inc

%endif %- Draw256BitmapLow
%-BW_METHOD_END Draw256BitmapLow
%-************************************************************************************************************
%-BW_METHOD_BEGIN Draw256BitmapHigh
%ifdef Draw256BitmapHigh
void %'ModuleName'%.%Draw256BitmapHigh(%'ModuleName'_PixelDim x1, %'ModuleName'_PixelDim y1, %'ModuleName'_PixelDim x2, %'ModuleName'_PixelDim y2, byte *bmp, %'ModuleName'_PixelColor *ColorTable, bool compressed);
%define! Parx1
%define! Pary1
%define! Parx2
%define! Pary2
%define! Parcompressed
%define! ParColorTable
%define! Parbmp
%include Common\GDisplayDraw256BitmapHigh.Inc

%endif %- Draw256BitmapHigh
%-BW_METHOD_END Draw256BitmapHigh
%-************************************************************************************************************
%-BW_METHOD_BEGIN UpdateRegion
%ifdef UpdateRegion
#define %'ModuleName'%.%UpdateRegion(x,y,w,h)   %@Display@'ModuleName'%.UpdateRegion(x,y,w,h)

%define! Parx
%define! Pary
%define! Parw
%define! Parh
%include Common\GDisplayUpdateRegion.Inc

%endif %- UpdateRegion
%-BW_METHOD_END UpdateRegion
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawFilledCircle
%ifdef DrawFilledCircle
void %'ModuleName'%.%DrawFilledCircle(%'ModuleName'_PixelDim x0, %'ModuleName'_PixelDim y0, %'ModuleName'_PixelDim radius, %'ModuleName'_PixelColor color);
%define! Parx0
%define! Pary0
%define! Parradius
%define! Parcolor
%include Common\GDisplayDrawFilledCircle.Inc

%endif %- DrawFilledCircle
%-BW_METHOD_END DrawFilledCircle
%-************************************************************************************************************
%ifdef GetDisplayOrientation
%-BW_PUBLISH_MACRO
%ifdef Orientation
%if %Orientation='Landscape'
#define %'ModuleName'%.%GetDisplayOrientation() %'ModuleName'%.ORIENTATION_LANDSCAPE
%elif %Orientation='Landscape180'
#define %'ModuleName'%.%GetDisplayOrientation() %'ModuleName'%.ORIENTATION_LANDSCAPE180
%elif %Orientation='Portrait'
#define %'ModuleName'%.%GetDisplayOrientation() %'ModuleName'%.ORIENTATION_PORTRAIT
%elif %Orientation='Portrait180'
#define %'ModuleName'%.%GetDisplayOrientation() %'ModuleName'%.ORIENTATION_PORTRAIT180
%endif
%else
#define %'ModuleName'%.%GetDisplayOrientation %@Display@'ModuleName'%.%GetDisplayOrientation
%endif
%define! RetVal
%include Common\GDisplayGetDisplayOrientation.Inc

%endif %- GetDisplayOrientation
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetDisplayOrientation
%ifdef SetDisplayOrientation
%-BW_PUBLISH_MACRO
#define %'ModuleName'%.%SetDisplayOrientation %@Display@'ModuleName'%.%SetDisplayOrientation
%define! ParnewOrientation
%include Common\GDisplaySetDisplayOrientation.Inc

%endif %- SetDisplayOrientation
%-BW_METHOD_END SetDisplayOrientation
%-************************************************************************************************************
%ifdef GetWidth
%-BW_PUBLISH_MACRO
%if %UseMemBuffer='yes'
%if %Orientation='Landscape' | %Orientation='Landscape180'
#define %'ModuleName'%.%GetWidth %@Display@'ModuleName'%.%GetLongerSide
%elif %Orientation='Portrait' | %Orientation='Portrait180'
#define %'ModuleName'%.%GetWidth %@Display@'ModuleName'%.%GetShorterSide
%endif
%else %- ask low level driver
#define %'ModuleName'%.%GetWidth %@Display@'ModuleName'%.%GetWidth
%endif
%define! RetVal
%include Common\GDisplayGetWidth.Inc

%endif %- GetWidth
%-************************************************************************************************************
%ifdef GetHeight
%-BW_PUBLISH_MACRO
%if %UseMemBuffer='yes'
%if %Orientation='Landscape' | %Orientation='Landscape180'
#define %'ModuleName'%.%GetHeight %@Display@'ModuleName'%.%GetShorterSide
%elif %Orientation='Portrait' | %Orientation='Portrait180'
#define %'ModuleName'%.%GetHeight %@Display@'ModuleName'%.%GetLongerSide
%endif
%else %- ask low level driver
#define %'ModuleName'%.%GetHeight %@Display@'ModuleName'%.%GetHeight
%endif
%define! RetVal
%include Common\GDisplayGetHeight.Inc

%endif %- GetHeight
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetLongerSide
%ifdef GetLongerSide
%-BW_PUBLISH_MACRO
#define %'ModuleName'%.%GetLongerSide %@Display@'ModuleName'%.%GetLongerSide
%define! RetVal
%include Common\GDisplayGetLongerSide.Inc

%endif %- GetLongerSide
%-BW_METHOD_END GetLongerSide
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetShorterSide
%ifdef GetShorterSide
%-BW_PUBLISH_MACRO
#define %'ModuleName'%.%GetShorterSide %@Display@'ModuleName'%.%GetShorterSide
%define! RetVal
%include Common\GDisplayGetShorterSide.Inc

%endif %- GetShorterSide
%-BW_METHOD_END GetShorterSide
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetDisplay
%ifdef GetDisplay
void %'ModuleName'%.%GetDisplay(void);
%include Common\GDisplayGetDisplay.Inc

%endif %- GetDisplay
%-BW_METHOD_END GetDisplay
%-************************************************************************************************************
%-BW_METHOD_BEGIN GiveDisplay
%ifdef GiveDisplay
void %'ModuleName'%.%GiveDisplay(void);
%include Common\GDisplayGiveDisplay.Inc

%endif %- GiveDisplay
%-BW_METHOD_END GiveDisplay
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
void %'ModuleName'%.%Init(void);
%include Common\GDisplayInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN OnError
%ifdef OnError
%INTERFACE OnError
void %OnError(void);
%include Common\GDisplayOnError.Inc

%endif %- OnError
%-BW_METHOD_END OnError
%-BW_METHOD_BEGIN OnGetDisplay
%ifdef OnGetDisplay
%INTERFACE OnGetDisplay
void %OnGetDisplay(void);
%include Common\GDisplayOnGetDisplay.Inc

%endif %- OnGetDisplay
%-BW_METHOD_END OnGetDisplay
%-BW_METHOD_BEGIN OnGiveDisplay
%ifdef OnGiveDisplay
%INTERFACE OnGiveDisplay
void %OnGiveDisplay(void);
%include Common\GDisplayOnGiveDisplay.Inc

%endif %- OnGiveDisplay
%-BW_METHOD_END OnGiveDisplay
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\GDisplaySettings.Inc
%define! Abstract Common\GDisplayAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%-
%ifdef RTOS
static xSemaphoreHandle %'ModuleName'%.displayMutex;

%endif
%-------------------------------------
%- Information on tested displays
%- bit0 is LSB (Least significant bit in memory)
%- bit7 is MSB (Most significant bit in memory)
%- Byte0 is first byte of display memory
%-------------------------------------
%- Nokia 3310 (Philips PDC8544):
%- Width:                84
%- Height:               48
%- Bytes in rows:        no
%- Bytes in x direction: yes
%- MSB first:            no
%-
%-       Column0: Column1:
%-       Byte0  Byte1
%- Row0: bit0   bit0
%- Row1: bit1   bit1
%- Row2: bit2   bit2
%-       ...    ...
%-       Byte84
%- Row8  bit0
%-       ...
%-------------------------------------
%- CanYourBadgeDoThis LED Matrix:
%- Width:                16
%- Height:               5
%- Bytes in rows:        yes
%- Bytes in x direction: no
%- MSB first:            no
%-
%-               Column0                     Column1
%- Row0:  Byte0: bit0 bit1 bit2 ....  byte5: bit0 bit1
%- Row1:  Byte1: bit0 bit1 bit2 ....  byte6: ......
%-
%-------------------------------------
%- Kent ChLCD:
%- Width:                132
%- Height:               64
%- Bytes in rows:        no
%- Bytes in x direction: yes
%- MSB first:            no
%-
%-       Column0: Column1:
%-       Byte0  Byte1
%- Row0: bit0   bit0
%- Row1: bit1   bit1
%- Row2: bit2   bit2
%-       ...    ...
%-       Byte132
%- Row8  bit0
%-       ...
%-
static const word c332to565[256] = { /* converts a 3-3-2 RBG value into a 5-6-5 RGB value */
 0x0000, 0x000A, 0x0014, 0xF81E, 0x0120, 0x012A, 0x0134, 0xF93E,
 0x0240, 0x024A, 0x0254, 0xFA5E, 0x0360, 0x036A, 0x0374, 0xFB7E,
 0x0480, 0x048A, 0x0494, 0xFC9E, 0x05A0, 0x05AA, 0x05B4, 0xFDBE,
 0x06C0, 0x06CA, 0x06D4, 0xFEDE, 0x07E0, 0x07EA, 0x07F4, 0xFFFE,
 0x2000, 0x200A, 0x2014, 0xF81E, 0x2120, 0x212A, 0x2134, 0xF93E,
 0x2240, 0x224A, 0x2254, 0xFA5E, 0x2360, 0x236A, 0x2374, 0xFB7E,
 0x2480, 0x248A, 0x2494, 0xFC9E, 0x25A0, 0x25AA, 0x25B4, 0xFDBE,
 0x26C0, 0x26CA, 0x26D4, 0xFEDE, 0x27E0, 0x27EA, 0x27F4, 0xFFFE,
 0x4000, 0x400A, 0x4014, 0xF81E, 0x4120, 0x412A, 0x4134, 0xF93E,
 0x4240, 0x424A, 0x4254, 0xFA5E, 0x4360, 0x436A, 0x4374, 0xFB7E,
 0x4480, 0x448A, 0x4494, 0xFC9E, 0x45A0, 0x45AA, 0x45B4, 0xFDBE,
 0x46C0, 0x46CA, 0x46D4, 0xFEDE, 0x47E0, 0x47EA, 0x47F4, 0xFFFE,
 0x6000, 0x600A, 0x6014, 0xF81E, 0x6120, 0x612A, 0x6134, 0xF93E,
 0x6240, 0x624A, 0x6254, 0xFA5E, 0x6360, 0x636A, 0x6374, 0xFB7E,
 0x6480, 0x648A, 0x6494, 0xFC9E, 0x65A0, 0x65AA, 0x65B4, 0xFDBE,
 0x66C0, 0x66CA, 0x66D4, 0xFEDE, 0x67E0, 0x67EA, 0x67F4, 0xFFFE,
 0x8000, 0x800A, 0x8014, 0xF81E, 0x8120, 0x812A, 0x8134, 0xF93E,
 0x8240, 0x824A, 0x8254, 0xFA5E, 0x8360, 0x836A, 0x8374, 0xFB7E,
 0x8480, 0x848A, 0x8494, 0xFC9E, 0x85A0, 0x85AA, 0x85B4, 0xFDBE,
 0x86C0, 0x86CA, 0x86D4, 0xFEDE, 0x87E0, 0x87EA, 0x87F4, 0xFFFE,
 0xA000, 0xA00A, 0xA014, 0xF81E, 0xA120, 0xA12A, 0xA134, 0xF93E,
 0xA240, 0xA24A, 0xA254, 0xFA5E, 0xA360, 0xA36A, 0xA374, 0xFB7E,
 0xA480, 0xA48A, 0xA494, 0xFC9E, 0xA5A0, 0xA5AA, 0xA5B4, 0xFDBE,
 0xA6C0, 0xA6CA, 0xA6D4, 0xFEDE, 0xA7E0, 0xA7EA, 0xA7F4, 0xFFFE,
 0xC000, 0xC00A, 0xC014, 0xF81E, 0xC120, 0xC12A, 0xC134, 0xF93E,
 0xC240, 0xC24A, 0xC254, 0xFA5E, 0xC360, 0xC36A, 0xC374, 0xFB7E,
 0xC480, 0xC48A, 0xC494, 0xFC9E, 0xC5A0, 0xC5AA, 0xC5B4, 0xFDBE,
 0xC6C0, 0xC6CA, 0xC6D4, 0xFEDE, 0xC7E0, 0xC7EA, 0xC7F4, 0xFFFE,
 0xF800, 0xF80A, 0xF814, 0xF81E, 0xF920, 0xF92A, 0xF934, 0xF93E,
 0xFA40, 0xFA4A, 0xFA54, 0xFA5E, 0xFB60, 0xFB6A, 0xFB74, 0xFB7E,
 0xFC80, 0xFC8A, 0xFC94, 0xFC9E, 0xFDA0, 0xFDAA, 0xFDB4, 0xFDBE,
 0xFEC0, 0xFECA, 0xFED4, 0xFEDE, 0xFFE0, 0xFFEA, 0xFFF4, 0xFFFE,
};
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN Clear
%ifdef Clear
%include Common\GDisplayClear.Inc
void %'ModuleName'%.%Clear(void)
{
%if %@Display@WindowCapability='yes' | %@Display@DisplayMemoryWrite='yes'
  %'ModuleName'%.%DrawFilledBox(0, 0, %'ModuleName'%.GetWidth(), %'ModuleName'%.GetHeight(), %'ModuleName'%.COLOR_WHITE);
%else %- use display buffer
  byte *p = &%@Display@'ModuleName'%.DisplayBuf[0][0]; /* first element in display buffer */

  while (p<((byte*)%@Display@'ModuleName'%.DisplayBuf)+sizeof(%@Display@'ModuleName'%.DisplayBuf)) {
 %if %@Display@BitsPerPixel='1'
    *p++ = (byte)(  (%'ModuleName'%.COLOR_WHITE<<7)
                  | (%'ModuleName'%.COLOR_WHITE<<6)
                  | (%'ModuleName'%.COLOR_WHITE<<5)
                  | (%'ModuleName'%.COLOR_WHITE<<4)
                  | (%'ModuleName'%.COLOR_WHITE<<3)
                  | (%'ModuleName'%.COLOR_WHITE<<2)
                  | (%'ModuleName'%.COLOR_WHITE<<1)
                  |  %'ModuleName'%.COLOR_WHITE
                 );
 %else
    *p++ = %'ModuleName'%.COLOR_WHITE;
 %endif
  }
%endif
}

%endif %- Clear
%-BW_METHOD_END Clear
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetPixel
%ifdef SetPixel
%define! Parx
%define! Pary
%include Common\GDisplaySetPixel.Inc
void %'ModuleName'%.%SetPixel(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y)
{
%if ndefined(OnError) & %@Display@WindowCapability='yes'
 %- we do not have OnError(), and using Window capabilities: only need to check for boundaries in case of memory buffer
%else
  if (x>=%'ModuleName'%.GetWidth() || y>=%'ModuleName'%.GetHeight()) { /* values out of range */
  %ifdef OnError
    %OnError(); /* call error handler */
  %endif
    return;
  }
%endif
  %ifdef RTOS
  %'ModuleName'%.GetDisplay();
  %endif
%if %@Display@WindowCapability='yes'
  %@Display@'ModuleName'%.OpenWindow(x, y, x, y);                %>40 /* set up a one pixel window */
  %@Display@'ModuleName'%.WritePixel(%'ModuleName'%.COLOR_BLACK);%>40 /* store pixel with color information */
  %@Display@'ModuleName'%.CloseWindow();                         %>40 /* close and execute window */
%elif %@Display@DisplayMemoryWrite='yes'
  %@Display@'ModuleName'%.SetPixel(x, y);
%else %- use memory buffer
  %'ModuleName'%.BUF_BYTE(x,y) |= %'ModuleName'%.BUF_BYTE_PIXEL_MASK(x,y);
%endif
  %ifdef RTOS
  %'ModuleName'%.GiveDisplay();
  %endif
}

%endif %- SetPixel
%-BW_METHOD_END SetPixel
%-************************************************************************************************************
%-BW_METHOD_BEGIN ClrPixel
%ifdef ClrPixel
%define! Parx
%define! Pary
%include Common\GDisplayClrPixel.Inc
void %'ModuleName'%.%ClrPixel(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y)
{
%if ndefined(OnError) & %@Display@WindowCapability='yes'
 %- we do not have OnError(), and using Window capabilities: only need to check for boundaries in case of memory buffer
%else
  if (x>=%'ModuleName'%.GetWidth() || y>=%'ModuleName'%.GetHeight()) { /* values out of range */
  %ifdef OnError
    %OnError(); /* call error handler */
  %endif
    return;
  }
%endif
  %ifdef RTOS
  %'ModuleName'%.GetDisplay();
  %endif
%if %@Display@WindowCapability='yes'
  %@Display@'ModuleName'%.OpenWindow(x, y, x, y);                %>40 /* set up a one pixel window */
  %@Display@'ModuleName'%.WritePixel(%'ModuleName'%.COLOR_WHITE);%>40 /* store pixel with color information */
  %@Display@'ModuleName'%.CloseWindow();                         %>40 /* close and execute window */
%elif %@Display@DisplayMemoryWrite='yes'
  %@Display@'ModuleName'%.ClrPixel(x, y);
%else %- use buffer
  %'ModuleName'%.BUF_BYTE(x,y) &= ~%'ModuleName'%.BUF_BYTE_PIXEL_MASK(x,y);
%endif
  %ifdef RTOS
  %'ModuleName'%.GiveDisplay();
  %endif
}

%endif %- ClrPixel
%-BW_METHOD_END ClrPixel
%-************************************************************************************************************
%-BW_METHOD_BEGIN NegPixel
%ifdef NegPixel
%define! Parx
%define! Pary
%include Common\GDisplayNegPixel.Inc
void %'ModuleName'%.%NegPixel(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y)
{
%if ndefined(OnError) & %@Display@WindowCapability='yes'
 %- we do not have OnError(), and using Window capabilities: only need to check for boundaries in case of memory buffer
%else
  if (x>=%'ModuleName'%.GetWidth() || y>=%'ModuleName'%.GetHeight()) { /* values out of range */
  %ifdef OnError
    %OnError(); /* call error handler */
  %endif
    return;
  }
%endif
%if %@Display@WindowCapability='yes'
  #warning "not using RAM buffer may mean that this is not possible at all (unless read from display)?"
  (void)x; (void)y; /* avoid compiler warning */
  /* NYI */
%elif %@Display@DisplayMemoryWrite='yes'
  %@Display@'ModuleName'%.NegPixel(x, y);
%else %- use memory buffer
  %'ModuleName'%.BUF_BYTE(x,y) ^= %'ModuleName'%.BUF_BYTE_PIXEL_MASK(x,y);
%endif
}

%endif %- NegPixel
%-BW_METHOD_END NegPixel
%-************************************************************************************************************
%-BW_METHOD_BEGIN UpdateFull
%ifdef UpdateFull
%include Common\GDisplayUpdateFull.Inc
/* method is implemented as macro in header file
void %'ModuleName'%.%UpdateFull(void)
{
}
*/

%endif %- UpdateFull
%-BW_METHOD_END UpdateFull
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetPixel
%ifdef GetPixel
%define! Parx
%define! Pary
%define! RetVal
%include Common\GDisplayGetPixel.Inc
%'ModuleName'_PixelColor %'ModuleName'%.%GetPixel(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y)
{
%if ndefined(OnError) & %@Display@WindowCapability='yes'
 %- we do not have OnError(), and using Window capabilities: only need to check for boundaries in case of memory buffer
%else
  if (x>=%'ModuleName'%.GetWidth() || y>=%'ModuleName'%.GetHeight()) { /* values out of range */
  %ifdef OnError
    %OnError(); /* call error handler */
  %endif
    return 0;
  }
%endif
%if %@Display@WindowCapability='yes'
  #warning "not using RAM buffer may mean that this is not possible at all (unless read from display)?"
  (void)x; (void)y; /* avoid compiler warning */
  return %'ModuleName'%.COLOR_BLACK; /* NYI */
%elif %@Display@DisplayMemoryWrite='yes'
  return %@Display@'ModuleName'%.GetPixel(x, y);
%else %- use memory buffer
  return (%'ModuleName'_PixelColor)%'ModuleName'%.BUF_BYTE_GET_PIXEL(x,y);
%endif
}

%endif %- GetPixel
%-BW_METHOD_END GetPixel
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawFilledBox
%ifdef DrawFilledBox
%define! Parx
%define! Pary
%define! Parwidth
%define! Parheight
%define! Parcolor
%include Common\GDisplayDrawFilledBox.Inc
void %'ModuleName'%.%DrawFilledBox(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim width, %'ModuleName'_PixelDim height, %'ModuleName'_PixelColor color)
{
%if %@Display@WindowCapability='yes'
  %'ModuleName'_PixelCount pixCnt;
  %'ModuleName'_PixelDim x1, y1;
%elif %@Display@DisplayMemoryWrite='yes'
%else %- use memory buffer
  %'ModuleName'%.PixelDim x0, xe, y0, ye;
%endif
  %'ModuleName'_PixelDim d_width = %'ModuleName'%.GetWidth();
  %'ModuleName'_PixelDim d_height = %'ModuleName'%.GetHeight();

%if ndefined(OnError) & %@Display@WindowCapability='yes'
 %- we do not have OnError(), and using Window capabilities: only need to check for boundaries in case of memory buffer
%else
  if (   width==0 || height==0
      || x>=d_width || y>=d_height
     ) {
  %ifdef OnError
    %OnError(); /* call error handler */
  %endif
    return; /* nothing to do */
  }
%endif
  if (x+width>d_width) { /* value out of range */
  %ifdef OnError
    %OnError(); /* call error handler */
  %endif
    if (x>=d_width) {
      return;                                                    %>40/* completely outside of display */
    } else {
      width = (%'ModuleName'_PixelDim)(d_width-x);
    }
  }
  if (y+height>d_height) { /* value out of range */
%ifdef OnError
    %OnError(); /* call error handler */
%endif
    if (y>=d_height) {
      return;                                                    %>40/* completely outside of display */
    } else {
      height = (%'ModuleName'_PixelDim)(d_height-y);
    }
  }
%if %@Display@WindowCapability='yes'
  x1 = (%'ModuleName'_PixelDim)(x+width-1);                      %>40 /* set window lower right x coordinate */
  y1 = (%'ModuleName'_PixelDim)(y+height-1);                     %>40 /* set window lower right y coordinate */
  pixCnt = (%'ModuleName'_PixelCount)((x1-x+1)*(y1-y+1));        %>40 /* number of pixels to write */
  %ifdef RTOS
  %'ModuleName'%.GetDisplay();
  %endif
  %@Display@'ModuleName'%.OpenWindow(x, y, x1, y1);              %>40 /* set up window as large as the box */
  while (pixCnt>0) {
    %@Display@'ModuleName'%.WritePixel(color);                   %>40 /* store pixel with color information */
    pixCnt--;
  } /* while */
  %@Display@'ModuleName'%.CloseWindow();                         %>40 /* close and execute window */
  %ifdef RTOS
  %'ModuleName'%.GiveDisplay();
  %endif
%elif %@Display@DisplayMemoryWrite='yes'
  %@Display@'ModuleName'%.DrawFilledBox(x, y, width, height, color);
  %ifdef RTOS
  %'ModuleName'%.GiveDisplay();
  %endif
%else %- use memory buffer
  y0 = y; ye = (%'ModuleName'%.PixelDim)(y0+height-1);
  %ifdef RTOS
  %'ModuleName'%.GetDisplay();
  %endif
  for(;;) { /* breaks */
    x0 = x; xe = (%'ModuleName'%.PixelDim)(x0+width-1);
    for(;;) { /* process line, breaks */
      %'ModuleName'%.%PutPixel(x0, y0, color);
      if (x0==xe) {
        %if WatchdogEnabled='yes'
        %@Watchdog@'ModuleName'%.Clear();                        %>40/* kick the dog in order not to timeout */
        %endif
        break; /* reached end of line */
      }
      x0++;
    } /* for */
    if (y0==ye) break; /* reached end */
    y0++;
  } /* for */
  %ifdef RTOS
  %'ModuleName'%.GiveDisplay();
  %endif
%endif
}

%endif %- DrawFilledBox
%-BW_METHOD_END DrawFilledBox
%-************************************************************************************************************
%-BW_METHOD_BEGIN PutPixel
%ifdef PutPixel
%define! Parx
%define! Pary
%define! Parcolor
%include Common\GDisplayPutPixel.Inc
#ifdef __HC08__
  #pragma MESSAGE DISABLE C4001 /* condition always FALSE */
#endif
void %'ModuleName'%.%PutPixel(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelColor color)
{
%if ndefined(OnError) & %@Display@WindowCapability='yes'
 %- we do not have OnError(), and using Window capabilities: only need to check for boundaries in case of memory buffer
%else
  if (x>=%'ModuleName'%.GetWidth() || y>=%'ModuleName'%.GetHeight()) { /* values out of range */
  %ifdef OnError
    %OnError(); /* call error handler */
  %endif
    return;
  }
%endif
  %ifdef RTOS
  %'ModuleName'%.GetDisplay();
  %endif
%if %@Display@WindowCapability='yes'
  %@Display@'ModuleName'%.OpenWindow(x, y, x, y);                %>40 /* set up window as large as the box */
  %@Display@'ModuleName'%.WritePixel(color);                     %>40 /* store pixel with color information */
  %@Display@'ModuleName'%.CloseWindow();                         %>40 /* close and execute window */
%else %- use memory buffer
  if (   (color==%'ModuleName'%.COLOR_BLACK && %'ModuleName'%.COLOR_BLACK==%'ModuleName'%.COLOR_PIXEL_SET)
      || (color==%'ModuleName'%.COLOR_WHITE && %'ModuleName'%.COLOR_WHITE==%'ModuleName'%.COLOR_PIXEL_SET)
     )
  {
    %'ModuleName'%.%SetPixel(x,y);
  } else {
    %'ModuleName'%.%ClrPixel(x,y);
  }
%endif
%ifdef RTOS
  %'ModuleName'%.GiveDisplay();
%endif
}
#ifdef __HC08__
  #pragma MESSAGE DEFAULT C4001 /* condition always FALSE */
#endif

%endif %- PutPixel
%-BW_METHOD_END PutPixel
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawBox
%ifdef DrawBox
%define! Parx
%define! Pary
%define! Parwidth
%define! Parheight
%define! Parcolor
%define! ParlineWidth
%include Common\GDisplayDrawBox.Inc
void %'ModuleName'%.%DrawBox(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim width, %'ModuleName'_PixelDim height, %'ModuleName'_PixelDim lineWidth, %'ModuleName'_PixelColor color)
{
  /* top line: */
  %'ModuleName'%.DrawFilledBox(x, y, width, lineWidth, color);
  /* left line: */
  %'ModuleName'%.DrawFilledBox(x, (%'ModuleName'%.PixelDim)(y+lineWidth), lineWidth, (%'ModuleName'%.PixelDim)(height-(2*lineWidth)), color);
  /* right line: */
  %'ModuleName'%.DrawFilledBox((%'ModuleName'%.PixelDim)(x+width-lineWidth), (%'ModuleName'%.PixelDim)(y+lineWidth), lineWidth, (%'ModuleName'%.PixelDim)(height-(2*lineWidth)), color);
  /* bottom line: */
  %'ModuleName'%.DrawFilledBox(x, (%'ModuleName'%.PixelDim)(y+height-lineWidth), width, lineWidth, color);
}

%endif %- DrawBox
%-BW_METHOD_END DrawBox
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawMonoBitmap
%ifdef DrawMonoBitmap
%define! Parx
%define! Pary
%define! Parimage
%define! ParpixelColor
%define! ParbackgroundColor
%include Common\GDisplayDrawMonoBitmap.Inc
void %'ModuleName'%.%DrawMonoBitmap(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, PIMAGE image, %'ModuleName'_PixelColor pixelColor, %'ModuleName'_PixelColor backgroundColor)
{
  %'ModuleName'%.PixelDim x0, y0, xe, ye;
  %'ModuleName'%.PixelColor pixel;
  byte i;
  const byte *data;

%ifdef OnError
  if (   image->width==0 || image->height==0
      || x+image->width>%'ModuleName'%.GetWidth() || y+image->height>%'ModuleName'%.GetHeight()
      )
  { /* values out of range */
    %OnError(); /* call error handler */
    return;
  }
%endif
  data = image->pixmap;
  y0 = y;
  ye = (%'ModuleName'%.PixelDim)(y+image->height-1);
  xe = (%'ModuleName'%.PixelDim)(x+image->width-1);
  for(;;) {
    i=7;
    x0 = x;
    for(;;) {
      pixel = (%'ModuleName'%.PixelColor)(((*data)&(1<<i))>>i); /* extract pixel out of bitstream */
      %'ModuleName'%.%PutPixel(x0, y0, (%'ModuleName'%.PixelColor)(pixel==1?pixelColor:backgroundColor));
      if (i==0 && x0!=xe) { /* next byte inside the row */
        data++;
        i = 7;
      } else {
        i--;
      }
      if (x0==xe) { /* reached end of line, next row */
        data++; /* next data byte */
        break;
      }
      x0++;
    } /* for */
    if (y0==ye) break; /* reached end */
    y0++;
  } /* for */
}

%endif %- DrawMonoBitmap
%-BW_METHOD_END DrawMonoBitmap
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawColorBitmap
%ifdef DrawColorBitmap
%define! Parx
%define! Pary
%define! Parimage
%include Common\GDisplayDrawColorBitmap.Inc
void %'ModuleName'%.%DrawColorBitmap(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, PIMAGE image)
{
  %'ModuleName'%.PixelDim x0, y0, xe, ye;
  %'ModuleName'%.PixelColor pixel;
  const byte *data;

%ifdef OnError
  if (   image->width==0 || image->height==0
      || x+image->width>%'ModuleName'%.GetWidth() || y+image->height>%'ModuleName'%.GetHeight()
      )
  { /* values out of range */
    %OnError(); /* call error handler */
    return;
  }
%endif
  data = image->pixmap;
  y0 = y;
  ye = (%'ModuleName'%.PixelDim)(y+image->height-1);
  xe = (%'ModuleName'%.PixelDim)(x+image->width-1);
  for(;;) {
    x0 = x;
    for(;;) {
      pixel = (%'ModuleName'%.PixelColor)c332to565[*data]; /* extract pixel out of bitstream and convert it to our color mode*/
      %'ModuleName'%.%PutPixel(x0, y0, pixel);
      data++;
      if (x0==xe) { /* reached end of line, next row */
        break;
      }
      x0++;
    } /* for */
    if (y0==ye) break; /* reached end */
    y0++;
  } /* for */
}

%endif %- DrawColorBitmap
%-BW_METHOD_END DrawColorBitmap
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawHLine
%ifdef DrawHLine
%define! Parx
%define! Pary
%define! Parlength
%define! Parcolor
%include Common\GDisplayDrawHLine.Inc
void %'ModuleName'%.%DrawHLine(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim length, %'ModuleName'_PixelColor color)
{
%ifdef OnError
  if (   x>=%'ModuleName'%.GetWidth() || y>=%'ModuleName'%.GetHeight() /* start inside display? */
      || x+length>%'ModuleName'%.GetWidth() /* not going beyond display */
      )
  { /* values out of range */
    %OnError(); /* call error handler */
    return;
  }
%endif
  %'ModuleName'%.DrawFilledBox(x, y, length, 1, color);
}

%endif %- DrawHLine
%-BW_METHOD_END DrawHLine
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawVLine
%ifdef DrawVLine
%define! Parx
%define! Pary
%define! Parlength
%define! Parcolor
%include Common\GDisplayDrawVLine.Inc
void %'ModuleName'%.%DrawVLine(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim length, %'ModuleName'_PixelColor color)
{
%ifdef OnError
  if (   x>=%'ModuleName'%.GetWidth() || y>=%'ModuleName'%.GetHeight() /* start inside display? */
      || y+length>%'ModuleName'%.GetHeight() /* not going beyond display */
      )
  { /* values out of range */
    %OnError(); /* call error handler */
    return;
  }
%endif
  %'ModuleName'%.DrawFilledBox(x, y, 1, length, color);
}

%endif %- DrawVLine
%-BW_METHOD_END DrawVLine
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawBarChart
%ifdef DrawBarChart
%define! Parx
%define! Pary
%define! Parwidth
%define! Parheight
%define! Pardata
%define! ParnofData
%define! ParborderWidth
%define! ParbarColor
%define! ParborderColor
%define! ParborderSpace
%include Common\GDisplayDrawBarChart.Inc
void %'ModuleName'%.%DrawBarChart(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim width, %'ModuleName'_PixelDim height, byte *data, byte nofData, %'ModuleName'_PixelColor barColor, byte borderWidth, %'ModuleName'_PixelColor borderColor, byte borderSpace)
{
  byte i;
  %'ModuleName'%.PixelDim barHeight; /* for calculation of each bar height */
  %'ModuleName'%.PixelDim barWidth; /* bar width, based on even distribution of the bars */

  if (borderWidth > 0) { /* border */
    %'ModuleName'%.DrawBox(x, y, width, height, borderWidth, borderColor);
  }
  /* reduce drawing area because of border */
  x += borderWidth+borderSpace;
  y += borderWidth+borderSpace;
  width -= 2*(borderWidth+borderSpace);
  height -= 2*(borderWidth+borderSpace);

  /* calculat bar width based on number of bars so we fill out our drawing area */
  barWidth = (%'ModuleName'%.PixelDim)((width-(nofData+1)*borderSpace)/nofData);

  /* draw some bars */
  for(i=0; i<nofData; i++) {
    barHeight = (%'ModuleName'%.PixelDim)((height*data[i])/100); /* scale with %% value */
    if (barHeight > 0) {
      %'ModuleName'%.DrawFilledBox(x, (%'ModuleName'_PixelDim)(y+height-barHeight), barWidth, barHeight, barColor);
    }
    x += barWidth+borderSpace;
  }
}

%endif %- DrawBarChart
%-BW_METHOD_END DrawBarChart
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawLine
%ifdef DrawLine
%define! Parcolor
%define! Parxstart
%define! Parystart
%define! Parxend
%define! Paryend
%include Common\GDisplayDrawLine.Inc
void %'ModuleName'%.%DrawLine(%'ModuleName'_PixelDim xstart, %'ModuleName'_PixelDim ystart, %'ModuleName'_PixelDim xend, %'ModuleName'_PixelDim yend, %'ModuleName'_PixelColor color)
{
  /* Based on Bresenham algorithm and http://de.wikipedia.org/wiki/Bresenham-Algorithmus */
  #define sgn(x) ((x) > 0) ? 1 : ((x) < 0) ? -1 : 0
  %'ModuleName'_PixelDim x, y;
  int t, dx, dy, incx, incy, pdx, pdy, ddx, ddy, es, el, err;

  /* Calculate distance in both dimensions */
  dx = xend - xstart;
  dy = yend - ystart;
  /* Determin sign of increment */
  incx = sgn(dx);
  incy = sgn(dy);
  if(dx<0) dx = -dx;
  if(dy<0) dy = -dy;
  /* Check which distance is larger */
  if (dx>dy) { /* we are faster in x direction */
    pdx=incx; pdy=0;    /* pd. is parallel step */
    ddx=incx; ddy=incy; /* dd. is diagonal step */
    es =dy;   el =dx;   /* error steps fast (es) and slow (el) */
  } else { /* faster in y direction */
    pdx=0;    pdy=incy; /* pd. is parallel step */
    ddx=incx; ddy=incy; /* dd. is diagonal step */
    es =dx;   el =dy;   /* error step fast (es) and slow (el) */
  }
  /* Do some initialization first... */
  x = xstart; y = ystart; err = el/2;
  %'ModuleName'%.%PutPixel(x, y, color); /* put first pixel */
  /* calculate pixels */
  for(t=0; t<el; ++t) { /* t counts the pixels, el is the number of pixels */
    err -= es; /* adapt error */
    if(err<0) { /* make error positive again */
      err += el;
      /* step into the slow direction, diagonal step  */
      x += ddx;
      y += ddy;
    } else {
      /* step into the fast direction, parallel step*/
      x += pdx;
      y += pdy;
    }
    %'ModuleName'%.%PutPixel(x, y, color);
  }
}

%endif %- DrawLine
%-BW_METHOD_END DrawLine
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawCircle
%ifdef DrawCircle
%define! Parx0
%define! Pary0
%define! Parradius
%define! Parcolor
%include Common\GDisplayDrawCircle.Inc
void %'ModuleName'%.%DrawCircle(%'ModuleName'_PixelDim x0, %'ModuleName'_PixelDim y0, %'ModuleName'_PixelDim radius, %'ModuleName'_PixelColor color)
{
  /* draw a circle using the Bresenham method, see http://de.wikipedia.org/wiki/Bresenham-Algorithmus */
  int f = 1 - radius;
  int ddF_x = 0;
  int ddF_y = -2 * radius;
  %'ModuleName'_PixelDim x = 0;
  %'ModuleName'_PixelDim y = radius;

  %'ModuleName'%.%PutPixel(x0, (%'ModuleName'_PixelDim)(y0 + radius), color);
  %'ModuleName'%.%PutPixel(x0, (%'ModuleName'_PixelDim)(y0 - radius), color);
  %'ModuleName'%.%PutPixel((%'ModuleName'_PixelDim)(x0 + radius), y0, color);
  %'ModuleName'%.%PutPixel((%'ModuleName'_PixelDim)(x0 - radius), y0, color);
  while(x < y) {
    if(f >= 0) {
      y--;
      ddF_y += 2;
      f += ddF_y;
    }
    x++;
    ddF_x += 2;
    f += ddF_x + 1;
    %'ModuleName'%.%PutPixel((%'ModuleName'_PixelDim)(x0 + x), (%'ModuleName'_PixelDim)(y0 + y), color);
    %'ModuleName'%.%PutPixel((%'ModuleName'_PixelDim)(x0 - x), (%'ModuleName'_PixelDim)(y0 + y), color);
    %'ModuleName'%.%PutPixel((%'ModuleName'_PixelDim)(x0 + x), (%'ModuleName'_PixelDim)(y0 - y), color);
    %'ModuleName'%.%PutPixel((%'ModuleName'_PixelDim)(x0 - x), (%'ModuleName'_PixelDim)(y0 - y), color);
    %'ModuleName'%.%PutPixel((%'ModuleName'_PixelDim)(x0 + y), (%'ModuleName'_PixelDim)(y0 + x), color);
    %'ModuleName'%.%PutPixel((%'ModuleName'_PixelDim)(x0 - y), (%'ModuleName'_PixelDim)(y0 + x), color);
    %'ModuleName'%.%PutPixel((%'ModuleName'_PixelDim)(x0 + y), (%'ModuleName'_PixelDim)(y0 - x), color);
    %'ModuleName'%.%PutPixel((%'ModuleName'_PixelDim)(x0 - y), (%'ModuleName'_PixelDim)(y0 - x), color);
  }
}

%endif %- DrawCircle
%-BW_METHOD_END DrawCircle
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawFilledCircle
%ifdef DrawFilledCircle
%define! Parx0
%define! Pary0
%define! Parradius
%define! Parcolor
%include Common\GDisplayDrawFilledCircle.Inc
void %'ModuleName'%.%DrawFilledCircle(%'ModuleName'_PixelDim x0, %'ModuleName'_PixelDim y0, %'ModuleName'_PixelDim radius, %'ModuleName'_PixelColor color)
{
  /* draw a circle using the Bresenham method, see http://de.wikipedia.org/wiki/Bresenham-Algorithmus */
  %'ModuleName'_PixelDim xoff=0;
  %'ModuleName'_PixelDim yoff=radius;
  int balance=-((int)radius);
  %'ModuleName'_PixelDim p0, p1, w0, w1;

  while (xoff <= yoff) {
    p0 = (%'ModuleName'_PixelDim)(x0-xoff);
    p1 = (%'ModuleName'_PixelDim)(x0-yoff);
    w0 = (%'ModuleName'_PixelDim)(2*xoff);
    w1 = (%'ModuleName'_PixelDim)(2*yoff);
    %'ModuleName'%.%DrawHLine(p0, (%'ModuleName'_PixelDim)(y0+yoff), w0, color);
    %'ModuleName'%.%DrawHLine(p0, (%'ModuleName'_PixelDim)(y0-yoff), w0, color);
    %'ModuleName'%.%DrawHLine(p1, (%'ModuleName'_PixelDim)(y0+xoff), w1, color);
    %'ModuleName'%.%DrawHLine(p1, (%'ModuleName'_PixelDim)(y0-xoff), w1, color);
    if ((balance += xoff++ + xoff)>= 0) {
      balance -= --yoff+yoff;
    }
  } /* while */
}

%endif %- DrawFilledCircle
%-BW_METHOD_END DrawFilledCircle
%-************************************************************************************************************
%-BW_METHOD_BEGIN Draw65kBitmap
%ifdef Draw65kBitmap
%define! Parx1
%define! Pary1
%define! Parx2
%define! Pary2
%define! Parcompressed
%define! Parbmp
%include Common\GDisplayDraw65kBitmap.Inc
void %'ModuleName'%.%Draw65kBitmap(%'ModuleName'_PixelDim x1, %'ModuleName'_PixelDim y1, %'ModuleName'_PixelDim x2, %'ModuleName'_PixelDim y2, word *bmp, bool compressed)
{
%if %@Display@WindowCapability='yes'
  %'ModuleName'_PixelCount pixelCount = (%'ModuleName'_PixelCount)((x2-x1+1) * (y2-y1+1));

%endif
  %ifdef RTOS
  %'ModuleName'%.GetDisplay();
  %endif
%if %@Display@WindowCapability='yes'
  %@Display@'ModuleName'%.OpenWindow(x1, y1, x2, y2);            %>40 /* set up window as large as the box */
  if (compressed) {
    %'ModuleName'_PixelColor PixelColor = 0;
    word Pos = 0;
    bool FirstRead = TRUE;
    word i;
    word Repeat;

    for (i=0; i<pixelCount; i++) {
      if (FirstRead) {                                           %>40 /* read first pixel after first start or after finishing a compressed bunch of data */
        PixelColor = (%'ModuleName'%.PixelColor)bmp[Pos++];
        %@Display@'ModuleName'%.WritePixel(PixelColor);          %>40 /* paint pixel */
        FirstRead = FALSE;
      } else {
        word LastPixel = PixelColor;                             %>40 /* save data of last pixel (word format) to temporary variable */

        PixelColor = (%'ModuleName'%.PixelColor)bmp[Pos++];      %>40 /* read next pixel */
        %@Display@'ModuleName'%.WritePixel(PixelColor);          %>40 /* paint new pixel */
        if (LastPixel == PixelColor) {                           %>40 /* check if the last two read pixels are identical */
          Repeat = bmp[Pos++];                                   %>40 /* if yes: read number following pixels of this color */
          i += Repeat;                                           %>40 /* increment pixel counter */
          while (Repeat--) {                                     %>40 /* output requested number of pixels */
            %@Display@'ModuleName'%.WritePixel(PixelColor);
          }
          FirstRead = TRUE;                                      %>40 /* restart potential repetition sequence */
        }
      }
    }
  } else {
    word i;
    %'ModuleName'_PixelColor pixelColor;

    for(i=0; i<pixelCount; i++) {
      pixelColor = (%'ModuleName'%.PixelColor)bmp[i];
      %@Display@'ModuleName'%.WritePixel(pixelColor);
    }
  }
  %@Display@'ModuleName'%.CloseWindow();                         %>40 /* close and execute window */
%else
  /* NYI */
  (void)x1; (void)y1; (void)x2; (void)y2; (void)bmp; (void)compressed;%>40 /* avoid compiler warning */
%endif
  %ifdef RTOS
  %'ModuleName'%.GiveDisplay();
  %endif
}

%endif %- Draw65kBitmap
%-BW_METHOD_END Draw65kBitmap
%-************************************************************************************************************
%-BW_METHOD_BEGIN Draw256BitmapHigh
%ifdef Draw256BitmapHigh
%define! Parx1
%define! Pary1
%define! Parx2
%define! Pary2
%define! Parcompressed
%define! ParColorTable
%define! Parbmp
%include Common\GDisplayDraw256BitmapHigh.Inc
void %'ModuleName'%.%Draw256BitmapHigh(%'ModuleName'_PixelDim x1, %'ModuleName'_PixelDim y1, %'ModuleName'_PixelDim x2, %'ModuleName'_PixelDim y2, byte *bmp, %'ModuleName'_PixelColor *ColorTable, bool compressed)
{
%if %@Display@WindowCapability='yes'
  %'ModuleName'_PixelCount pixelCount = (%'ModuleName'_PixelCount)((x2-x1+1) * (y2-y1+1));

%endif
  %ifdef RTOS
  %'ModuleName'%.GetDisplay();
  %endif
%if %@Display@WindowCapability='yes'
  %@Display@'ModuleName'%.OpenWindow(x1, y1, x2, y2);            %>40 /* set up window as large as the box */
  if (compressed) {
    byte PixelColorIndex = 0;
    word Pos = 0;
    bool FirstRead = TRUE;
    word i;
    byte LastPixelIndex;
    byte Repeat;

    for (i=0; i<pixelCount; i++) {
      if (FirstRead) {                                           %>40 /* read first pixel after first start or after finishing a compressed bunch of data */
        PixelColorIndex = bmp[Pos++];
        %@Display@'ModuleName'%.WritePixel(ColorTable[PixelColorIndex]);
        FirstRead = FALSE;
      } else {
        LastPixelIndex = PixelColorIndex;                        %>40 /* save data of last pixel (word format) to temporary variable */
        PixelColorIndex = bmp[Pos++];                            %>40 /* read next pixel */
        %@Display@'ModuleName'%.WritePixel(ColorTable[PixelColorIndex]);
        if (LastPixelIndex == PixelColorIndex) {                 %>40 /* check if the last two read pixels are identical */
          Repeat = bmp[Pos++];                                   %>40 /* if yes: read number following pixels of this color */
          i += Repeat;                                           %>40 /* increment pixel counter */
          while (Repeat--) {                                     %>40 /* output requested number of pixels */
            %@Display@'ModuleName'%.WritePixel(ColorTable[PixelColorIndex]);
          }
          FirstRead = TRUE;                                      %>40 /* restart potential repetition sequence */
        }
      }
    }
  } else {
    %'ModuleName'_PixelCount i;
    byte PixelColorIndex;
    word PixelColor;

    for(i=0; i<pixelCount; i++) {
      PixelColorIndex = bmp[i];
      PixelColor = ColorTable[PixelColorIndex];
      %@Display@'ModuleName'%.WritePixel(PixelColor);
    }
  }
  %@Display@'ModuleName'%.CloseWindow();                         %>40 /* close and execute window */
%else
  /* NYI */
  (void)x1; (void)y1; (void)x2; (void)y2; (void)bmp;  (void)ColorTable; (void)compressed;%>40 /* avoid compiler warning */
%endif
  %ifdef RTOS
  %'ModuleName'%.GiveDisplay();
  %endif
}

%endif %- Draw256BitmapHigh
%-BW_METHOD_END Draw256BitmapHigh
%-************************************************************************************************************
%-BW_METHOD_BEGIN Draw256BitmapLow
%ifdef Draw256BitmapLow
%define! Parx1
%define! Pary1
%define! Parx2
%define! Pary2
%define! Parcompressed
%define! Parbmp
%include Common\GDisplayDraw256BitmapLow.Inc
void %'ModuleName'%.%Draw256BitmapLow(%'ModuleName'_PixelDim x1, %'ModuleName'_PixelDim y1, %'ModuleName'_PixelDim x2, %'ModuleName'_PixelDim y2, byte *bmp, bool compressed)
{
/* For uncompressed bitmap data:
      The pixels are provided in an array of 8bit pixel information (bmp[]).
      Each byte describes a pixel in 3-3-2 RBG format
   For compressed bitmap data:
      If two bytes are the same, this means that the 3rd byte contains how many times the color has to be repeated.
      Example: 10 red dots are compressed as:
        RED RED 8
 */

%if %@Display@WindowCapability='yes'
  %'ModuleName'_PixelCount pixelCount = (%'ModuleName'_PixelCount)((x2-x1+1) * (y2-y1+1));

%endif
  %ifdef RTOS
  %'ModuleName'%.GetDisplay();
  %endif
%if %@Display@WindowCapability='yes'
  %@Display@'ModuleName'%.OpenWindow(x1, y1, x2, y2);            %>40 /* set up window as large as the box */
  if (compressed) {
    /* compressed pixel information */
    byte pixelColor = 0;
    byte lastPixel;
    %'ModuleName'_PixelCount pos = 0;
    bool first = TRUE;                                           %>40 /* if we read the first time, or if we may have a new sequence */
    byte repeat;

    while(pixelCount!=0) {                                       %>40 /* while there are pixels to write... */
      if (first) {                                               %>40 /* first pixel, or first after a compressed sequence */
        pixelColor = *bmp;                                       %>40 /* read pixel */
        bmp++;                                                   %>40 /* advance pointer to next pixel */
        %@Display@'ModuleName'%.WritePixel(c332to565[pixelColor]);%>40 /* write pixel */
        pixelCount--;                                            %>40 /* one more done */
        first = FALSE;                                           %>40 /* reset flag */
      } else {
        lastPixel = pixelColor;                                  %>40 /* remember already written pixel to detect potential compressed sequence */
        pixelColor = *bmp;                                       %>40 /* read pixel */
        bmp++;                                                   %>40 /* advance pointer to next pixel */
        %@Display@'ModuleName'%.WritePixel(c332to565[pixelColor]);%>40 /* write pixel */
        pixelCount--;                                            %>40 /* one more done */
        if (lastPixel == pixelColor) {                           %>40 /* do we have twice the same pixel? Then it this starts a compressed sequence... */
          repeat = *bmp;                                         %>40 /* yes! read the number of pixels to repeat */
          bmp++;                                                 %>40 /* next byte in stream */
          pixelCount -= repeat;                                  %>40 /* a bunch more will be done */
          while (repeat--) {                                     %>40 /* write requested amount of pixels */
            %@Display@'ModuleName'%.WritePixel(c332to565[pixelColor]);%>40 /* write pixel */
          } /* while */
          first = TRUE;                                          %>40 /* set flag for new sequence */
        }
      }
    }
  } else {
    /* uncompressed pixel information */
    while(pixelCount != 0) {                                     %>40 /* while there are pixels to write... */
      %@Display@'ModuleName'%.WritePixel(c332to565[*bmp]);       %>40 /* write pixel */
      bmp++;                                                     %>40 /* next byte */
      pixelCount--;                                              %>40 /* one more done */
    } /* for */
  }
  %@Display@'ModuleName'%.CloseWindow();                         %>40 /* close and execute window */
%else
  /* NYI */
  (void)x1; (void)y1; (void)x2; (void)y2; (void)bmp; (void)compressed;%>40 /* avoid compiler warning */
%endif
  %ifdef RTOS
  %'ModuleName'%.GiveDisplay();
  %endif
}

%endif %- Draw256BitmapLow
%-BW_METHOD_END Draw256BitmapLow
%-************************************************************************************************************
%-BW_METHOD_BEGIN UpdateRegion
%ifdef UpdateRegion
%define! Parx
%define! Pary
%define! Parw
%define! Parh
%include Common\GDisplayUpdateRegion.Inc
#if 0
void %'ModuleName'%.%UpdateRegion(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim w, %'ModuleName'_PixelDim h)
{
  /* method is implemented as macro in the header file */
}
#endif

%endif %- UpdateRegion
%-BW_METHOD_END UpdateRegion
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetDisplayOrientation
%ifdef GetDisplayOrientation
%define! RetVal
%include Common\GDisplayGetDisplayOrientation.Inc
/*
%'ModuleName'_DisplayOrientation %'ModuleName'%.%GetDisplayOrientation(void)
  ** This method is implemented as macro
*/

%endif %- GetDisplayOrientation
%-BW_METHOD_END GetDisplayOrientation
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetDisplayOrientation
%ifdef SetDisplayOrientation
%define! ParnewOrientation
%include Common\GDisplaySetDisplayOrientation.Inc
/*
void %'ModuleName'%.%SetDisplayOrientation(%'ModuleName'_DisplayOrientation newOrientation)
  ** This method is implemented as macro
*/

%endif %- SetDisplayOrientation
%-BW_METHOD_END SetDisplayOrientation
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetWidth
%ifdef GetWidth
%define! RetVal
%include Common\GDisplayGetWidth.Inc
/*
%'ModuleName'_PixelDim %'ModuleName'%.%GetWidth(void)
  ** This method is implemented as macro
*/

%endif %- GetWidth
%-BW_METHOD_END GetWidth
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetHeight
%ifdef GetHeight
%define! RetVal
%include Common\GDisplayGetHeight.Inc
/*
%'ModuleName'_PixelDim %'ModuleName'%.%GetHeight(void)
  ** This method is implemented as macro
*/

%endif %- GetHeight
%-BW_METHOD_END GetHeight
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetLongerSide
%ifdef GetLongerSide
%define! RetVal
%include Common\GDisplayGetLongerSide.Inc
/*
%'ModuleName'_PixelDim %'ModuleName'%.%GetLongerSide(void)
  ** This method is implemented as macro
*/

%endif %- GetLongerSide
%-BW_METHOD_END GetLongerSide
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetShorterSide
%ifdef GetShorterSide
%define! RetVal
%include Common\GDisplayGetShorterSide.Inc
/*
%'ModuleName'_PixelDim %'ModuleName'%.%GetShorterSide(void)
  ** This method is implemented as macro
*/

%endif %- GetShorterSide
%-BW_METHOD_END GetShorterSide
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetDisplay
%ifdef GetDisplay
%include Common\GDisplayGetDisplay.Inc
void %'ModuleName'%.%GetDisplay(void)
{
%ifdef RTOS
  %@RTOS@'ModuleName'%.xSemaphoreTakeRecursive(%'ModuleName'%.displayMutex, portMAX_DELAY);
%endif
%if defined(OnGetDisplay)
  %OnGetDisplay();
%endif
  %@Display@'ModuleName'%.GetLCD();
}

%endif %- GetDisplay
%-BW_METHOD_END GetDisplay
%-************************************************************************************************************
%-BW_METHOD_BEGIN GiveDisplay
%ifdef GiveDisplay
%include Common\GDisplayGiveDisplay.Inc
void %'ModuleName'%.%GiveDisplay(void)
{
  %@Display@'ModuleName'%.GiveLCD();
%if defined(OnGiveDisplay)
  %OnGiveDisplay();
%endif
%ifdef RTOS
  %@RTOS@'ModuleName'%.xSemaphoreGiveRecursive(%'ModuleName'%.displayMutex);
%endif
}

%endif %- GiveDisplay
%-BW_METHOD_END GiveDisplay
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%include Common\GDisplayInit.Inc
void %'ModuleName'%.%Init(void)
{
  %if ClearScreenOnInit='yes'
  %'ModuleName'%.%Clear(); /* clear display memory */
  %'ModuleName'%.%UpdateFull(); /* update display */
  %endif
  %ifdef RTOS
  %'ModuleName'%.displayMutex = %@RTOS@'ModuleName'%.xSemaphoreCreateRecursiveMutex();
  %endif
}

%endif %- Init
%-BW_METHOD_END Init
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_METHOD_BEGIN OnError
%ifdef OnError
%IMPLEMENTATION OnError
%include Common\GDisplayOnError.Inc
void %OnError(void)
{
  /* Write your code here ... */
}

%endif %- OnError
%-BW_METHOD_END OnError
%-BW_METHOD_BEGIN OnGetDisplay
%ifdef OnGetDisplay
%IMPLEMENTATION OnGetDisplay
%include Common\GDisplayOnGetDisplay.Inc
void %OnGetDisplay(void)
{
  /* Write your code here ... */
}

%endif %- OnGetDisplay
%-BW_METHOD_END OnGetDisplay
%-BW_METHOD_BEGIN OnGiveDisplay
%ifdef OnGiveDisplay
%IMPLEMENTATION OnGiveDisplay
%include Common\GDisplayOnGiveDisplay.Inc
void %OnGiveDisplay(void)
{
  /* Write your code here ... */
}

%endif %- OnGiveDisplay
%-BW_METHOD_END OnGiveDisplay
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
%if ClearScreenOnInit='yes' | defined(RTOS)
  %'ModuleName'%.Init();
%endif
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This bean is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
