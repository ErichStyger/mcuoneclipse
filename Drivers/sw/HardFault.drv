%-Driver generated by the Component Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Component Wizard
%- If you change these lines, Component Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    26.12.2012
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_HandlerC Additional handler which decodes the processor status
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\HardFaultSettings.Inc
%define! Abstract Common\HardFaultAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
%-BW_CUSTOM_USERTYPE_END


%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN HardFaultHandler
%ifdef HardFaultHandler
void %'ModuleName'%.%HardFaultHandler(void);
%include Common\HardFaultHardFaultHandler.Inc

%endif %- HardFaultHandler
%-BW_METHOD_END HardFaultHandler
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG HandlerC
void %'ModuleName'%.HandlerC(dword *hardfault_args);
%define! Parhardfault_args
%include Common\GeneralInternal.inc (HandlerC)

%-INTERNAL_METHOD_END HandlerC
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\HardFaultSettings.Inc
%define! Abstract Common\HardFaultAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%if (CPUfamily = "Kinetis")
%- =============================================================================
%- Allocation of interrupt vectors by component.
%- =============================================================================
%-
%if (defined(PEversionDecimal) && (PEversionDecimal >=0 '1282')) %- this is only supported with MCU 10.3
%- Get interrupts info from CPU database
%- Note: this is done only for Kinetis for now.
%:tmp = %CPUDB_define_Interrupt_Vectors_info()
%-
 %for vect from InterruptVectors
   %if %"%'vect'" = 'defaultInt'
     %if vect = 'ivINT_Hard_Fault'
       %define_prj %'vect' %'ModuleName'%.%HardFaultHandler
     %else
       %- keep PEx default
     %endif
   %endif
 %endfor
%-
%endif %- MCU 10.3
%-
%else
  %error "this component is only supported for GCC and Kinetis!"
%endif %-(CPUfamily = "Kinetis")
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%-
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG HandlerC
%define! Parhardfault_args
%include Common\GeneralInternal.inc (HandlerC)
/**
 * This is called from the HardFaultHandler with a pointer the Fault stack
 * as the parameter. We can then read the values from the stack and place them
 * into local variables for ease of reading.
 * We then read the various Fault Status and Address Registers to help decode
 * cause of the fault.
 * The function ends with a BKPT instruction to force control back into the debugger
 */
%if %Compiler = "GNUC"
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
%endif
void %'ModuleName'%.HandlerC(dword *hardfault_args)
{
%if (%Compiler = "IARARM")
  volatile unsigned long stacked_r0;
  volatile unsigned long stacked_r1;
  volatile unsigned long stacked_r2;
  volatile unsigned long stacked_r3;
  volatile unsigned long stacked_r12;
  volatile unsigned long stacked_lr;
  volatile unsigned long stacked_pc;
  volatile unsigned long stacked_psr;
  volatile unsigned long _CFSR;
  volatile unsigned long _HFSR;
  volatile unsigned long _DFSR;
  volatile unsigned long _AFSR;
  volatile unsigned long _BFAR;
  volatile unsigned long _MMAR;
%else
  static volatile unsigned long stacked_r0;
  static volatile unsigned long stacked_r1;
  static volatile unsigned long stacked_r2;
  static volatile unsigned long stacked_r3;
  static volatile unsigned long stacked_r12;
  static volatile unsigned long stacked_lr;
  static volatile unsigned long stacked_pc;
  static volatile unsigned long stacked_psr;
  static volatile unsigned long _CFSR;
  static volatile unsigned long _HFSR;
  static volatile unsigned long _DFSR;
  static volatile unsigned long _AFSR;
  static volatile unsigned long _BFAR;
  static volatile unsigned long _MMAR;
%endif
  stacked_r0 = ((unsigned long)hardfault_args[0]);
  stacked_r1 = ((unsigned long)hardfault_args[1]);
  stacked_r2 = ((unsigned long)hardfault_args[2]);
  stacked_r3 = ((unsigned long)hardfault_args[3]);
  stacked_r12 = ((unsigned long)hardfault_args[4]);
  stacked_lr = ((unsigned long)hardfault_args[5]);
  stacked_pc = ((unsigned long)hardfault_args[6]);
  stacked_psr = ((unsigned long)hardfault_args[7]);

  /* Configurable Fault Status Register */
  /* Consists of MMSR, BFSR and UFSR */
  _CFSR = (*((volatile unsigned long *)(0xE000ED28)));

  /* Hard Fault Status Register */
  _HFSR = (*((volatile unsigned long *)(0xE000ED2C)));

  /* Debug Fault Status Register */
  _DFSR = (*((volatile unsigned long *)(0xE000ED30)));

  /* Auxiliary Fault Status Register */
  _AFSR = (*((volatile unsigned long *)(0xE000ED3C)));

  /* Read the Fault Address Registers. These may not contain valid values.
   * Check BFARVALID/MMARVALID to see if they are valid values
   * MemManage Fault Address Register
   */
  _MMAR = (*((volatile unsigned long *)(0xE000ED34)));
  /* Bus Fault Address Register */
  _BFAR = (*((volatile unsigned long *)(0xE000ED38)));

  __asm("BKPT #0\n") ; /* cause the debugger to stop */
}

%-INTERNAL_METHOD_END HandlerC
%-************************************************************************************************************
%-BW_METHOD_BEGIN HardFaultHandler
%ifdef HardFaultHandler
%include Common\HardFaultHardFaultHandler.Inc
%if %Compiler = "GNUC"
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
__attribute__((naked))
void %'ModuleName'%.%HardFaultHandler(void)
{
  __asm volatile (
    " movs r0,#4      \n"  /* load bit mask into R0 */
    " mov r1, lr      \n"  /* load link register into R1 */
    " tst r0, r1      \n"  /* compare with bitmask */
    " beq _MSP        \n"  /* if bitmask is set: stack pointer is in PSP. Otherwise in MSP */
    " mrs r0, psp     \n"  /* otherwise: stack pointer is in PSP */
    " b _GetPC        \n"  /* go to part which loads the PC */
    "_MSP:            \n"  /* stack pointer is in MSP register */
    " mrs r0, msp     \n"  /* load stack pointer into R0 */
    "_GetPC:          \n"  /* find out where the hard fault happened */
    " ldr r1,[r0,#20] \n"  /* load program counter into R1. R1 contains address of the next instruction where the hard fault happened */
    " b %'ModuleName'%.HandlerC   \n"  /* decode more information. R0 contains pointer to stack frame */
  );
}
%elif (%Compiler = "ARM_CC") %- Keil/ARM compiler
void %'ModuleName'%.%HardFaultHandler(void)
{
  int r0, r1; /* explicitly declared registers */

  __asm {
    movs r0,#4      /* load bit mask into R0 */
    mov r1, lr      /* load link register into R1 */
    tst r0, r1      /* compare with bitmask */
    beq _MSP        /* if bitmask is set: stack pointer is in PSP. Otherwise in MSP */
    mrs r0, psp     /* otherwise: stack pointer is in PSP */
    b _GetPC        /* go to part which loads the PC */
  _MSP:             /* stack pointer is in MSP register */
    mrs r0, msp     /* load stack pointer into R0 */
  _GetPC:           /* find out where the hard fault happened */
    ldr r1,[r0,#20] /* load program counter into R1. R1 contains address of the next instruction where the hard fault happened */
    b %'ModuleName'%.HandlerC  /* decode more information. R0 contains pointer to stack frame */
  }
}
%elif (%Compiler = "IARARM")
  /* %'ModuleName'%.HardFaultHandler() is implemented in assembly in %'ModuleName'%.HardFaultHandler.s */
%else
  #error "unsupported compiler."
%endif

%endif %- HardFaultHandler
%-BW_METHOD_END HardFaultHandler
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
  /* Write code here ... */
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%if (%Compiler = "IARARM")
%- need to implement the handler in assembly, as IAR does not support inline assembly with labels?
%FILE %'DirRel_Code'%'ModuleName'%.HardFaultHandler.s
  /* use code segment, and we are generating ARM thumb code: */
  RSEG    CODE:CODE(2)
  thumb

  /* external interface declaration; */
  PUBLIC %'ModuleName'%.%HardFaultHandler

  /* list of external functions we are going to use: */
  EXTERN %'ModuleName'%.HandlerC

/*-----------------------------------------------------------*/
%'ModuleName'%.%HardFaultHandler:
  movs r0,#4        /* load bit mask into R0 */
  mov r1, lr      /* load link register into R1 */
  tst r0, r1       /* compare with bitmask */
  beq _MSP         /* if bitmask is set: stack pointer is in PSP. Otherwise in MSP */
  mrs r0, psp      /* otherwise: stack pointer is in PSP */
  b _GetPC         /* go to part which loads the PC */
  _MSP:             /* stack pointer is in MSP register */
  mrs r0, msp      /* load stack pointer into R0 */
  _GetPC:           /* find out where the hard fault happened */
  ldr r1,[r0,#20]  /* load program counter into R1. R1 contains address of the next instruction where the hard fault happened */
  b %'ModuleName'%.HandlerC  /* decode more information. R0 contains pointer to stack frame */
/*-----------------------------------------------------------*/
  END
%endif %- (%Compiler = "IARARM")
%else %- Language (& Compiler)
  %error^ This component is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
