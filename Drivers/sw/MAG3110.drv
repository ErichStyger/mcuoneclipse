%-Driver pre-generated by the Component Development Environment
%-      Copyright: 1997 - 2013 Freescale Semiconductor, Inc. All Rights Reserved.
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Component Wizard
%- If you change these lines, Component Development Environment will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Erich Styger
%define DriverVersion 01.00
%define DriverDate    03/31/2013
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_Read16bitBEValue Reads a 16bit value to the device. Value is read in Big Endian and returned in the proper format depending of LE/BE of microcontroller.
%define! Description_Write16bitBEValue Writes a 16bit value to the device. Value is written in Big Endian.
%-BW_INTERN_COMMENTS_END
%-
%define CDEversion Standard
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
  %-
%-
%INTERFACE
%define! Settings Common\MAG3110Settings.Inc
%define! Abstract Common\MAG3110Abstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited components */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
%ifdef ParseCommand
#define %'ModuleName'%.PARSE_COMMAND_ENABLED  1  /* set to 1 if method ParseCommand() is present, 0 otherwise */
%else
#define %'ModuleName'%.PARSE_COMMAND_ENABLED  0 /* set to 1 if method ParseCommand() is present, 0 otherwise */
%endif %- ParseCommand

/* data ready register */
#define %'ModuleName'%.DR_STATUS 0x00 /* data ready status register address */
#define %'ModuleName'%.DR_STATUS_ZYXOW_BIT_MASK   (1<<7) /* X, Y, Z-axis data overwrite */
#define %'ModuleName'%.DR_STATUS_ZOW_BIT_MASK     (1<<6) /* Z-axis data overwrite */
#define %'ModuleName'%.DR_STATUS_YOW_BIT_MASK     (1<<5) /* Y-axis data overwrite */
#define %'ModuleName'%.DR_STATUS_XOW_BIT_MASK     (1<<4) /* X-axis data overwrite */
#define %'ModuleName'%.DR_STATUS_ZXYDR_BIT_MASK   (1<<3) /* X or Y or Z-axis new data ready */
#define %'ModuleName'%.DR_STATUS_ZDR_BIT_MASK     (1<<2) /* Z-axis new data ready */
#define %'ModuleName'%.DR_STATUS_YDR_BIT_MASK     (1<<1) /* >-axis new data ready */
#define %'ModuleName'%.DR_STATUS_XDR_BIT_MASK     (1<<0) /* X-axis new data ready */

/* data registers */
#define %'ModuleName'%.OUT_X_MSB 0x01 /* X output MSB address */
#define %'ModuleName'%.OUT_X_LSB 0x02 /* X output LSB address */
#define %'ModuleName'%.OUT_Y_MSB 0x03 /* Y output MSB address */
#define %'ModuleName'%.OUT_Y_LSB 0x04 /* Y output LSB address */
#define %'ModuleName'%.OUT_Z_MSB 0x05 /* Z output MSB address */
#define %'ModuleName'%.OUT_Z_LSB 0x06 /* Z output LSB address */

/* 'who am I' register */
#define %'ModuleName'%.WHO_AM_I  0x07 /* device ID number */

/* system mode register */
#define %'ModuleName'%.SYSMOD    0x08 /* current system mode register address */
#define %'ModuleName'%.SYSMOD_STANDBY_BIT_MASK    0x00 /* standby mode */
#define %'ModuleName'%.SYSMOD_ACTIVE_RAW_BIT_MASK 0x01 /* active, with raw data */
#define %'ModuleName'%.SYSMOD_ACTIVE_BIT_MASK     0x02 /* active, with user corrected data */

/* offset registers */
#define %'ModuleName'%.OFF_X_MSB 0x09 /* user offset X MSB register address */
#define %'ModuleName'%.OFF_X_LSB 0x0A /* user offset X LSB register address */
#define %'ModuleName'%.OFF_Y_MSB 0x0B /* user offset Y MSB register address */
#define %'ModuleName'%.OFF_Y_LSB 0x0C /* user offset Y LSB register address */
#define %'ModuleName'%.OFF_Z_MSB 0x0D /* user offset Z MSB register address */
#define %'ModuleName'%.OFF_Z_LSB 0x0E /* user offset Z LSB register address */

/* die temperature (needs to add an offset as not factory trimmed) */
#define %'ModuleName'%.DIE_TEMP  0x0F /* die temperature register, signed 8bit in C */

/* control register 1 */
#define %'ModuleName'%.CTRL_REG_1 0x10 /* CTRL 1 register address */
#define %'ModuleName'%.CTRL_REG_1_AC_BIT_MASK           0x01 /* active mode */
#define %'ModuleName'%.CTRL_REG_1_TM_BIT_MASK           0x02 /* trigger immediate measurement */
#define %'ModuleName'%.CTRL_REG_1_FR_BIT_MASK           0x04 /* fast read selection */

#define %'ModuleName'%.CTRL_REG_1_OS_BITS_POS           (3)  /* bit position */
#define %'ModuleName'%.CTRL_REG_1_OS_START              (16) /* value 0 below is starting with oversampling 16  */
#define %'ModuleName'%.CTRL_REG_1_OS_16_BIT_MASK        (0x0<<%'ModuleName'%.CTRL_REG_1_OS_BITS_POS) /* oversampling ration 16 */
#define %'ModuleName'%.CTRL_REG_1_OS_32_BIT_MASK        (0x1<<%'ModuleName'%.CTRL_REG_1_OS_BITS_POS) /* oversampling ration 32 */
#define %'ModuleName'%.CTRL_REG_1_OS_64_BIT_MASK        (0x2<<%'ModuleName'%.CTRL_REG_1_OS_BITS_POS) /* oversampling ration 64 */
#define %'ModuleName'%.CTRL_REG_1_OS_128_BIT_MASK       (0x3<<%'ModuleName'%.CTRL_REG_1_OS_BITS_POS) /* oversampling ration 128 */
#define %'ModuleName'%.CTRL_REG_1_OS_FULL_BIT_MASK      (0x3<<%'ModuleName'%.CTRL_REG_1_OS_BITS_POS) /* all bits set */

#define %'ModuleName'%.CTRL_REG_1_DR_BITS_POS           (5)    /* bit position */
#define %'ModuleName'%.CTRL_REG_1_DR_START              (1280) /* value 0 below is starting with 1280 Hz */
#define %'ModuleName'%.CTRL_REG_1_DR_1280HZ_BIT_MASK    (0x0<<%'ModuleName'%.CTRL_REG_1_DR_BITS_POS) /* ADC Rate 1280 Hz */
#define %'ModuleName'%.CTRL_REG_1_DR_640HZ_BIT_MASK     (0x1<<%'ModuleName'%.CTRL_REG_1_DR_BITS_POS) /* ADC Rate 640 Hz */
#define %'ModuleName'%.CTRL_REG_1_DR_320HZ_BIT_MASK     (0x2<<%'ModuleName'%.CTRL_REG_1_DR_BITS_POS) /* ADC Rate 320 Hz */
#define %'ModuleName'%.CTRL_REG_1_DR_160HZ_BIT_MASK     (0x3<<%'ModuleName'%.CTRL_REG_1_DR_BITS_POS) /* ADC Rate 160 Hz */
#define %'ModuleName'%.CTRL_REG_1_DR_80HZ_BIT_MASK      (0x4<<%'ModuleName'%.CTRL_REG_1_DR_BITS_POS) /* ADC Rate 80 Hz */
#define %'ModuleName'%.CTRL_REG_1_DR_40HZ_BIT_MASK      (0x5<<%'ModuleName'%.CTRL_REG_1_DR_BITS_POS) /* ADC Rate 40 Hz */
#define %'ModuleName'%.CTRL_REG_1_DR_20HZ_BIT_MASK      (0x6<<%'ModuleName'%.CTRL_REG_1_DR_BITS_POS) /* ADC Rate 20 Hz */
#define %'ModuleName'%.CTRL_REG_1_DR_10HZ_BIT_MASK      (0x7<<%'ModuleName'%.CTRL_REG_1_DR_BITS_POS) /* ADC Rate 10 Hz */
#define %'ModuleName'%.CTRL_REG_1_DR_FULL_BIT_MASK      (0x7<<%'ModuleName'%.CTRL_REG_1_DR_BITS_POS) /* all bits set */

/* control register 2 */
#define %'ModuleName'%.CTRL_REG_2 0x11 /* CTRL 2 register address */
#define %'ModuleName'%.CTRL_REG_2_AUTO_MRST_EN_BIT_MASK  (1<<7) /* automatic magnetic sensor reset */
#define %'ModuleName'%.CTRL_REG_2_RAW_BIT_MASK           (1<<5) /* raw mode  */
#define %'ModuleName'%.CTRL_REG_2_MAG_RST_BIT_MASK       (1<<4) /* magnetic sensor reset (one-shot) */

#define %'ModuleName'%.I2C_ADDR   (%I2CSlaveAddress) /* I2C slave device address as set in the properties */

%-BW_CUSTOM_USERTYPE_END

%-BW_DEFINITION_START
%-*****************************************************************************************************
%-BW_METHOD_BEGIN GetXYZ16
%ifdef GetXYZ16
uint8_t %'ModuleName'%.%GetXYZ16(int16_t *xyz);
%define! Parxyz
%define! RetVal
%include Common\MAG3110GetRaw8XYZ.inc
%endif %- GetXYZ16
%-BW_METHOD_END GetXYZ16

%-*****************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
uint8_t %'ModuleName'%.%Deinit(void);
%define!  RetVal
%include Common\MAG3110Deinit.inc
%endif  %-Deinit
%-BW_METHOD_END Deinit

%-*****************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
uint8_t %'ModuleName'%.%Init(void);
%define!  RetVal
%include Common\MAG3110Init.inc
%endif  %-Init
%-BW_METHOD_END Init

%-************************************************************************************************************
%-BW_METHOD_BEGIN GetX
%ifdef GetX
word %'ModuleName'%.%GetX(int16_t *value);
%define! Parvalue
%define! RetVal
%include Common\MAG3110GetX.Inc

%endif %- GetX
%-BW_METHOD_END GetX
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetY
%ifdef GetY
word %'ModuleName'%.%GetY(int16_t *value);
%define! Parvalue
%define! RetVal
%include Common\MAG3110GetY.Inc

%endif %- GetY
%-BW_METHOD_END GetY
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetZ
%ifdef GetZ
word %'ModuleName'%.%GetZ(int16_t *value);
%define! Parvalue
%define! RetVal
%include Common\MAG3110GetZ.Inc

%endif %- GetZ
%-BW_METHOD_END GetZ
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
byte %'ModuleName'%.%ParseCommand(const unsigned char *cmd, bool *handled, const %@Shell@'ModuleName'%.StdIOType *io);
%define! Parcmd
%define! Parhandled
%define! Pario
%define! RetVal
%include Common\MAG3110ParseCommand.Inc

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetFastReadMode
%ifdef SetFastReadMode
byte %'ModuleName'%.%SetFastReadMode(bool on);
%define! Paron
%define! RetVal
%include Common\MAG3110SetFastReadMode.Inc

%endif %- SetFastReadMode
%-BW_METHOD_END SetFastReadMode
%-************************************************************************************************************
%-BW_METHOD_BEGIN Enable
%ifdef Enable
byte %'ModuleName'%.%Enable(void);
%define! RetVal
%include Common\MAG3110Enable.Inc

%endif %- Enable
%-BW_METHOD_END Enable
%-************************************************************************************************************
%-BW_METHOD_BEGIN Disable
%ifdef Disable
byte %'ModuleName'%.%Disable(void);
%define! RetVal
%include Common\MAG3110Disable.Inc

%endif %- Disable
%-BW_METHOD_END Disable
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetTemperature
%ifdef GetTemperature
byte %'ModuleName'%.%GetTemperature(signed char *temperature);
%define! Partemperature
%define! RetVal
%include Common\MAG3110GetTemperature.Inc

%endif %- GetTemperature
%-BW_METHOD_END GetTemperature
%-************************************************************************************************************
%-BW_METHOD_BEGIN WhoAmI
%ifdef WhoAmI
byte %'ModuleName'%.%WhoAmI(byte *value);
%define! Parvalue
%define! RetVal
%include Common\MAG3110WhoAmI.Inc

%endif %- WhoAmI
%-BW_METHOD_END WhoAmI
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetSysMode
%ifdef GetSysMode
byte %'ModuleName'%.%GetSysMode(byte *mode);
%define! Parmode
%define! RetVal
%include Common\MAG3110GetSysMode.Inc

%endif %- GetSysMode
%-BW_METHOD_END GetSysMode
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetUserOffsetCorrection
%ifdef GetUserOffsetCorrection
byte %'ModuleName'%.%GetUserOffsetCorrection(int16_t *x, int16_t *y, int16_t *z);
%define! Parx
%define! Pary
%define! Parz
%define! RetVal
%include Common\MAG3110GetUserOffsetCorrection.Inc

%endif %- GetUserOffsetCorrection
%-BW_METHOD_END GetUserOffsetCorrection
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetUserOffsetCorrection
%ifdef SetUserOffsetCorrection
byte %'ModuleName'%.%SetUserOffsetCorrection(int16_t x, int16_t y, int16_t z);
%define! Parx
%define! Pary
%define! Parz
%define! RetVal
%include Common\MAG3110SetUserOffsetCorrection.Inc

%endif %- SetUserOffsetCorrection
%-BW_METHOD_END SetUserOffsetCorrection
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG Write16bitBEValue
byte %'ModuleName'%.Write16bitBEValue(byte addr, word value);
%define! Paraddr
%define! Parvalue
%define! RetVal
%include Common\GeneralInternal.inc (Write16bitBEValue)

%-INTERNAL_METHOD_END Write16bitBEValue
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG Read16bitBEValue
byte %'ModuleName'%.Read16bitBEValue(byte addr, word *value);
%define! Paraddr
%define! Parvalue
%define! RetVal
%include Common\GeneralInternal.inc (Read16bitBEValue)

%-INTERNAL_METHOD_END Read16bitBEValue
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteReg
%ifdef WriteReg
byte %'ModuleName'%.%WriteReg(byte reg, byte val);
%define! Parreg
%define! Parval
%define! RetVal
%include Common\MAG3110WriteReg.Inc

%endif %- WriteReg
%-BW_METHOD_END WriteReg
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadReg
%ifdef ReadReg
byte %'ModuleName'%.%ReadReg(byte addr, byte *val);
%define! Paraddr
%define! Parval
%define! RetVal
%include Common\MAG3110ReadReg.Inc

%endif %- ReadReg
%-BW_METHOD_END ReadReg
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetSysMode
%ifdef SetSysMode
byte %'ModuleName'%.%SetSysMode(byte mode);
%define! Parmode
%define! RetVal
%include Common\MAG3110SetSysMode.Inc

%endif %- SetSysMode
%-BW_METHOD_END SetSysMode
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetXYZ8
%ifdef GetXYZ8
uint8_t %'ModuleName'%.%GetXYZ8(signed char *xyz);
%define! Parxyz
%define! RetVal
%include Common\MAG3110GetXYZ8.Inc

%endif %- GetXYZ8
%-BW_METHOD_END GetXYZ8
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetFastReadMode
%ifdef GetFastReadMode
byte %'ModuleName'%.%GetFastReadMode(bool *isOn);
%define! ParisOn
%define! RetVal
%include Common\MAG3110GetFastReadMode.Inc

%endif %- GetFastReadMode
%-BW_METHOD_END GetFastReadMode
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetTriggerImmediateMode
%ifdef SetTriggerImmediateMode
byte %'ModuleName'%.%SetTriggerImmediateMode(bool on);
%define! Paron
%define! RetVal
%include Common\MAG3110SetTriggerImmediateMode.Inc

%endif %- SetTriggerImmediateMode
%-BW_METHOD_END SetTriggerImmediateMode
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetTriggerImmediateMode
%ifdef GetTriggerImmediateMode
byte %'ModuleName'%.%GetTriggerImmediateMode(bool *isOn);
%define! ParisOn
%define! RetVal
%include Common\MAG3110GetTriggerImmediateMode.Inc

%endif %- GetTriggerImmediateMode
%-BW_METHOD_END GetTriggerImmediateMode
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetOversamplingMode
%ifdef SetOversamplingMode
byte %'ModuleName'%.%SetOversamplingMode(byte bits);
%define! Parbits
%define! RetVal
%include Common\MAG3110SetOversamplingMode.Inc

%endif %- SetOversamplingMode
%-BW_METHOD_END SetOversamplingMode
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetOversamplingMode
%ifdef GetOversamplingMode
byte %'ModuleName'%.%GetOversamplingMode(byte *bits);
%define! Parbits
%define! RetVal
%include Common\MAG3110GetOversamplingMode.Inc

%endif %- GetOversamplingMode
%-BW_METHOD_END GetOversamplingMode
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetDataRateMode
%ifdef SetDataRateMode
byte %'ModuleName'%.%SetDataRateMode(byte bits);
%define! Parbits
%define! RetVal
%include Common\MAG3110SetDataRateMode.Inc

%endif %- SetDataRateMode
%-BW_METHOD_END SetDataRateMode
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetDataRateMode
%ifdef GetDataRateMode
byte %'ModuleName'%.%GetDataRateMode(byte *bits);
%define! Parbits
%define! RetVal
%include Common\MAG3110GetDataRateMode.Inc

%endif %- GetDataRateMode
%-BW_METHOD_END GetDataRateMode
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetRawMode
%ifdef SetRawMode
byte %'ModuleName'%.%SetRawMode(bool on);
%define! Paron
%define! RetVal
%include Common\MAG3110SetRawMode.Inc

%endif %- SetRawMode
%-BW_METHOD_END SetRawMode
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetRawMode
%ifdef GetRawMode
byte %'ModuleName'%.%GetRawMode(bool *isOn);
%define! ParisOn
%define! RetVal
%include Common\MAG3110GetRawMode.Inc

%endif %- GetRawMode
%-BW_METHOD_END GetRawMode
%-************************************************************************************************************
%-BW_METHOD_BEGIN MagneticSensorReset
%ifdef MagneticSensorReset
byte %'ModuleName'%.%MagneticSensorReset(void);
%define! RetVal
%include Common\MAG3110MagneticSensorReset.Inc

%endif %- MagneticSensorReset
%-BW_METHOD_END MagneticSensorReset
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\MAG3110Settings.Inc
%define! Abstract Common\MAG3110Abstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%if (CPUfamily = "Kinetis")
#define %'ModuleName'_CPU_IS_LITTLE_ENDIAN 1 /* Cpu is little endian */
%else
#define %'ModuleName'_CPU_IS_LITTLE_ENDIAN 0 /* Cpu is big endian */
%endif

#define %'ModuleName'_DIE_TEMP_OFFSET %DieTempOffset /* offset to temperature reading as value on device is not calibrated */
%-
%if defined(Shell)
static uint8_t PrintStatus(const %@Shell@'ModuleName'%.StdIOType *io) {
  unsigned char buf[24];
  uint8_t val8;
  int8_t temperature;
  int16_t x, y, z;
  bool isOn;

  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"%'ModuleName'", (unsigned char*)"\r\n", io->stdOut);

  if (%'ModuleName'%.%GetSysMode(&val8)==ERR_OK) {
    if (val8==%'ModuleName'%.SYSMOD_STANDBY_BIT_MASK) {
      %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"STANDBY\r\n");
    } else if (val8==%'ModuleName'%.SYSMOD_ACTIVE_RAW_BIT_MASK) {
      %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"ACTIVE, RAW\r\n");
    } else if (val8==%'ModuleName'%.SYSMOD_ACTIVE_BIT_MASK) {
      %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"ACTIVE\r\n");
    } else {
      %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"UNKNOWN\r\n");
    }
  } else {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"FAILED\r\n");
  }
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  Sys Mode", buf, io->stdOut);

  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  X, Y, Z", (unsigned char*)"", io->stdOut);
  if (%'ModuleName'%.GetX(&x)!=ERR_OK) {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"FAILED", io->stdOut);
  } else {
    %@Shell@'ModuleName'%.SendNum16s(x, io->stdOut);
  }
  %@Shell@'ModuleName'%.SendStr((unsigned char*)" ", io->stdOut);
  if (%'ModuleName'%.GetY(&y)!=ERR_OK) {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"FAILED", io->stdOut);
  } else {
    %@Shell@'ModuleName'%.SendNum16s(y, io->stdOut);
  }
  %@Shell@'ModuleName'%.SendStr((unsigned char*)" ", io->stdOut);
  if (%'ModuleName'%.GetZ(&z)!=ERR_OK) {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"FAILED", io->stdOut);
  } else {
    %@Shell@'ModuleName'%.SendNum16s(z, io->stdOut);
  }
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);

  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  Offset", (unsigned char*)"", io->stdOut);
  %'ModuleName'%.%GetUserOffsetCorrection(&x, &y, &z);
  %@Shell@'ModuleName'%.SendNum16s(x, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)" ", io->stdOut);
  %@Shell@'ModuleName'%.SendNum16s(y, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)" ", io->stdOut);
  %@Shell@'ModuleName'%.SendNum16s(z, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);

  if (%'ModuleName'%.%GetDataRateMode(&val8)!=ERR_OK) {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"FAILED\r\n");
  } else {
    val8 >>= %'ModuleName'%.CTRL_REG_1_DR_BITS_POS; /* shift value into position */
    x = %'ModuleName'%.CTRL_REG_1_DR_START; /* start with base data rate */
    x >>= val8; /* shift base data rate to calculate the set rate */
    %@Utility@'ModuleName'%.Num16sToStr(buf, sizeof(buf), x);
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)" Hz\r\n");
  }
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  Data Rate", buf, io->stdOut);

  if (%'ModuleName'%.%GetOversamplingMode(&val8)!=ERR_OK) {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"FAILED\r\n");
  } else {
    val8 >>= %'ModuleName'%.CTRL_REG_1_OS_BITS_POS; /* shift value into position */
    x = %'ModuleName'%.CTRL_REG_1_OS_START; /* start with base data rate */
    x <<= val8; /* shift base data rate to calculate the set rate */
    %@Utility@'ModuleName'%.Num16sToStr(buf, sizeof(buf), x);
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)"x oversampling\r\n");
  }
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  Sampling", buf, io->stdOut);

  if (%'ModuleName'%.%GetFastReadMode(&isOn)!=ERR_OK) {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"FAILED\r\n");
  } else {
    if (isOn) {
      %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"on\r\n");
    } else {
      %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"off\r\n");
    }
  }
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  Fast Read", buf, io->stdOut);

  if (%'ModuleName'%.%GetTriggerImmediateMode(&isOn)!=ERR_OK) {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"FAILED\r\n");
  } else {
    if (isOn) {
      %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"immediate on\r\n");
    } else {
      %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"immediate off\r\n");
    }
  }
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  Trigger", buf, io->stdOut);

  if (%'ModuleName'%.%GetRawMode(&isOn)!=ERR_OK) {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"FAILED\r\n");
  } else {
    if (isOn) {
      %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"on\r\n");
    } else {
      %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"off\r\n");
    }
  }
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  Raw mode", buf, io->stdOut);

  if (%'ModuleName'%.%GetTemperature(&temperature)==ERR_OK) {
    %@Utility@'ModuleName'%.Num8sToStr(buf, sizeof(buf), temperature);
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)"°C (offset ");
    %@Utility@'ModuleName'%.strcatNum8s(buf, sizeof(buf), %'ModuleName'_DIE_TEMP_OFFSET);
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)"°C)\r\n");
  } else {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"FAILED\r\n");
  }
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  Temperature", buf, io->stdOut);

  if (%'ModuleName'%.%WhoAmI(&val8)==ERR_OK) {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"0x");
    %@Utility@'ModuleName'%.strcatNum8Hex(buf, sizeof(buf), val8);
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
  } else {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"FAILED\r\n");
  }
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  Who am I", buf, io->stdOut);

  return ERR_OK;
}

static uint8_t PrintHelp(const %@Shell@'ModuleName'%.StdIOType *io) {
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"%'ModuleName'", (unsigned char*)"Group of %'ModuleName' commands\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  help|status", (unsigned char*)"Print help or status information\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  enable|disable", (unsigned char*)"Enables or disables the sensor\r\n", io->stdOut);
  return ERR_OK;
}

%endif
%-
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetXYZ8
%ifdef GetXYZ8
%define! Parxyz
%define! RetVal
%include Common\MAG3110GetXYZ8.Inc
uint8_t %'ModuleName'%.%GetXYZ8(signed char *xyz)
{
  /* NOTE: this function assumes that FAST_READ *is* set, as it reads 3 bytes */
  static const uint8_t addr = %'ModuleName'%.OUT_X_MSB;

  return %@I2C@'ModuleName'%.ReadAddress(%'ModuleName'%.I2C_ADDR, (uint8_t*)&addr, sizeof(addr), (uint8_t*)xyz, 3);
}

%endif %- GetXYZ8
%-BW_METHOD_END GetXYZ8
%-*****************************************************************************************************
%-BW_METHOD_BEGIN GetXYZ16
%ifdef GetXYZ16
%define! Parxyz
%define! RetVal
%include Common\MAG3110GetRaw8XYZ.inc
uint8_t %'ModuleName'%.%GetXYZ16(int16_t *xyz)
{
  /* NOTE: this function assumes that FAST_READ is *not* set, as it reads 6 bytes */
  static const uint8_t addr = %'ModuleName'%.OUT_X_MSB;

  return %@I2C@'ModuleName'%.ReadAddress(%'ModuleName'%.I2C_ADDR, (uint8_t*)&addr, sizeof(addr), (uint8_t*)xyz, 6);
}
%endif %- GetXYZ16
%-BW_METHOD_END GetXYZ16

%-*****************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
%define! RetVal
%include Common\MAG3110Deinit.inc
uint8_t %'ModuleName'%.%Deinit(void)
{
  return ERR_OK; /* nothing to do */
}
%endif %-Deinit
%-BW_METHOD_END Deinit

%-*****************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%define! RetVal
%include Common\MAG3110Init.inc
uint8_t %'ModuleName'%.%Init(void)
{
  return ERR_OK;
}
%endif %-Init
%-BW_METHOD_END Init

%-************************************************************************************************************
%-BW_METHOD_BEGIN GetX
%ifdef GetX
%define! Parvalue
%define! RetVal
%include Common\MAG3110GetX.Inc
word %'ModuleName'%.%GetX(int16_t *value)
{
  union {
    uint8_t buf[2]; /* value from device is in big endian */
    int16_t be;
  } val;
  static const uint8_t addr = %'ModuleName'%.OUT_X_MSB;

  if(%@I2C@'ModuleName'%.ReadAddress(%'ModuleName'%.I2C_ADDR, (uint8_t*)&addr, sizeof(addr), &val.buf[0], sizeof(val.buf))!=ERR_OK) {
    return ERR_FAILED; /* failure */
  }
#if %'ModuleName'_CPU_IS_LITTLE_ENDIAN
  *value = (int16_t)((val.buf[0]<<8)|val.buf[1]); /* transform into LE value */
#else
  *value = val.be; /* already in BE */
#endif
  return ERR_OK;
}

%endif %- GetX
%-BW_METHOD_END GetX
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetY
%ifdef GetY
%define! Parvalue
%define! RetVal
%include Common\MAG3110GetY.Inc
word %'ModuleName'%.%GetY(int16_t *value)
{
  union {
    uint8_t buf[2]; /* value from device is in big endian */
    int16_t be;
  } val;
  static const uint8_t addr = %'ModuleName'%.OUT_Y_MSB;

  if (%@I2C@'ModuleName'%.ReadAddress(%'ModuleName'%.I2C_ADDR, (uint8_t*)&addr, sizeof(addr), &val.buf[0], sizeof(val.buf))!=ERR_OK) {
    return ERR_FAILED; /* failure */
  }
#if %'ModuleName'_CPU_IS_LITTLE_ENDIAN
  *value = (int16_t)((val.buf[0]<<8)|val.buf[1]); /* transform into LE value */
#else
  *value = val.be; /* already in BE */
#endif
  return ERR_OK;
}

%endif %- GetY
%-BW_METHOD_END GetY
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetZ
%ifdef GetZ
%define! Parvalue
%define! RetVal
%include Common\MAG3110GetZ.Inc
word %'ModuleName'%.%GetZ(int16_t *value)
{
  union {
    uint8_t buf[2]; /* value from device is in big endian */
    int16_t be;
  } val;
  static const uint8_t addr = %'ModuleName'%.OUT_Z_MSB;

  if (%@I2C@'ModuleName'%.ReadAddress(%'ModuleName'%.I2C_ADDR, (uint8_t*)&addr, sizeof(addr), &val.buf[0], sizeof(val.buf))!=ERR_OK) {
    return ERR_FAILED; /* failure */
  }
#if %'ModuleName'_CPU_IS_LITTLE_ENDIAN
  *value = (int16_t)((val.buf[0]<<8)|val.buf[1]); /* transform into LE value */
#else
  *value = val.be; /* already in BE */
#endif
  return ERR_OK;
}

%endif %- GetZ
%-BW_METHOD_END GetZ
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
%define! Parcmd
%define! Parhandled
%define! Pario
%define! RetVal
%include Common\MAG3110ParseCommand.Inc
byte %'ModuleName'%.%ParseCommand(const unsigned char *cmd, bool *handled, const %@Shell@'ModuleName'%.StdIOType *io)
{
  if (%@Utility@'ModuleName'%.strcmp((char*)cmd, %@Shell@'ModuleName'%.CMD_HELP)==0 || %@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' help")==0) {
    *handled = TRUE;
    return PrintHelp(io);
  } else if ((%@Utility@'ModuleName'%.strcmp((char*)cmd, %@Shell@'ModuleName'%.CMD_STATUS)==0) || (%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' status")==0)) {
    *handled = TRUE;
    return PrintStatus(io);
  } else if (%@Utility@'ModuleName'%.strcmp((char*)cmd, (char*)"%'ModuleName' enable")==0) {
    %'ModuleName'%.Enable();
    *handled = TRUE;
  } else if (%@Utility@'ModuleName'%.strcmp((char*)cmd, (char*)"%'ModuleName' disable")==0) {
    %'ModuleName'%.Disable();
    *handled = TRUE;
  }
  return ERR_OK;
}

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetFastReadMode
%ifdef SetFastReadMode
%define! Paron
%define! RetVal
%include Common\MAG3110SetFastReadMode.Inc
byte %'ModuleName'%.%SetFastReadMode(bool on)
{
  uint8_t val;

  if (%@I2C@'ModuleName'%.ReadByteAddress8(%'ModuleName'%.I2C_ADDR, %'ModuleName'%.CTRL_REG_1, &val)!=ERR_OK) {
    return ERR_FAILED;
  }
  if (on) {
    val |= %'ModuleName'%.CTRL_REG_1_FR_BIT_MASK; /* enable F_READ: Fast read mode, data format limited to single byte (auto increment counter will skip LSB) */
  } else {
    val &= ~%'ModuleName'%.CTRL_REG_1_FR_BIT_MASK; /* disable F_READ: Fast read mode, data format limited to single byte (auto increment counter will skip LSB) */
  }
  return %@I2C@'ModuleName'%.WriteByteAddress8(%'ModuleName'%.I2C_ADDR, %'ModuleName'%.CTRL_REG_1, val);
}

%endif %- SetFastReadMode
%-BW_METHOD_END SetFastReadMode
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetFastReadMode
%ifdef GetFastReadMode
%define! ParisOn
%define! RetVal
%include Common\MAG3110GetFastReadMode.Inc
byte %'ModuleName'%.%GetFastReadMode(bool *isOn)
{
  uint8_t val;

  if(%@I2C@'ModuleName'%.ReadByteAddress8(%'ModuleName'%.I2C_ADDR, %'ModuleName'%.CTRL_REG_1, &val)!=ERR_OK) {
    return ERR_FAILED;
  }
  *isOn = (bool)(val&%'ModuleName'%.CTRL_REG_1_FR_BIT_MASK);
  return ERR_OK;
}

%endif %- GetFastReadMode
%-BW_METHOD_END GetFastReadMode
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetTriggerImmediateMode
%ifdef SetTriggerImmediateMode
%define! Paron
%define! RetVal
%include Common\MAG3110SetTriggerImmediateMode.Inc
byte %'ModuleName'%.%SetTriggerImmediateMode(bool on)
{
  uint8_t val;

  if (%@I2C@'ModuleName'%.ReadByteAddress8(%'ModuleName'%.I2C_ADDR, %'ModuleName'%.CTRL_REG_1, &val)!=ERR_OK) {
    return ERR_FAILED;
  }
  if (on) {
    val |= %'ModuleName'%.CTRL_REG_1_TM_BIT_MASK; /* enable F_READ: Fast read mode, data format limited to single byte (auto increment counter will skip LSB) */
  } else {
    val &= ~%'ModuleName'%.CTRL_REG_1_TM_BIT_MASK; /* disable F_READ: Fast read mode, data format limited to single byte (auto increment counter will skip LSB) */
  }
  return %@I2C@'ModuleName'%.WriteByteAddress8(%'ModuleName'%.I2C_ADDR, %'ModuleName'%.CTRL_REG_1, val);
}

%endif %- SetTriggerImmediateMode
%-BW_METHOD_END SetTriggerImmediateMode
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetTriggerImmediateMode
%ifdef GetTriggerImmediateMode
%define! ParisOn
%define! RetVal
%include Common\MAG3110GetTriggerImmediateMode.Inc
byte %'ModuleName'%.%GetTriggerImmediateMode(bool *isOn)
{
  uint8_t val;

  if(%@I2C@'ModuleName'%.ReadByteAddress8(%'ModuleName'%.I2C_ADDR, %'ModuleName'%.CTRL_REG_1, &val)!=ERR_OK) {
    return ERR_FAILED;
  }
  *isOn = (bool)(val&%'ModuleName'%.CTRL_REG_1_TM_BIT_MASK);
  return ERR_OK;
}

%endif %- GetTriggerImmediateMode
%-BW_METHOD_END GetTriggerImmediateMode
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetRawMode
%ifdef SetRawMode
%define! Paron
%define! RetVal
%include Common\MAG3110SetRawMode.Inc
byte %'ModuleName'%.%SetRawMode(bool on)
{
  uint8_t val;

  if (%@I2C@'ModuleName'%.ReadByteAddress8(%'ModuleName'%.I2C_ADDR, %'ModuleName'%.CTRL_REG_2, &val)!=ERR_OK) {
    return ERR_FAILED;
  }
  if (on) {
    val |= %'ModuleName'%.CTRL_REG_2_RAW_BIT_MASK; /* enable RAW mode */
  } else {
    val &= ~%'ModuleName'%.CTRL_REG_2_RAW_BIT_MASK; /* disable RAW mode */
  }
  return %@I2C@'ModuleName'%.WriteByteAddress8(%'ModuleName'%.I2C_ADDR, %'ModuleName'%.CTRL_REG_2, val);
}

%endif %- SetRawMode
%-BW_METHOD_END SetRawMode
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetRawMode
%ifdef GetRawMode
%define! ParisOn
%define! RetVal
%include Common\MAG3110GetRawMode.Inc
byte %'ModuleName'%.%GetRawMode(bool *isOn)
{
  uint8_t val;

  if(%@I2C@'ModuleName'%.ReadByteAddress8(%'ModuleName'%.I2C_ADDR, %'ModuleName'%.CTRL_REG_2, &val)!=ERR_OK) {
    return ERR_FAILED;
  }
  *isOn = (bool)(val&%'ModuleName'%.CTRL_REG_2_RAW_BIT_MASK);
  return ERR_OK;
}

%endif %- GetRawMode
%-BW_METHOD_END GetRawMode
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetOversamplingMode
%ifdef SetOversamplingMode
%define! Parbits
%define! RetVal
%include Common\MAG3110SetOversamplingMode.Inc
byte %'ModuleName'%.%SetOversamplingMode(byte bits)
{
  uint8_t val;

  if (%@I2C@'ModuleName'%.ReadByteAddress8(%'ModuleName'%.I2C_ADDR, %'ModuleName'%.CTRL_REG_1, &val)!=ERR_OK) {
    return ERR_FAILED;
  }
  val |= (uint8_t)(bits & %'ModuleName'%.CTRL_REG_1_OS_FULL_BIT_MASK); /* making sure we use the right bits */
  return %@I2C@'ModuleName'%.WriteByteAddress8(%'ModuleName'%.I2C_ADDR, %'ModuleName'%.CTRL_REG_1, val);
}

%endif %- SetOversamplingMode
%-BW_METHOD_END SetOversamplingMode
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetOversamplingMode
%ifdef GetOversamplingMode
%define! Parbits
%define! RetVal
%include Common\MAG3110GetOversamplingMode.Inc
byte %'ModuleName'%.%GetOversamplingMode(byte *bits)
{
  uint8_t val;

  if(%@I2C@'ModuleName'%.ReadByteAddress8(%'ModuleName'%.I2C_ADDR, %'ModuleName'%.CTRL_REG_1, &val)!=ERR_OK) {
    return ERR_FAILED;
  }
  *bits = (uint8_t)(val & %'ModuleName'%.CTRL_REG_1_OS_FULL_BIT_MASK); /* making sure we use the right bits */
  return ERR_OK;
}

%endif %- GetOversamplingMode
%-BW_METHOD_END GetOversamplingMode
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetDataRateMode
%ifdef SetDataRateMode
%define! Parbits
%define! RetVal
%include Common\MAG3110SetDataRateMode.Inc
byte %'ModuleName'%.%SetDataRateMode(byte bits)
{
  uint8_t val;

  if (%@I2C@'ModuleName'%.ReadByteAddress8(%'ModuleName'%.I2C_ADDR, %'ModuleName'%.CTRL_REG_1, &val)!=ERR_OK) {
    return ERR_FAILED;
  }
  val |= (uint8_t)(bits & %'ModuleName'%.CTRL_REG_1_DR_FULL_BIT_MASK); /* making sure we use the right bits */
  return %@I2C@'ModuleName'%.WriteByteAddress8(%'ModuleName'%.I2C_ADDR, %'ModuleName'%.CTRL_REG_1, val);
}

%endif %- SetDataRateMode
%-BW_METHOD_END SetDataRateMode
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetDataRateMode
%ifdef GetDataRateMode
%define! Parbits
%define! RetVal
%include Common\MAG3110GetDataRateMode.Inc
byte %'ModuleName'%.%GetDataRateMode(byte *bits)
{
  uint8_t val;

  if(%@I2C@'ModuleName'%.ReadByteAddress8(%'ModuleName'%.I2C_ADDR, %'ModuleName'%.CTRL_REG_1, &val)!=ERR_OK) {
    return ERR_FAILED;
  }
  *bits = (uint8_t)(val & %'ModuleName'%.CTRL_REG_1_DR_FULL_BIT_MASK); /* making sure we use the right bits */
  return ERR_OK;
}

%endif %- GetDataRateMode
%-BW_METHOD_END GetDataRateMode
%-************************************************************************************************************
%-BW_METHOD_BEGIN Enable
%ifdef Enable
%define! RetVal
%include Common\MAG3110Enable.Inc
byte %'ModuleName'%.%Enable(void)
{
  uint8_t val, res;

  res = %@I2C@'ModuleName'%.ReadByteAddress8(%'ModuleName'%.I2C_ADDR, %'ModuleName'%.CTRL_REG_1, &val);
  if (res!=ERR_OK) {
    return res;
  }
  val |= %'ModuleName'%.CTRL_REG_1_AC_BIT_MASK; /* enable device */
  return %@I2C@'ModuleName'%.WriteByteAddress8(%'ModuleName'%.I2C_ADDR, %'ModuleName'%.CTRL_REG_1, val);
}

%endif %- Enable
%-BW_METHOD_END Enable
%-************************************************************************************************************
%-BW_METHOD_BEGIN Disable
%ifdef Disable
%define! RetVal
%include Common\MAG3110Disable.Inc
byte %'ModuleName'%.%Disable(void)
{
  uint8_t val, res;

  res = %@I2C@'ModuleName'%.ReadByteAddress8(%'ModuleName'%.I2C_ADDR, %'ModuleName'%.CTRL_REG_1, &val);
  if (res!=ERR_OK) {
    return res;
  }
  val &= ~%'ModuleName'%.CTRL_REG_1_AC_BIT_MASK; /* disable device */
  return %@I2C@'ModuleName'%.WriteByteAddress8(%'ModuleName'%.I2C_ADDR, %'ModuleName'%.CTRL_REG_1, val);
}

%endif %- Disable
%-BW_METHOD_END Disable
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetTemperature
%ifdef GetTemperature
%define! Partemperature
%define! RetVal
%include Common\MAG3110GetTemperature.Inc
byte %'ModuleName'%.%GetTemperature(signed char *temperature)
{
  int8_t temp;

  if (%@I2C@'ModuleName'%.ReadByteAddress8(%'ModuleName'%.I2C_ADDR, %'ModuleName'%.DIE_TEMP, (uint8_t*)&temp) != ERR_OK) {
    return ERR_FAILED;
  }
  *temperature = (int8_t)(temp+%'ModuleName'_DIE_TEMP_OFFSET);
  return ERR_OK;
}

%endif %- GetTemperature
%-BW_METHOD_END GetTemperature
%-************************************************************************************************************
%-BW_METHOD_BEGIN WhoAmI
%ifdef WhoAmI
%define! Parvalue
%define! RetVal
%include Common\MAG3110WhoAmI.Inc
byte %'ModuleName'%.%WhoAmI(byte *value)
{
  return %@I2C@'ModuleName'%.ReadByteAddress8(%'ModuleName'%.I2C_ADDR, %'ModuleName'%.WHO_AM_I, value);
}

%endif %- WhoAmI
%-BW_METHOD_END WhoAmI
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetSysMode
%ifdef GetSysMode
%define! Parmode
%define! RetVal
%include Common\MAG3110GetSysMode.Inc
byte %'ModuleName'%.%GetSysMode(byte *mode)
{
  return %@I2C@'ModuleName'%.ReadByteAddress8(%'ModuleName'%.I2C_ADDR, %'ModuleName'%.SYSMOD, mode);
}

%endif %- GetSysMode
%-BW_METHOD_END GetSysMode
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetSysMode
%ifdef SetSysMode
%define! Parmode
%define! RetVal
%include Common\MAG3110SetSysMode.Inc
byte %'ModuleName'%.%SetSysMode(byte mode)
{
  return %@I2C@'ModuleName'%.WriteByteAddress8(%'ModuleName'%.I2C_ADDR, %'ModuleName'%.SYSMOD, mode);
}

%endif %- SetSysMode
%-BW_METHOD_END SetSysMode
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG Read16bitBEValue
%define! Paraddr
%define! Parvalue
%define! RetVal
%include Common\GeneralInternal.inc (Read16bitBEValue)
byte %'ModuleName'%.Read16bitBEValue(byte addr, word *value)
{
  union {
    uint8_t buf[2]; /* value from device is in big endian */
    uint16_t be;
  } val;
  uint8_t res;

  res = %@I2C@'ModuleName'%.ReadAddress(%'ModuleName'%.I2C_ADDR, &addr, sizeof(addr), &val.buf[0], sizeof(val.buf));
  if(res!=ERR_OK) {
    return res; /* failure */
  }
#if %'ModuleName'_CPU_IS_LITTLE_ENDIAN
  *value = (uint16_t)((val.buf[0]<<8)|val.buf[1]); /* transform into LE value */
#else
  *value = val.be; /* already in BE */
#endif
  return ERR_OK;
}

%-INTERNAL_METHOD_END Read16bitBEValue
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG Write16bitBEValue
%define! Paraddr
%define! Parvalue
%define! RetVal
%include Common\GeneralInternal.inc (Write16bitBEValue)
byte %'ModuleName'%.Write16bitBEValue(byte addr, word value)
{
  union {
    uint8_t buf[2]; /* value on device is in big endian */
    uint16_t be;
  } val;

#if %'ModuleName'_CPU_IS_LITTLE_ENDIAN
  val.buf[0] = (uint8_t)(value);
  val.buf[1] = (uint8_t)(value>>8);
#else
  val.be = val; /* already in BE */
#endif
  return %@I2C@'ModuleName'%.WriteAddress(%'ModuleName'%.I2C_ADDR, &addr, sizeof(addr), &val.buf[0], sizeof(val.buf));
}

%-INTERNAL_METHOD_END Write16bitBEValue
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetUserOffsetCorrection
%ifdef GetUserOffsetCorrection
%define! Parx
%define! Pary
%define! Parz
%define! RetVal
%include Common\MAG3110GetUserOffsetCorrection.Inc
byte %'ModuleName'%.%GetUserOffsetCorrection(int16_t *x, int16_t *y, int16_t *z)
{
  uint8_t res;

  res = %'ModuleName'%.Read16bitBEValue(%'ModuleName'%.OFF_X_MSB, (uint16_t*)x);
  if(res!=ERR_OK) {
    return res; /* failure */
  }
  res = %'ModuleName'%.Read16bitBEValue(%'ModuleName'%.OFF_Y_MSB, (uint16_t*)y);
  if(res!=ERR_OK) {
    return res; /* failure */
  }
  res = %'ModuleName'%.Read16bitBEValue(%'ModuleName'%.OFF_Z_MSB, (uint16_t*)z);
  if(res!=ERR_OK) {
    return res; /* failure */
  }
  return ERR_OK;
}

%endif %- GetUserOffsetCorrection
%-BW_METHOD_END GetUserOffsetCorrection
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetUserOffsetCorrection
%ifdef SetUserOffsetCorrection
%define! Parx
%define! Pary
%define! Parz
%define! RetVal
%include Common\MAG3110SetUserOffsetCorrection.Inc
byte %'ModuleName'%.%SetUserOffsetCorrection(int16_t x, int16_t y, int16_t z)
{
  uint8_t res;

  res = %'ModuleName'%.Write16bitBEValue(%'ModuleName'%.OFF_X_MSB, (uint16_t)(x<<1)); /* bit 0 is always zero */
  if(res!=ERR_OK) {
    return res; /* failure */
  }
  res = %'ModuleName'%.Write16bitBEValue(%'ModuleName'%.OFF_Y_MSB, (uint16_t)(y<<1)); /* bit 0 is always zero */
  if(res!=ERR_OK) {
    return res; /* failure */
  }
  res = %'ModuleName'%.Write16bitBEValue(%'ModuleName'%.OFF_Z_MSB, (uint16_t)(z<<1)); /* bit 0 is always zero */
  if(res!=ERR_OK) {
    return res; /* failure */
  }
  return ERR_OK;
}

%endif %- SetUserOffsetCorrection
%-BW_METHOD_END SetUserOffsetCorrection
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteReg
%ifdef WriteReg
%define! Parreg
%define! Parval
%define! RetVal
%include Common\MAG3110WriteReg.Inc
byte %'ModuleName'%.%WriteReg(byte reg, byte val)
{
  return %@I2C@'ModuleName'%.WriteByteAddress8(%'ModuleName'%.I2C_ADDR, %'ModuleName'%.SYSMOD, val);
}

%endif %- WriteReg
%-BW_METHOD_END WriteReg
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadReg
%ifdef ReadReg
%define! Paraddr
%define! Parval
%define! RetVal
%include Common\MAG3110ReadReg.Inc
byte %'ModuleName'%.%ReadReg(byte addr, byte *val)
{
  return %@I2C@'ModuleName'%.ReadByteAddress8(%'ModuleName'%.I2C_ADDR, addr, val);
}

%endif %- ReadReg
%-BW_METHOD_END ReadReg
%-************************************************************************************************************
%-BW_METHOD_BEGIN MagneticSensorReset
%ifdef MagneticSensorReset
%define! RetVal
%include Common\MAG3110MagneticSensorReset.Inc
byte %'ModuleName'%.%MagneticSensorReset(void)
{
  uint8_t val;

  if (%@I2C@'ModuleName'%.ReadByteAddress8(%'ModuleName'%.I2C_ADDR, %'ModuleName'%.CTRL_REG_2, &val)!=ERR_OK) {
    return ERR_FAILED;
  }
  val |= %'ModuleName'%.CTRL_REG_2_MAG_RST_BIT_MASK; /* set one shot reset bit */
  return %@I2C@'ModuleName'%.WriteByteAddress8(%'ModuleName'%.I2C_ADDR, %'ModuleName'%.CTRL_REG_2, val);
}

%endif %- MagneticSensorReset
%-BW_METHOD_END MagneticSensorReset
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
  /* Write code here ... */
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This component is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
