%-Driver generated by the Bean Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END 
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Bean Wizard
%- If you change these lines, Bean Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    02.07.2008
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_ShiftRightAndFill Moves the content of a string to the right and fills the space on the left side with a pattern
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\UtilitySettings.Inc
%define! Abstract Common\UtilityAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"
#include <string.h>
#include <stddef.h> /* for size_t */
%include sw\CommonSupport.prg
%-
%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
#include <stddef.h>
%-BW_CUSTOM_USERTYPE_END


%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcpy
%ifdef strcpy
void %'ModuleName'%.%strcpy(byte *dst, size_t dstSize, const unsigned char *src);
%define! Pardst
%define! PardstSize
%define! Parsrc
%include Common\Utilitystrcpy.Inc

%endif %- strcpy
%-BW_METHOD_END strcpy
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcat
%ifdef strcat
void %'ModuleName'%.%strcat(byte *dst, size_t dstSize, const unsigned char *src);
%define! Pardst
%define! PardstSize
%define! Parsrc
%include Common\Utilitystrcat.Inc

%endif %- strcat
%-BW_METHOD_END strcat
%-************************************************************************************************************
%-BW_METHOD_BEGIN Num16sToStr
%ifdef Num16sToStr
void %'ModuleName'%.%Num16sToStr(byte *dst, size_t dstSize, int16_t val);
%define! Pardst
%define! PardstSize
%define! Parval
%include Common\UtilityNum16sToStr.Inc

%endif %- Num16sToStr
%-BW_METHOD_END Num16sToStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN Num16sToStrFormatted
%ifdef Num16sToStrFormatted
void %'ModuleName'%.%Num16sToStrFormatted(byte *dst, size_t dstSize, int16_t val, char fill, byte nofFill);
%define! Pardst
%define! PardstSize
%define! Parval
%define! Parfill
%define! ParnofFill
%include Common\UtilityNum16sToStrFormatted.Inc

%endif %- Num16sToStrFormatted
%-BW_METHOD_END Num16sToStrFormatted
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcatNum16s
%ifdef strcatNum16s
void %'ModuleName'%.%strcatNum16s(byte *dst, size_t dstSize, int16_t val);
%define! Pardst
%define! PardstSize
%define! Parval
%include Common\UtilitystrcatNum16s.Inc

%endif %- strcatNum16s
%-BW_METHOD_END strcatNum16s
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcatNum16sFormatted
%ifdef strcatNum16sFormatted
void %'ModuleName'%.%strcatNum16sFormatted(byte *dst, size_t dstSize, int16_t val, char fill, byte nofFill);
%define! Pardst
%define! PardstSize
%define! Parval
%define! Parfill
%define! ParnofFill
%include Common\UtilitystrcatNum16sFormatted.Inc

%endif %- strcatNum16sFormatted
%-BW_METHOD_END strcatNum16sFormatted
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcatNum8Hex
%ifdef strcatNum8Hex
void %'ModuleName'%.%strcatNum8Hex(byte *dst, size_t dstSize, byte num);
%define! Pardst
%define! PardstSize
%define! Parnum
%include Common\UtilitystrcatNum8Hex.Inc

%endif %- strcatNum8Hex
%-BW_METHOD_END strcatNum8Hex
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcatNum16Hex
%ifdef strcatNum16Hex
void %'ModuleName'%.%strcatNum16Hex(byte *dst, size_t dstSize, word num);
%define! Pardst
%define! PardstSize
%define! Parnum
%include Common\UtilitystrcatNum16Hex.Inc

%endif %- strcatNum16Hex
%-BW_METHOD_END strcatNum16Hex
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcatNum32s
%ifdef strcatNum32s
void %'ModuleName'%.%strcatNum32s(byte *dst, size_t dstSize, long val);
%define! Pardst
%define! PardstSize
%define! Parval
%include Common\UtilitystrcatNum32s.Inc

%endif %- strcatNum32s
%-BW_METHOD_END strcatNum32s
%-************************************************************************************************************
%-BW_METHOD_BEGIN Num32sToStr
%ifdef Num32sToStr
void %'ModuleName'%.%Num32sToStr(byte *dst, size_t dstSize, long val);
%define! Pardst
%define! PardstSize
%define! Parval
%include Common\UtilityNum32sToStr.Inc

%endif %- Num32sToStr
%-BW_METHOD_END Num32sToStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcatNum32Hex
%ifdef strcatNum32Hex
void %'ModuleName'%.%strcatNum32Hex(byte *dst, size_t dstSize, dword num);
%define! Pardst
%define! PardstSize
%define! Parnum
%include Common\UtilitystrcatNum32Hex.Inc

%endif %- strcatNum32Hex
%-BW_METHOD_END strcatNum32Hex
%-************************************************************************************************************
%-BW_METHOD_BEGIN IsLeapYear
%ifdef IsLeapYear
bool %'ModuleName'%.%IsLeapYear(word year);
%define! Paryear
%define! RetVal
%include Common\UtilityIsLeapYear.Inc

%endif %- IsLeapYear
%-BW_METHOD_END IsLeapYear
%-************************************************************************************************************
%-BW_METHOD_BEGIN WeekDay
%ifdef WeekDay
byte %'ModuleName'%.%WeekDay(word year, byte month, byte day);
%define! Paryear
%define! Parmonth
%define! Parday
%define! RetVal
%include Common\UtilityWeekDay.Inc

%endif %- WeekDay
%-BW_METHOD_END WeekDay
%-************************************************************************************************************
%-BW_METHOD_BEGIN chcat
%ifdef chcat
void %'ModuleName'%.%chcat(byte *dst, size_t dstSize, byte ch);
%define! Pardst
%define! PardstSize
%define! Parch
%include Common\Utilitychcat.Inc

%endif %- chcat
%-BW_METHOD_END chcat
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcatNum32u
%ifdef strcatNum32u
void %'ModuleName'%.%strcatNum32u(byte *dst, size_t dstSize, dword val);
%define! Pardst
%define! PardstSize
%define! Parval
%include Common\UtilitystrcatNum32u.Inc

%endif %- strcatNum32u
%-BW_METHOD_END strcatNum32u
%-************************************************************************************************************
%-BW_METHOD_BEGIN Num32uToStr
%ifdef Num32uToStr
void %'ModuleName'%.%Num32uToStr(byte *dst, size_t dstSize, dword val);
%define! Pardst
%define! PardstSize
%define! Parval
%include Common\UtilityNum32uToStr.Inc

%endif %- Num32uToStr
%-BW_METHOD_END Num32uToStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcatNum32uFormatted
%ifdef strcatNum32uFormatted
void %'ModuleName'%.%strcatNum32uFormatted(byte *dst, size_t dstSize, dword val, char fill, byte nofFill);
%define! Pardst
%define! PardstSize
%define! Parval
%define! Parfill
%define! ParnofFill
%include Common\UtilitystrcatNum32uFormatted.Inc

%endif %- strcatNum32uFormatted
%-BW_METHOD_END strcatNum32uFormatted
%-************************************************************************************************************
%-BW_METHOD_BEGIN Num32uToStrFormatted
%ifdef Num32uToStrFormatted
void %'ModuleName'%.%Num32uToStrFormatted(byte *dst, size_t dstSize, dword val, char fill, byte nofFill);
%define! Pardst
%define! PardstSize
%define! Parval
%define! Parfill
%define! ParnofFill
%include Common\UtilityNum32uToStrFormatted.Inc

%endif %- Num32uToStrFormatted
%-BW_METHOD_END Num32uToStrFormatted
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcatNum24Hex
%ifdef strcatNum24Hex
void %'ModuleName'%.%strcatNum24Hex(byte *dst, size_t dstSize, dword num);
%define! Pardst
%define! PardstSize
%define! Parnum
%include Common\UtilitystrcatNum24Hex.Inc

%endif %- strcatNum24Hex
%-BW_METHOD_END strcatNum24Hex
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadEscapedName
%ifdef ReadEscapedName
byte %'ModuleName'%.%ReadEscapedName(const unsigned char *filename, byte *destname, size_t maxlen, size_t *lenRead, size_t *lenWritten, const char *terminators);
%define! Parfilename
%define! Pardestname
%define! Parmaxlen
%define! ParlenRead
%define! ParfileName
%define! ParlenWritten
%define! Parterminators
%define! RetVal
%include Common\UtilityReadEscapedName.Inc

%endif %- ReadEscapedName
%-BW_METHOD_END ReadEscapedName
%-************************************************************************************************************
%-BW_METHOD_BEGIN xatoi
%ifdef xatoi
byte %'ModuleName'%.%xatoi(const unsigned char **str, int32_t *res);
%define! Parstr
%define! Parres
%define! RetVal
%include Common\Utilityxatoi.Inc

%endif %- xatoi
%-BW_METHOD_END xatoi
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanDate
%ifdef ScanDate
byte %'ModuleName'%.%ScanDate(const unsigned char **str, byte *day, byte *month, word *year);
%define! Parstr
%define! Parday
%define! Parmonth
%define! Paryear
%define! RetVal
%include Common\UtilityScanDate.Inc

%endif %- ScanDate
%-BW_METHOD_END ScanDate
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanTime
%ifdef ScanTime
byte %'ModuleName'%.%ScanTime(const unsigned char **str, byte *hour, byte *minute, byte *second, byte *hSecond);
%define! Parstr
%define! Parhour
%define! Parminute
%define! Parsecond
%define! ParhSecond
%define! RetVal
%include Common\UtilityScanTime.Inc

%endif %- ScanTime
%-BW_METHOD_END ScanTime
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanDecimal16uNumber
%ifdef ScanDecimal16uNumber
byte %'ModuleName'%.%ScanDecimal16uNumber(const unsigned char **str, word *val);
%define! Parstr
%define! Parval
%define! RetVal
%include Common\UtilityScanDecimal16uNumber.Inc

%endif %- ScanDecimal16uNumber
%-BW_METHOD_END ScanDecimal16uNumber
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanDecimal8uNumber
%ifdef ScanDecimal8uNumber
byte %'ModuleName'%.%ScanDecimal8uNumber(const unsigned char **str, byte *val);
%define! Parstr
%define! Parval
%define! RetVal
%include Common\UtilityScanDecimal8uNumber.Inc

%endif %- ScanDecimal8uNumber
%-BW_METHOD_END ScanDecimal8uNumber
%-************************************************************************************************************
%-BW_METHOD_BEGIN Num16uToStr
%ifdef Num16uToStr
void %'ModuleName'%.%Num16uToStr(byte *dst, size_t dstSize, word val);
%define! Pardst
%define! PardstSize
%define! Parval
%include Common\UtilityNum16uToStr.Inc

%endif %- Num16uToStr
%-BW_METHOD_END Num16uToStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN Num8sToStr
%ifdef Num8sToStr
void %'ModuleName'%.%Num8sToStr(byte *dst, size_t dstSize, signed char val);
%define! Pardst
%define! PardstSize
%define! Parval
%include Common\UtilityNum8sToStr.Inc

%endif %- Num8sToStr
%-BW_METHOD_END Num8sToStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN Num8uToStr
%ifdef Num8uToStr
void %'ModuleName'%.%Num8uToStr(byte *dst, size_t dstSize, byte val);
%define! Pardst
%define! PardstSize
%define! Parval
%include Common\UtilityNum8uToStr.Inc

%endif %- Num8uToStr
%-BW_METHOD_END Num8uToStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN Num16uToStrFormatted
%ifdef Num16uToStrFormatted
void %'ModuleName'%.%Num16uToStrFormatted(byte *dst, size_t dstSize, word val, char fill, byte nofFill);
%define! Pardst
%define! PardstSize
%define! Parval
%define! Parfill
%define! ParnofFill
%include Common\UtilityNum16uToStrFormatted.Inc

%endif %- Num16uToStrFormatted
%-BW_METHOD_END Num16uToStrFormatted
%-************************************************************************************************************
%-BW_METHOD_BEGIN Num32sToStrFormatted
%ifdef Num32sToStrFormatted
void %'ModuleName'%.%Num32sToStrFormatted(byte *dst, size_t dstSize, long val, char fill, byte nofFill);
%define! Pardst
%define! PardstSize
%define! Parval
%define! Parfill
%define! ParnofFill
%include Common\UtilityNum32sToStrFormatted.Inc

%endif %- Num32sToStrFormatted
%-BW_METHOD_END Num32sToStrFormatted
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcatNum16u
%ifdef strcatNum16u
void %'ModuleName'%.%strcatNum16u(byte *dst, size_t dstSize, word val);
%define! Pardst
%define! PardstSize
%define! Parval
%include Common\UtilitystrcatNum16u.Inc

%endif %- strcatNum16u
%-BW_METHOD_END strcatNum16u
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcatNum16uFormatted
%ifdef strcatNum16uFormatted
void %'ModuleName'%.%strcatNum16uFormatted(byte *dst, size_t dstSize, word val, char fill, byte nofFill);
%define! Pardst
%define! PardstSize
%define! Parval
%define! Parfill
%define! ParnofFill
%include Common\UtilitystrcatNum16uFormatted.Inc

%endif %- strcatNum16uFormatted
%-BW_METHOD_END strcatNum16uFormatted
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcatNum32sFormatted
%ifdef strcatNum32sFormatted
void %'ModuleName'%.%strcatNum32sFormatted(byte *dst, size_t dstSize, long val, char fill, byte nofFill);
%define! Pardst
%define! PardstSize
%define! Parval
%define! Parfill
%define! ParnofFill
%include Common\UtilitystrcatNum32sFormatted.Inc

%endif %- strcatNum32sFormatted
%-BW_METHOD_END strcatNum32sFormatted
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanDecimal32uNumber
%ifdef ScanDecimal32uNumber
byte %'ModuleName'%.%ScanDecimal32uNumber(const unsigned char **str, uint32_t *val);
%define! Parstr
%define! Parval
%define! RetVal
%include Common\UtilityScanDecimal32uNumber.Inc

%endif %- ScanDecimal32uNumber
%-BW_METHOD_END ScanDecimal32uNumber
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcatNum8u
%ifdef strcatNum8u
void %'ModuleName'%.%strcatNum8u(byte *dst, size_t dstSize, byte val);
%define! Pardst
%define! PardstSize
%define! Parval
%include Common\UtilitystrcatNum8u.Inc

%endif %- strcatNum8u
%-BW_METHOD_END strcatNum8u
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcatNum8s
%ifdef strcatNum8s
void %'ModuleName'%.%strcatNum8s(byte *dst, size_t dstSize, signed char val);
%define! Pardst
%define! PardstSize
%define! Parval
%include Common\UtilitystrcatNum8s.Inc

%endif %- strcatNum8s
%-BW_METHOD_END strcatNum8s
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcmp
%ifdef strcmp
#define %'ModuleName'%.%strcmp(str1, str2) \
  strcmp(str1, str2)

%define! Parstr1
%define! Parstr2
%define! RetVal
%include Common\Utilitystrcmp.Inc

%endif %- strcmp
%-BW_METHOD_END strcmp
%-************************************************************************************************************
%-BW_METHOD_BEGIN strncmp
%ifdef strncmp
#define %'ModuleName'%.%strncmp(str1, str2, size) \
  strncmp(str1, str2, size)

%define! Parstr1
%define! Parstr2
%define! Parsize
%define! RetVal
%include Common\Utilitystrncmp.Inc

%endif %- strncmp
%-BW_METHOD_END strncmp
%-************************************************************************************************************
%-BW_METHOD_BEGIN strlen
%ifdef strlen
#define %'ModuleName'%.%strlen(str) \
  strlen(str)

%define! Parstr
%define! RetVal
%include Common\Utilitystrlen.Inc

%endif %- strlen
%-BW_METHOD_END strlen
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanHex32uNumber
%ifdef ScanHex32uNumber
byte %'ModuleName'%.%ScanHex32uNumber(const unsigned char **str, uint32_t *val);
%define! Parstr
%define! Parval
%define! RetVal
%include Common\UtilityScanHex32uNumber.Inc

%endif %- ScanHex32uNumber
%-BW_METHOD_END ScanHex32uNumber
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanHex16uNumber
%ifdef ScanHex16uNumber
byte %'ModuleName'%.%ScanHex16uNumber(const unsigned char **str, word *val);
%define! Parstr
%define! Parval
%define! RetVal
%include Common\UtilityScanHex16uNumber.Inc

%endif %- ScanHex16uNumber
%-BW_METHOD_END ScanHex16uNumber
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanHex8uNumber
%ifdef ScanHex8uNumber
byte %'ModuleName'%.%ScanHex8uNumber(const unsigned char **str, byte *val);
%define! Parstr
%define! Parval
%define! RetVal
%include Common\UtilityScanHex8uNumber.Inc

%endif %- ScanHex8uNumber
%-BW_METHOD_END ScanHex8uNumber
%-************************************************************************************************************
%-BW_METHOD_BEGIN strtailcmp
%ifdef strtailcmp
byte %'ModuleName'%.%strtailcmp(byte *str, byte *tail);
%define! Parstr
%define! Partail
%define! RetVal
%include Common\Utilitystrtailcmp.Inc

%endif %- strtailcmp
%-BW_METHOD_END strtailcmp
%-************************************************************************************************************
%-BW_METHOD_BEGIN strCutTail
%ifdef strCutTail
byte %'ModuleName'%.%strCutTail(byte *str, byte *tail);
%define! Parstr
%define! Partail
%define! RetVal
%include Common\UtilitystrCutTail.Inc

%endif %- strCutTail
%-BW_METHOD_END strCutTail
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanHex8uNumberNoPrefix
%ifdef ScanHex8uNumberNoPrefix
byte %'ModuleName'%.%ScanHex8uNumberNoPrefix(const unsigned char **str, byte *val);
%define! Parstr
%define! Parval
%define! RetVal
%include Common\UtilityScanHex8uNumberNoPrefix.Inc

%endif %- ScanHex8uNumberNoPrefix
%-BW_METHOD_END ScanHex8uNumberNoPrefix
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcatNum32sDotValue100
%ifdef strcatNum32sDotValue100
void %'ModuleName'%.%strcatNum32sDotValue100(byte *dst, size_t dstSize, long num);
%define! Pardst
%define! PardstSize
%define! Parnum
%include Common\UtilitystrcatNum32sDotValue100.Inc

%endif %- strcatNum32sDotValue100
%-BW_METHOD_END strcatNum32sDotValue100
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanDecimal8sNumber
%ifdef ScanDecimal8sNumber
byte %'ModuleName'%.%ScanDecimal8sNumber(const unsigned char **str, signed char *val);
%define! Parstr
%define! Parval
%define! RetVal
%include Common\UtilityScanDecimal8sNumber.Inc

%endif %- ScanDecimal8sNumber
%-BW_METHOD_END ScanDecimal8sNumber
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanDecimal16sNumber
%ifdef ScanDecimal16sNumber
byte %'ModuleName'%.%ScanDecimal16sNumber(const unsigned char **str, int16_t *val);
%define! Parstr
%define! Parval
%define! RetVal
%include Common\UtilityScanDecimal16sNumber.Inc

%endif %- ScanDecimal16sNumber
%-BW_METHOD_END ScanDecimal16sNumber
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanDecimal32sNumber
%ifdef ScanDecimal32sNumber
byte %'ModuleName'%.%ScanDecimal32sNumber(const unsigned char **str, uint32_t *val);
%define! Parstr
%define! Parval
%define! RetVal
%include Common\UtilityScanDecimal32sNumber.Inc

%endif %- ScanDecimal32sNumber
%-BW_METHOD_END ScanDecimal32sNumber
%-************************************************************************************************************
%-BW_METHOD_BEGIN strFind
%ifdef strFind
int16_t %'ModuleName'%.%strFind(byte *str, byte *subStr);
%define! Parstr
%define! ParsubStr
%define! RetVal
%include Common\UtilitystrFind.Inc

%endif %- strFind
%-BW_METHOD_END strFind
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\UtilitySettings.Inc
%define! Abstract Common\UtilityAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%-
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-UNLOCKED
/* Internal method prototypes */
%-INTERNAL_LOC_METHOD_BEG ShiftRightAndFill
static void ShiftRightAndFill(byte *dst, byte fill, byte nofFill);
%-INTERNAL_LOC_METHOD_END ShiftRightAndFill
%-

%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcpy
%ifdef strcpy
%define! Pardst
%define! PardstSize
%define! Parsrc
%include Common\Utilitystrcpy.Inc
/*!
  \brief copy the string src into dst. It performs the same task as strncpy, except
     - always terminates the result string.
     - does not zero out the remaining part in dst.
     Note: dstSize is the size of dst INCLUDING zero byte.
     Precondition: src, dst != NULL
  \param[in,out] dst Start of buffer, where to append the number string
  \param[in] dstSize The size of the buffer, including the zero byte
  \param[in] src The source string to copy
*/
void %'ModuleName'%.%strcpy(byte *dst, size_t dstSize, const unsigned char *src)
{
  dstSize--; /* for zero byte */
  while (dstSize > 0 && *src != '\0') {
    *dst++ = *src++;
    dstSize--;
  }
  *dst = '\0';
}

%endif %- strcpy
%-BW_METHOD_END strcpy
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcat
%ifdef strcat
%define! Pardst
%define! PardstSize
%define! Parsrc
%include Common\Utilitystrcat.Inc
/*!
  \brief Concat the string src into dst. Always terminates the result string.
     Note: count is the size of dst INCLUDING zero byte.
     Precondition: src, dst != NULL
  \param[in,out] dst Start of buffer, where to append the number string
  \param[in] dstSize The size of the buffer, including the zero byte
  \param[in] src The source string to add
  */
void %'ModuleName'%.%strcat(byte *dst, size_t dstSize, const unsigned char *src)
{
  dstSize--; /* for zero byte */
  /* point to the end of the source */
  while (dstSize > 0 && *dst != '\0') {
    dst++;
    dstSize--;
  }
  /* copy the src in the destination */
  while (dstSize > 0 && *src != '\0') {
    *dst++ = *src++;
    dstSize--;
  }
  /* terminate the string */
  *dst = '\0';
}

%endif %- strcat
%-BW_METHOD_END strcat
%-************************************************************************************************************
%-BW_METHOD_BEGIN chcat
%ifdef chcat
%define! Pardst
%define! PardstSize
%define! Parch
%include Common\Utilitychcat.Inc
void %'ModuleName'%.%chcat(byte *dst, size_t dstSize, byte ch)
{
  dstSize--; /* for zero byte */
  /* point to the end of the source */
  while (dstSize > 0 && *dst != '\0') {
    dst++;
    dstSize--;
  }
  /* copy the ch in the destination */
  if (dstSize > 0) {
    *dst++ = ch;
  }
  /* terminate the string */
  *dst = '\0';
}

%endif %- chcat
%-BW_METHOD_END chcat
%-************************************************************************************************************
%-BW_METHOD_BEGIN Num8uToStr
%ifdef Num8uToStr
%define! Pardst
%define! PardstSize
%define! Parval
%include Common\UtilityNum8uToStr.Inc
/*!
  \brief Converts an 8bit unsigned number into a string.
  \param[in,out] dst String buffer to store the number.
  \param[in] dstSize Size of the destination buffer in bytes.
  \param[in] val 8bit unsigned number to convert.
 */
void %'ModuleName'%.%Num8uToStr(byte *dst, size_t dstSize, byte val)
{
  %'ModuleName'%.Num16uToStr(dst, dstSize, (uint16_t)val);
}

%endif %- Num8uToStr
%-BW_METHOD_END Num8uToStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN Num8sToStr
%ifdef Num8sToStr
%define! Pardst
%define! PardstSize
%define! Parval
%include Common\UtilityNum8sToStr.Inc
/*!
  \brief Converts an 8bit signed number into a string.
  \param[in,out] dst String buffer to store the number.
  \param[in] dstSize Size of the destination buffer in bytes.
  \param[in] val 8bit signed number to convert.
 */
void %'ModuleName'%.%Num8sToStr(byte *dst, size_t dstSize, signed char val)
{
  %'ModuleName'%.Num16sToStr(dst, dstSize, (int16_t)val);
}

%endif %- Num8sToStr
%-BW_METHOD_END Num8sToStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN Num16uToStr
%ifdef Num16uToStr
%define! Pardst
%define! PardstSize
%define! Parval
%include Common\UtilityNum16uToStr.Inc
/*!
  \brief Converts a 16bit unsigned number into a string.
  \param[in,out] dst String buffer to store the number.
  \param[in] dstSize Size of the destination buffer in bytes.
  \param[in] val 16bit unsigned number to convert.
 */
void %'ModuleName'%.%Num16uToStr(byte *dst, size_t dstSize, word val)
{
  unsigned char *ptr = ((unsigned char *)dst);
  unsigned char i=0, j;
  unsigned char tmp;

  dstSize--; /* for zero byte */
  if (val == 0 && dstSize > 0){
    ptr[i++] = '0';
    dstSize--;
  }
  while (val > 0 && dstSize > 0) {
    ptr[i++] = (unsigned char)((val %% 10) + '0');
    dstSize--;
    val /= 10;
  }
  for(j=0; j<(i/2); j++) { /* swap buffer */
    tmp = ptr[j];
    ptr[j] = ptr[(i-j)-1];
    ptr[(i-j)-1] = tmp;
  }
  ptr[i] = '\0';
}

%endif %- Num16uToStr
%-BW_METHOD_END Num16uToStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN Num16sToStr
%ifdef Num16sToStr
%define! Pardst
%define! PardstSize
%define! Parval
%include Common\UtilityNum16sToStr.Inc
/*!
  \brief Converts a 16bit signed number into a string.
  \param[in,out] dst String buffer to store the number.
  \param[in] dstSize Size of the destination buffer in bytes.
  \param[in] val 16bit signed number to convert.
 */
void %'ModuleName'%.%Num16sToStr(byte *dst, size_t dstSize, int16_t val)
{
  unsigned char *ptr =  ((unsigned char *)dst);
  unsigned char i=0, j;
  unsigned char tmp;
  unsigned char sign = (unsigned char)(val < 0);

  if (val==(int16_t)(0x8000)) { /* special case 0x8000/-32768: prevent overflow below. */
    %'ModuleName'%.%strcpy(dst, dstSize, (unsigned char*)"-32768");
    return;
  }
  dstSize--; /* for zero byte */
  if (sign) {
    val = -val;
  }
  if (val == 0 && dstSize > 0){
    ptr[i++] = '0';
    dstSize--;
  }
  while (val > 0 && dstSize > 0) {
    ptr[i++] = (unsigned char)((val %% 10) + '0');
    dstSize--;
    val /= 10;
  }
  if (sign && dstSize > 0){
    ptr[i++] = '-';
    dstSize--;
  }
  for(j=0; j<(i/2); j++) { /* swap buffer */
    tmp = ptr[j];
    ptr[j] = ptr[(i-j)-1];
    ptr[(i-j)-1] = tmp;
  }
  ptr[i] = '\0';
}

%endif %- Num16sToStr
%-BW_METHOD_END Num16sToStr
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG ShiftRightAndFill
%define! Pardst
%define! Parfill
%define! ParnofFill
%include Common\GeneralInternalGlobal.inc (ShiftRightAndFill)
static void ShiftRightAndFill(byte *dst, byte fill, byte nofFill)
{
  signed char i, j;

  j = 0;
  while(dst[j] != '\0') {
    j++;
  }
  i = (signed char)nofFill;
  if (i==j) {
    /* nothing to do, we are done */
  } else if (i>j) {
    while (j>=0) {
      dst[i] = dst[j];
      i--; j--;
    }
    while(i>=0) {
      dst[i] = fill;
      i--;
    }
  } else {
    /* hmmm, not enough space, return what we have, do nothing */
  }
}

%-INTERNAL_METHOD_END ShiftRightAndFill
%-************************************************************************************************************
%-BW_METHOD_BEGIN Num16sToStrFormatted
%ifdef Num16sToStrFormatted
%define! Pardst
%define! PardstSize
%define! Parval
%define! Parfill
%define! ParnofFill
%include Common\UtilityNum16sToStrFormatted.Inc
/*!
  \brief Converts a 16bit signed number to a string, in a formatted way (like printf with "%%0d").
     Always terminates the result string.
     Note: count is the size of dst INCLUDING zero byte.
     Precondition: src, dst != NULL
  \param[in,out] dst Start of buffer, where to append the number string
  \param[in] dstSize Size of the destination buffer, in bytes.
  \param[in] val The 16bit signed number to add
  \param[in] fill Fill character, typically ' ' (like for "%%2d" or '0' (for "%%02d")
  \param[in] nofFill Size for the format (right aligned) string, e.g. '2' for "%%2d"
*/
void %'ModuleName'%.%Num16sToStrFormatted(byte *dst, size_t dstSize, int16_t val, char fill, byte nofFill)
{
  %'ModuleName'%.%Num16sToStr(dst, dstSize, val);
  ShiftRightAndFill(dst, fill, nofFill);
}

%endif %- Num16sToStrFormatted
%-BW_METHOD_END Num16sToStrFormatted
%-************************************************************************************************************
%-BW_METHOD_BEGIN Num16uToStrFormatted
%ifdef Num16uToStrFormatted
%define! Pardst
%define! PardstSize
%define! Parval
%define! Parfill
%define! ParnofFill
%include Common\UtilityNum16uToStrFormatted.Inc
/*!
  \brief Converts a 16bit unsigned number to a string, in a formatted way (like printf with "%%0d").
     Always terminates the result string.
     Note: count is the size of dst INCLUDING zero byte.
     Precondition: src, dst != NULL
  \param[in,out] dst Start of buffer, where to append the number string
  \param[in] dstSize Size of the destination buffer, in bytes.
  \param[in] val The 16bit unsigned number to add
  \param[in] fill Fill character, typically ' ' (like for "%%2d" or '0' (for "%%02d")
  \param[in] nofFill Size for the format (right aligned) string, e.g. '2' for "%%2d"
*/
void %'ModuleName'%.%Num16uToStrFormatted(byte *dst, size_t dstSize, word val, char fill, byte nofFill)
{
  %'ModuleName'%.%Num16uToStr(dst, dstSize, val);
  ShiftRightAndFill(dst, fill, nofFill);
}

%endif %- Num16uToStrFormatted
%-BW_METHOD_END Num16uToStrFormatted
%-************************************************************************************************************
%-BW_METHOD_BEGIN Num32uToStrFormatted
%ifdef Num32uToStrFormatted
%define! Pardst
%define! PardstSize
%define! Parval
%define! Parfill
%define! ParnofFill
%include Common\UtilityNum32uToStrFormatted.Inc
/*!
  \brief Converts a 32bit unsigned number to a string, in a formatted way (like printf with "%%0d").
     Always terminates the result string.
     Note: count is the size of dst INCLUDING zero byte.
     Precondition: src, dst != NULL
  \param[in,out] dst Start of buffer, where to append the number string
  \param[in] dstSize Size of the destination buffer, in bytes.
  \param[in] val The 32bit unsigned number to add
  \param[in] fill Fill character, typically ' ' (like for "%%2d" or '0' (for "%%02d")
  \param[in] nofFill Size for the format (right aligned) string, e.g. '2' for "%%2d"
*/
void %'ModuleName'%.%Num32uToStrFormatted(byte *dst, size_t dstSize, dword val, char fill, byte nofFill)
{
  %'ModuleName'%.%Num32uToStr(dst, dstSize, val);
  ShiftRightAndFill(dst, fill, nofFill);
}

%endif %- Num32uToStrFormatted
%-BW_METHOD_END Num32uToStrFormatted
%-************************************************************************************************************
%-BW_METHOD_BEGIN Num32sToStrFormatted
%ifdef Num32sToStrFormatted
%define! Pardst
%define! PardstSize
%define! Parval
%define! Parfill
%define! ParnofFill
%include Common\UtilityNum32sToStrFormatted.Inc
/*!
  \brief Converts a 32bit signed number to a string, in a formatted way (like printf with "%%0d").
     Always terminates the result string.
     Note: count is the size of dst INCLUDING zero byte.
     Precondition: src, dst != NULL
  \param[in,out] dst Start of buffer, where to append the number string
  \param[in] dstSize Size of the destination buffer, in bytes.
  \param[in] val The 32bit signed number to add
  \param[in] fill Fill character, typically ' ' (like for "%%2d" or '0' (for "%%02d")
  \param[in] nofFill Size for the format (right aligned) string, e.g. '2' for "%%2d"
*/
void %'ModuleName'%.%Num32sToStrFormatted(byte *dst, size_t dstSize, long val, char fill, byte nofFill)
{
  %'ModuleName'%.%Num32sToStr(dst, dstSize, val);
  ShiftRightAndFill(dst, fill, nofFill);
}

%endif %- Num32sToStrFormatted
%-BW_METHOD_END Num32sToStrFormatted
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcatNum8u
%ifdef strcatNum8u
%define! Pardst
%define! PardstSize
%define! Parval
%include Common\UtilitystrcatNum8u.Inc
/*!
  \brief appends a 8bit unsigned number to a string. Always terminates the result string.
     Note: count is the size of dst INCLUDING zero byte.
     Precondition: src, dst != NULL
  \param[in,out] dst Start of buffer, where to append the number string
  \param[in] dstSize The size of the buffer, including the zero byte
  \param[in] val The 8bit unsigned number to add
  */
void %'ModuleName'%.%strcatNum8u(byte *dst, size_t dstSize, byte val)
{
  unsigned char buf[sizeof("256")]; /* maximum buffer size we need */

  %'ModuleName'%.%Num8uToStr(buf, sizeof(buf), val);
  %'ModuleName'%.%strcat(dst, dstSize, buf);
}

%endif %- strcatNum8u
%-BW_METHOD_END strcatNum8u
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcatNum8s
%ifdef strcatNum8s
%define! Pardst
%define! PardstSize
%define! Parval
%include Common\UtilitystrcatNum8s.Inc
/*!
  \brief appends a 8bit signed number to a string. Always terminates the result string.
     Note: count is the size of dst INCLUDING zero byte.
     Precondition: src, dst != NULL
  \param[in,out] dst Start of buffer, where to append the number string
  \param[in] dstSize The size of the buffer, including the zero byte
  \param[in] val The 8bit signed number to add
  */
void %'ModuleName'%.%strcatNum8s(byte *dst, size_t dstSize, signed char val)
{
  unsigned char buf[sizeof("-128")]; /* maximum buffer size we need */

  %'ModuleName'%.%Num8sToStr(buf, sizeof(buf), val);
  %'ModuleName'%.%strcat(dst, dstSize, buf);
}

%endif %- strcatNum8s
%-BW_METHOD_END strcatNum8s
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcatNum16u
%ifdef strcatNum16u
%define! Pardst
%define! PardstSize
%define! Parval
%include Common\UtilitystrcatNum16u.Inc
/*!
  \brief appends a 16bit unsigned number to a string. Always terminates the result string.
     Note: count is the size of dst INCLUDING zero byte.
     Precondition: src, dst != NULL
  \param[in,out] dst Start of buffer, where to append the number string
  \param[in] dstSize The size of the buffer, including the zero byte
  \param[in] val The 16bit unsigned number to add
  */
void %'ModuleName'%.%strcatNum16u(byte *dst, size_t dstSize, word val)
{
  unsigned char buf[sizeof("32768")]; /* maximum buffer size we need */

  %'ModuleName'%.%Num16uToStr(buf, sizeof(buf), val);
  %'ModuleName'%.%strcat(dst, dstSize, buf);
}

%endif %- strcatNum16u
%-BW_METHOD_END strcatNum16u
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcatNum16s
%ifdef strcatNum16s
%define! Pardst
%define! PardstSize
%define! Parval
%include Common\UtilitystrcatNum16s.Inc
/*!
  \brief appends a 16bit signed number to a string. Always terminates the result string.
     Note: count is the size of dst INCLUDING zero byte.
     Precondition: src, dst != NULL
  \param[in,out] dst Start of buffer, where to append the number string
  \param[in] dstSize The size of the buffer, including the zero byte
  \param[in] val The 16bit signed number to add
  */
void %'ModuleName'%.%strcatNum16s(byte *dst, size_t dstSize, int16_t val)
{
  unsigned char buf[sizeof("-32768")]; /* maximum buffer size we need */

  %'ModuleName'%.%Num16sToStr(buf, sizeof(buf), val);
  %'ModuleName'%.%strcat(dst, dstSize, buf);
}

%endif %- strcatNum16s
%-BW_METHOD_END strcatNum16s
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcatNum16uFormatted
%ifdef strcatNum16uFormatted
%define! Pardst
%define! PardstSize
%define! Parval
%define! Parfill
%define! ParnofFill
%include Common\UtilitystrcatNum16uFormatted.Inc
/*!
  \brief appends a 16bit unsigned number to a string, in a formatted way (like printf with "%%0d".
     Always terminates the result string.
     Note: count is the size of dst INCLUDING zero byte.
     Precondition: src, dst != NULL
  \param[in,out] dst Start of buffer, where to append the number string
  \param[in] dstSize The size of the buffer, including the zero byte
  \param[in] val The 16bit unsigned number to add
  \param[in] fill Fill character
  \param[in] nofFill Number of fill characters
  */
void %'ModuleName'%.%strcatNum16uFormatted(byte *dst, size_t dstSize, word val, char fill, byte nofFill)
{
  unsigned char buf[sizeof("32768")]; /* maximum buffer size we need */

  %'ModuleName'%.%Num16uToStrFormatted(buf, dstSize, val, fill, nofFill);
  %'ModuleName'%.%strcat(dst, dstSize, buf);
}

%endif %- strcatNum16uFormatted
%-BW_METHOD_END strcatNum16uFormatted
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcatNum16sFormatted
%ifdef strcatNum16sFormatted
%define! Pardst
%define! PardstSize
%define! Parval
%define! Parfill
%define! ParnofFill
%include Common\UtilitystrcatNum16sFormatted.Inc
/*!
  \brief appends a 16bit signed number to a string, in a formatted way (like printf with "%%0d".
     Always terminates the result string.
     Note: count is the size of dst INCLUDING zero byte.
     Precondition: src, dst != NULL
  \param[in,out] dst Start of buffer, where to append the number string
  \param[in] dstSize The size of the buffer, including the zero byte
  \param[in] val The 16bit signed number to add
  \param[in] fill Fill character
  \param[in] nofFill Number of fill characters
  */
void %'ModuleName'%.%strcatNum16sFormatted(byte *dst, size_t dstSize, int16_t val, char fill, byte nofFill)
{
  unsigned char buf[sizeof("-32768")]; /* maximum buffer size we need */

  %'ModuleName'%.%Num16sToStrFormatted(buf, dstSize, val, fill, nofFill);
  %'ModuleName'%.%strcat(dst, dstSize, buf);
}

%endif %- strcatNum16sFormatted
%-BW_METHOD_END strcatNum16sFormatted
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcatNum32uFormatted
%ifdef strcatNum32uFormatted
%define! Pardst
%define! PardstSize
%define! Parval
%define! Parfill
%define! ParnofFill
%include Common\UtilitystrcatNum32uFormatted.Inc
/*!
  \brief appends a 32bit unsigned number to a string, in a formatted way (like printf with "%%0d".
     Always terminates the result string.
     Note: count is the size of dst INCLUDING zero byte.
     Precondition: src, dst != NULL
  \param[in,out] dst Start of buffer, where to append the number string
  \param[in] dstSize The size of the buffer, including the zero byte
  \param[in] val The 32bit unsigned number to add
  \param[in] fill Fill character
  \param[in] nofFill Number of fill characters
  */
void %'ModuleName'%.%strcatNum32uFormatted(byte *dst, size_t dstSize, dword val, char fill, byte nofFill)
{
  unsigned char buf[sizeof("4294967295")]; /* maximum buffer size we need */

  %'ModuleName'%.%Num32uToStrFormatted(buf, dstSize, val, fill, nofFill);
  %'ModuleName'%.%strcat(dst, dstSize, buf);
}

%endif %- strcatNum32uFormatted
%-BW_METHOD_END strcatNum32uFormatted
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcatNum32sFormatted
%ifdef strcatNum32sFormatted
%define! Pardst
%define! PardstSize
%define! Parval
%define! Parfill
%define! ParnofFill
%include Common\UtilitystrcatNum32sFormatted.Inc
/*!
  \brief appends a 32bit signed number to a string, in a formatted way (like printf with "%%0d".
     Always terminates the result string.
     Note: count is the size of dst INCLUDING zero byte.
     Precondition: src, dst != NULL
  \param[in,out] dst Start of buffer, where to append the number string
  \param[in] dstSize The size of the buffer, including the zero byte
  \param[in] val The 32bit signed number to add
  \param[in] fill Fill character
  \param[in] nofFill Number of fill characters
  */
void %'ModuleName'%.%strcatNum32sFormatted(byte *dst, size_t dstSize, long val, char fill, byte nofFill)
{
  unsigned char buf[sizeof("-4294967295")]; /* maximum buffer size we need */

  %'ModuleName'%.%Num32sToStrFormatted(buf, dstSize, val, fill, nofFill);
  %'ModuleName'%.%strcat(dst, dstSize, buf);
}

%endif %- strcatNum32sFormatted
%-BW_METHOD_END strcatNum32sFormatted
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcatNum8Hex
%ifdef strcatNum8Hex
%define! Pardst
%define! PardstSize
%define! Parnum
%include Common\UtilitystrcatNum8Hex.Inc
/*!
  \brief Adds a 8bit number as hex value to a string.
  \param[in,out] dst Start of buffer, where to append the number string
  \param[in] dstSize The size of the buffer, including the zero byte
  \param[in] num The 8bit number to add
  */
void %'ModuleName'%.%strcatNum8Hex(byte *dst, size_t dstSize, byte num)
{
  unsigned char buf[sizeof("FF")]; /* maximum buffer size we need */
  unsigned char hex;

  buf[2] = '\0';
  hex = (char)(num & 0x0F);
  buf[1] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
  hex = (char)((num>>4) & 0x0F);
  buf[0] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
  %'ModuleName'%.%strcat(dst, dstSize, buf);
}

%endif %- strcatNum8Hex
%-BW_METHOD_END strcatNum8Hex
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcatNum16Hex
%ifdef strcatNum16Hex
%define! Pardst
%define! PardstSize
%define! Parnum
%include Common\UtilitystrcatNum16Hex.Inc
/*!
  \brief Adds a 16bit number as hex value to a string.
  \param[in,out] dst Start of buffer, where to append the number string
  \param[in] dstSize The size of the buffer, including the zero byte
  \param[in] num The 16bit number to add
  */
void %'ModuleName'%.%strcatNum16Hex(byte *dst, size_t dstSize, word num)
{
  unsigned char buf[sizeof("FFFF")]; /* maximum buffer size we need */
  unsigned char hex;
  int8_t i;

  buf[4] = '\0';
  i = 3;
  do {
    hex = (char)(num & 0x0F);
    buf[i] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
    num >>= 4;                                                   %>40 /* next nibble */
    i--;
  } while (i>=0);
  %'ModuleName'%.%strcat(dst, dstSize, buf);
}

%endif %- strcatNum16Hex
%-BW_METHOD_END strcatNum16Hex
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcatNum24Hex
%ifdef strcatNum24Hex
%define! Pardst
%define! PardstSize
%define! Parnum
%include Common\UtilitystrcatNum24Hex.Inc
/*!
  \brief Adds a 24bit number as hex value to a string.
  \param[in,out] dst Start of buffer, where to append the number string
  \param[in] dstSize The size of the buffer, including the zero byte
  \param[in] num The 24bit number to add
  */
void %'ModuleName'%.%strcatNum24Hex(byte *dst, size_t dstSize, dword num)
{
  unsigned char buf[sizeof("FFFFFF")]; /* maximum buffer size we need */
  unsigned char hex;
  int8_t i;

  buf[6] = '\0';
  i = 5;
  do {
    hex = (char)(num & 0x0F);
    buf[i] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
    num >>= 4;                                                   %>40 /* next nibble */
    i--;
  } while (i>=0);
  %'ModuleName'%.%strcat(dst, dstSize, buf);
}

%endif %- strcatNum24Hex
%-BW_METHOD_END strcatNum24Hex
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcatNum32Hex
%ifdef strcatNum32Hex
%define! Pardst
%define! PardstSize
%define! Parnum
%include Common\UtilitystrcatNum32Hex.Inc
/*!
  \brief Adds a 32bit number as hex value to a string.
  \param[in,out] dst Start of buffer, where to append the number string
  \param[in] dstSize The size of the buffer, including the zero byte
  \param[in] num The 32bit number to add
  */
void %'ModuleName'%.%strcatNum32Hex(byte *dst, size_t dstSize, dword num)
{
  unsigned char buf[sizeof("FFFFFFFF")]; /* maximum buffer size we need */
  unsigned char hex;
  int8_t i;

  buf[8] = '\0';
  i = 7;
  do {
    hex = (char)(num & 0x0F);
    buf[i] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
    num >>= 4;                                                   %>40 /* next nibble */
    i--;
  } while (i>=0);
  %'ModuleName'%.%strcat(dst, dstSize, buf);
}

%endif %- strcatNum32Hex
%-BW_METHOD_END strcatNum32Hex
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcatNum32s
%ifdef strcatNum32s
%define! Pardst
%define! PardstSize
%define! Parval
%include Common\UtilitystrcatNum32s.Inc
/*!
  \brief appends a 32bit (long) number to a string. Always terminates the result string.
     Note: count is the size of dst INCLUDING zero byte.
     Precondition: src, dst != NULL
  \param[in,out] dst Start of buffer, where to append the number string
  \param[in] dstSize The size of the buffer, including the zero byte
  \param[in] val The 32bit number to add
  */
void %'ModuleName'%.%strcatNum32s(byte *dst, size_t dstSize, long val)
{
  unsigned char buf[sizeof("-4294967295")]; /* maximum buffer size we need */

  %'ModuleName'%.%Num32sToStr(buf, sizeof(buf), val);
  %'ModuleName'%.%strcat(dst, dstSize, buf);
}

%endif %- strcatNum32s
%-BW_METHOD_END strcatNum32s
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcatNum32u
%ifdef strcatNum32u
%define! Pardst
%define! PardstSize
%define! Parval
%include Common\UtilitystrcatNum32u.Inc
/*!
  \brief appends a 32bit (unsigned long) number to a string. Always terminates the result string.
     Note: count is the size of dst INCLUDING zero byte.
     Precondition: src, dst != NULL
  \param[in,out] dst Start of buffer, where to append the number string
  \param[in] dstSize The size of the buffer, including the zero byte
  \param[in] val The 32bit unsigned number to add
  */
void %'ModuleName'%.%strcatNum32u(byte *dst, size_t dstSize, dword val)
{
  unsigned char buf[sizeof("4294967295")]; /* maximum buffer size we need */

  %'ModuleName'%.%Num32uToStr(buf, sizeof(buf), val);
  %'ModuleName'%.%strcat(dst, dstSize, buf);
}

%endif %- strcatNum32u
%-BW_METHOD_END strcatNum32u
%-************************************************************************************************************
%-BW_METHOD_BEGIN Num32sToStr
%ifdef Num32sToStr
%define! Pardst
%define! PardstSize
%define! Parval
%include Common\UtilityNum32sToStr.Inc
/*!
  \brief Converts a 32bit number to a string.
  \param[in,out] dst String buffer to store the number.
  \param[in] dstSize Size of the destination buffer in bytes.
  \param[in] val 32bit signed number to convert.
 */
void %'ModuleName'%.%Num32sToStr(byte *dst, size_t dstSize, long val)
{
  unsigned char *ptr = ((unsigned char *)dst);
  unsigned char i=0, j;
  unsigned char tmp;
  unsigned char sign = (unsigned char)(val < 0);

  if (val==(int32_t)(0x80000000)) { /* special case 0x80000000/-2147483648: prevent overflow below. */
    %'ModuleName'%.%strcpy(dst, dstSize, (unsigned char*)"-2147483648");
    return;
  }
  dstSize--; /* for zero byte */
  if (sign) {
    val = -val;
  }
  if (val == 0 && dstSize > 0){
    ptr[i++] = '0';
    dstSize--;
  }
  while (val > 0 && dstSize > 0) {
    ptr[i++] = (unsigned char)((val %% 10) + '0');
    dstSize--;
    val /= 10;
  }
  if (sign && dstSize > 0){
    ptr[i++] = '-';
    dstSize--;
  }
  for(j=0; j<(i/2); j++) { /* swap buffer */
    tmp = ptr[j];
    ptr[j] = ptr[(i-j)-1];
    ptr[(i-j)-1] = tmp;
  }
  ptr[i] = '\0';
}

%endif %- Num32sToStr
%-BW_METHOD_END Num32sToStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN Num32uToStr
%ifdef Num32uToStr
%define! Pardst
%define! PardstSize
%define! Parval
%include Common\UtilityNum32uToStr.Inc
/*!
  \brief Converts a 32bit signed number to a string.
  \param[in,out] dst String buffer to store the number.
  \param[in] dstSize Size of the destination buffer in bytes.
  \param[in] val 32bit unsigned number to convert.
 */
void %'ModuleName'%.%Num32uToStr(byte *dst, size_t dstSize, dword val)
{
  unsigned char *ptr = ((unsigned char *)dst);
  unsigned char i=0, j;
  unsigned char tmp;

  dstSize--; /* for zero byte */
  if (val == 0 && dstSize > 0){
    ptr[i++] = '0';
    dstSize--;
  }
  while (val > 0 && dstSize > 0) {
    ptr[i++] = (unsigned char)((val %% 10) + '0');
    dstSize--;
    val /= 10;
  }
  for(j=0; j<(i/2); j++) { /* swap buffer */
    tmp = ptr[j];
    ptr[j] = ptr[(i-j)-1];
    ptr[(i-j)-1] = tmp;
  }
  ptr[i] = '\0';
}

%endif %- Num32uToStr
%-BW_METHOD_END Num32uToStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN IsLeapYear
%ifdef IsLeapYear
%define! Paryear
%define! RetVal
%include Common\UtilityIsLeapYear.Inc
bool %'ModuleName'%.%IsLeapYear(word year)
{
  return ((((year%%4)==0) && (year%%100)!=0) || (year%%400)==0);
}

%endif %- IsLeapYear
%-BW_METHOD_END IsLeapYear
%-************************************************************************************************************
%-BW_METHOD_BEGIN WeekDay
%ifdef WeekDay
%define! Paryear
%define! Parmonth
%define! Parday
%define! RetVal
%include Common\UtilityWeekDay.Inc
byte %'ModuleName'%.%WeekDay(word year, byte month, byte day)
{
  /* see http://klausler.com/new-dayofweek.html */
  static const byte skew[12] = {0,3,3,6,1,4,6,2,5,0,3,5};
  word sum;

  sum = (word)(year-1900);
  sum += sum/4;
  sum %%= 7;
  if (%'ModuleName'%.%IsLeapYear(year) && (month==1 || month==2)) {
    sum--;
  }
  sum += day;
  sum %%= 7;
  sum += skew[month-1];
  sum %%= 7;
  return (byte)sum; /* 0: Sunday, 1: Monday, 2: Tuesday, 3: Wednesday, ... */
}

%endif %- WeekDay
%-BW_METHOD_END WeekDay
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadEscapedName
%ifdef ReadEscapedName
%define! Parfilename
%define! Pardestname
%define! Parmaxlen
%define! ParlenRead
%define! ParfileName
%define! ParlenWritten
%define! Parterminators
%define! RetVal
%include Common\UtilityReadEscapedName.Inc
byte %'ModuleName'%.%ReadEscapedName(const unsigned char *filename, byte *destname, size_t maxlen, size_t *lenRead, size_t *lenWritten, const char *terminators)
{
  size_t lenCopied = 0, lenOverread = 0;
  bool quoteMode = FALSE;  /* quoteMode means the name is surrounded by ". In this mode, only a second single quote "
                              terminates the string. In !quoteMode a space or a '\0' may also terminate it correctly */
  bool res = ERR_OK;
  #define IS_SPACE(ch) ((ch)==' '||(ch)=='\t'||(ch)=='\n'||(ch)=='\v'||(ch)=='\f'||(ch)=='\r')

  if (filename==NULL || (destname!=NULL && maxlen<=0)) {
    return ERR_FAILED;
  }
  if (filename[0] == '"') { /* translated mode */
    filename++; /* overread '"' */
    lenOverread++;
    quoteMode=TRUE;
  }
  if (terminators == NULL) {
    terminators = "";
  }
  for (;;) {
    if (quoteMode) {
      if (filename[0] == '"') {
        filename++; /* overread '"' */
        lenOverread++;
        if (filename[0] != '"') { /* quoteMode is terminated by a single quote. A double quote is treated like a single quote and does not terminate it ! */
          break; /* successfully finished with this name */
        } /* else we copy the second quote " */
      }
      if (filename[0] == '\0') { /* unexpected 0. stop */
        res = ERR_FAILED;
        break; /* error case: no terminating double quote (") was found */
      }
    } else { /* copy mode */
      if (IS_SPACE(filename[0]) || filename[0] == '\0' || strchr(terminators, filename[0]) != NULL) { /* !quoteMode is terminated by space, '\0' or by any char in terminators */
        break;
      }
    }
    if (destname != NULL) {
      if (lenCopied + 1 < maxlen) {
        destname[0] = filename[0];
        destname++;
      } else {
        destname[0] = '\0'; /* terminate string */
        destname = NULL; /* avoid it to overwrite not allocated space */
      }
    }
    lenCopied++;
    filename++;
  }
  if (destname != NULL) {
    destname[0] = '\0';
  }
  if (lenRead != NULL) {
    *lenRead = lenCopied+lenOverread;
  }
  if (lenWritten != NULL) {
    *lenWritten = lenCopied + 1; /* additionally a zero byte written */
  }
  return res;
}

%endif %- ReadEscapedName
%-BW_METHOD_END ReadEscapedName
%-************************************************************************************************************
%-BW_METHOD_BEGIN xatoi
%ifdef xatoi
%define! Parstr
%define! Parres
%define! RetVal
%include Common\Utilityxatoi.Inc
/*------------------------------------------------------------------------/
/  Universal string handler for user console interface
/-------------------------------------------------------------------------/
/
/  Copyright (C) 2010, ChaN, all right reserved.
/
/ * This software is a free software and there is NO WARRANTY.
/ * No restriction on use. You can use, modify and redistribute it for
/   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
/ * Redistributions of source code must retain the above copyright notice.
/
/-------------------------------------------------------------------------*/
#ifdef __HC12__
  #pragma MESSAGE DISABLE C12056  /* message about SP debug info */
#endif
byte %'ModuleName'%.%xatoi(const unsigned char **str, int32_t *res)
{
/* 123 -5   0x3ff 0b1111 0377 3.25  w "
      ^                               1st call returns 123 and next ptr
         ^                            2nd call returns -5 and next ptr
                 ^                    3rd call returns 1023 and next ptr
                        ^             4th call returns 15 and next ptr
                             ^        5th call returns 255 and next ptr
                               ^      6th call returns 3 and next ptr, caller needs to read '.'
                                 ^    7th call returns 25 and next ptr
                                    ^ 8th call fails and returns ERR_FAILED
*/
  uint32_t val;
  uint8_t c, r, s = 0;

  *res = 0;
  while (**str==' ') {
    (*str)++;                                                    %>40/* Skip leading spaces */
  }
  c = **str;
  if (c == '-') {                                                %>40/* negative? */
    s = 1;
    c = *(++(*str));
  }
  if (c == '0') {
    c = *(++(*str));
    switch (c) {
      case 'x':                                                  %>40/* hexadecimal */
        r = 16; c = *(++(*str));
        break;
      case 'b':                                                  %>40/* binary */
        r = 2; c = *(++(*str));
        break;
      default:
        if (c <= ' ' || c == '.') {
          return ERR_OK;                                         %>40/* single zero */
        }
        if (c < '0' || c > '9') {
          return ERR_FAILED;                                     %>40/* invalid char */
        }
        r = 8;                                                   %>40/* octal */
        break;
    } /* switch */
  } else {
    if (c < '0' || c > '9') {
      return ERR_FAILED;                                         %>40/* EOL or invalid char */
    }
    r = 10;                                                      %>40/* decimal */
  }
  val = 0;
  while (c > ' ' && c != '.') {
    if (c >= 'a') c -= 0x20;
    c -= '0';
    if (c >= 17) {
      c -= 7;
      if (c <= 9) return ERR_FAILED;                             %>40/* invalid char */
    }
    if (c >= r) return ERR_FAILED;                               %>40/* invalid char for current radix */
    val = val * r + c;
    c = *(++(*str));
  } /* while */
  if (s) val = 0 - val;                                          %>40/* apply sign if needed */
  *res = (long)val;
  return ERR_OK;
}
#ifdef __HC12__
  #pragma MESSAGE DEFAULT C12056  /* message about SP debug info */
#endif

%endif %- xatoi
%-BW_METHOD_END xatoi
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanDate
%ifdef ScanDate
%define! Parstr
%define! Parday
%define! Parmonth
%define! Paryear
%define! RetVal
%include Common\UtilityScanDate.Inc
byte %'ModuleName'%.%ScanDate(const unsigned char **str, byte *day, byte *month, word *year)
{
  /* precondition: string points to starting of date, e.g. "01.01.10" or "12.5.2010", and date is in format dd.mm.yy or dd.mm.yyyy */
  const unsigned char *p;

  p = *str;
  while(*p==' ') {
    p++; /* skip leading spaces */
  }
  if (   %'ModuleName'%.ScanDecimal8uNumber(&p, day)==ERR_OK
      && *day > 0 && *day <= 31
      && (*p=='.' || *p=='-')
     )
  {
    p++;
    if (   %'ModuleName'%.ScanDecimal8uNumber(&p, month)==ERR_OK
        && *month > 0 && *month <= 12
        && (*p=='.' || *p=='-')
       )
    {
      p++;
      if (   %'ModuleName'%.ScanDecimal16uNumber(&p, year)==ERR_OK
          && *year > 0 && *year <= 3000 /* hopefully this is enough :-) */
         )
      {
        if (*year < 100) {
          *year += 2000; /* transform '10' into '2010' */
        }
        *str = p; /* advance pointer for caller */
        return ERR_OK;
      }
    }
  }
  *day = 0;
  *month = 0;
  *year = 0;
  return ERR_FAILED; /* wrong format */
}

%endif %- ScanDate
%-BW_METHOD_END ScanDate
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanTime
%ifdef ScanTime
%define! Parstr
%define! Parhour
%define! Parminute
%define! Parsecond
%define! ParhSecond
%define! RetVal
%include Common\UtilityScanTime.Inc
byte %'ModuleName'%.%ScanTime(const unsigned char **str, byte *hour, byte *minute, byte *second, byte *hSecond)
{
  /* precondition: string points to starting of time string, e.g. "03:15:05" or "03:15:05,3" or "03:15:05,17", and time is in format hh:mm:ss[,hh] */
  const unsigned char *p;
  #define SCAN_IS_DIGIT(ch) ((ch)>='0'&&(ch)<='9')

  *hour = 0;
  *minute = 0;
  *second = 0;
  *hSecond = 0;
  p = *str;
  while(*p==' ') {
    p++; /* skip leading spaces */
  }
  if (   %'ModuleName'%.ScanDecimal8uNumber(&p, hour)==ERR_OK
      && *hour <= 24
      && *p==':'
     )
  {
    p++; /* skip ':' */
    if (   %'ModuleName'%.ScanDecimal8uNumber(&p, minute)==ERR_OK
        && *minute <= 60
       )
    {
      if (*p==':') { /* there is more after the minute */
        p++; /* skip ':' */
        if (   %'ModuleName'%.ScanDecimal8uNumber(&p, second)==ERR_OK
            && *second <= 60
           )
        {
          if (*p==',') { /* we do have either ",z" or ",hh" */
            p++; /* skip ',' */
            if (SCAN_IS_DIGIT(*p)) {
              if (SCAN_IS_DIGIT(*(p+1))) { /* ,hh format */
                *hSecond = (uint8_t)((*p-'0')*10 + *(p+1)-'0');
                p++; p++;
                return ERR_OK;
              } else { /* ,z format */
                *hSecond = (uint8_t)((*p-'0')*10);
                p++;
                *str = p; /* advance pointer for caller */
                return ERR_OK;
              }
            } else {
              return ERR_FAILED; /* illegal format, not a number, e.g. ",x" */
            }
          }
          *str = p; /* advance pointer for caller */
          return ERR_OK;
        }
      } else if (*p==' ' || *p=='\0') { /* nothing more after the minute? Assume zero seconds */
        *str = p; /* advance pointer for caller */
        return ERR_OK;
      }
    }
  }
  return ERR_FAILED; /* wrong format */
}

%endif %- ScanTime
%-BW_METHOD_END ScanTime
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanDecimal8uNumber
%ifdef ScanDecimal8uNumber
%define! Parstr
%define! Parval
%define! RetVal
%include Common\UtilityScanDecimal8uNumber.Inc
byte %'ModuleName'%.%ScanDecimal8uNumber(const unsigned char **str, byte *val)
{
  /* scans a decimal number, and stops at any non-number. Number can have any preceding zeros or spaces. */
  #define _8_NOF_DIGITS  (3+1)
  uint8_t nofDigits = _8_NOF_DIGITS; /* maximum number of digits to avoid overflow */
  const unsigned char *p = *str;

  while(*p==' ') { /* skip leading spaces */
    p++;
  }
  *val = 0;
  while(*p>='0' && *p<='9' && nofDigits > 0) {
    *val = (uint8_t)((*val)*10 + *p-'0');
    nofDigits--;
    p++;
  } /* while */
  if (nofDigits==0) {
    return ERR_OVERFLOW;
  }
  if (nofDigits==_8_NOF_DIGITS) { /* no digits at all? */
    return ERR_FAILED;
  }
  *str = p;
  return ERR_OK;
}

%endif %- ScanDecimal8uNumber
%-BW_METHOD_END ScanDecimal8uNumber
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanDecimal8sNumber
%ifdef ScanDecimal8sNumber
%define! Parstr
%define! Parval
%define! RetVal
%include Common\UtilityScanDecimal8sNumber.Inc
byte %'ModuleName'%.%ScanDecimal8sNumber(const unsigned char **str, signed char *val)
{
  /* Scans a decimal number, and stops at any non-number. Number can have any preceding spaces. */
  const unsigned char *p = *str;
  bool isNeg;
  uint8_t val8u;
  uint8_t res;

  while(*p==' ') { /* skip leading spaces */
    p++;
  }
  *val = 0;
  if (*p=='-') {
    isNeg = TRUE;
    p++; /* skip minus */
  } else {
    isNeg = FALSE;
  }
  res = %'ModuleName'%.%ScanDecimal8uNumber(&p, &val8u);
  if (res != ERR_OK) {
    return res;
  }
  if (isNeg) {
    *val = - (int8_t)val8u;
  } else {
    *val = (int8_t)val8u;
  }
  *str = p;
  return ERR_OK;
}

%endif %- ScanDecimal8sNumber
%-BW_METHOD_END ScanDecimal8sNumber
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanDecimal16uNumber
%ifdef ScanDecimal16uNumber
%define! Parstr
%define! Parval
%define! RetVal
%include Common\UtilityScanDecimal16uNumber.Inc
byte %'ModuleName'%.%ScanDecimal16uNumber(const unsigned char **str, word *val)
{
  /* scans a decimal number, and stops at any non-number. Number can have any preceding zeros or spaces. */
  #define _16_NOF_DIGITS  (5+1)
  uint8_t nofDigits = _16_NOF_DIGITS; /* maximum number of digits to avoid overflow */
  const unsigned char *p = *str;

  while(*p==' ') { /* skip leading spaces */
    p++;
  }
  *val = 0;
  while(*p>='0' && *p<='9' && nofDigits > 0) {
    *val = (uint16_t)((*val)*10 + *p-'0');
    nofDigits--;
    p++;
  } /* while */
  if (nofDigits==0) {
    return ERR_OVERFLOW;
  }
  if (nofDigits==_16_NOF_DIGITS) { /* no digits at all? */
    return ERR_FAILED;
  }
  *str = p;
  return ERR_OK;
}

%endif %- ScanDecimal16uNumber
%-BW_METHOD_END ScanDecimal16uNumber
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanDecimal16sNumber
%ifdef ScanDecimal16sNumber
%define! Parstr
%define! Parval
%define! RetVal
%include Common\UtilityScanDecimal16sNumber.Inc
byte %'ModuleName'%.%ScanDecimal16sNumber(const unsigned char **str, int16_t *val)
{
  /* Scans a decimal number, and stops at any non-number. Number can have any preceding spaces. */
  const unsigned char *p = *str;
  bool isNeg;
  uint16_t val16u;
  uint8_t res;

  while(*p==' ') { /* skip leading spaces */
    p++;
  }
  *val = 0;
  if (*p=='-') {
    isNeg = TRUE;
    p++; /* skip minus */
  } else {
    isNeg = FALSE;
  }
  res = %'ModuleName'%.%ScanDecimal16uNumber(&p, &val16u);
  if (res != ERR_OK) {
    return res;
  }
  if (isNeg) {
    *val = - (int16_t)val16u;
  } else {
    *val = (int16_t)val16u;
  }
  *str = p;
  return ERR_OK;
}

%endif %- ScanDecimal16sNumber
%-BW_METHOD_END ScanDecimal16sNumber
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanDecimal32uNumber
%ifdef ScanDecimal32uNumber
%define! Parstr
%define! Parval
%define! RetVal
%include Common\UtilityScanDecimal32uNumber.Inc
byte %'ModuleName'%.%ScanDecimal32uNumber(const unsigned char **str, uint32_t *val)
{
  /* scans a decimal number, and stops at any non-number. Number can have any preceding zeros or spaces. */
  #define _32_NOF_DIGITS  (10+1)
  uint8_t nofDigits = _32_NOF_DIGITS; /* maximum number of digits to avoid overflow */
  const unsigned char *p = *str;

  while(*p==' ') { /* skip leading spaces */
    p++;
  }
  *val = 0;
  while(*p>='0' && *p<='9' && nofDigits > 0) {
    *val = (uint32_t)((*val)*10 + *p-'0');
    nofDigits--;
    p++;
  } /* while */
  if (nofDigits==0) {
    return ERR_OVERFLOW;
  }
  if (nofDigits==_32_NOF_DIGITS) { /* no digits at all? */
    return ERR_FAILED;
  }
  *str = p;
  return ERR_OK;
}

%endif %- ScanDecimal32uNumber
%-BW_METHOD_END ScanDecimal32uNumber
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanDecimal32sNumber
%ifdef ScanDecimal32sNumber
%define! Parstr
%define! Parval
%define! RetVal
%include Common\UtilityScanDecimal32sNumber.Inc
byte %'ModuleName'%.%ScanDecimal32sNumber(const unsigned char **str, uint32_t *val)
{
  /* Scans a decimal number, and stops at any non-number. Number can have any preceding spaces. */
  const unsigned char *p = *str;
  bool isNeg;
  uint32_t val32u;
  uint8_t res;

  while(*p==' ') { /* skip leading spaces */
    p++;
  }
  *val = 0;
  if (*p=='-') {
    isNeg = TRUE;
    p++; /* skip minus */
  } else {
    isNeg = FALSE;
  }
  res = %'ModuleName'%.%ScanDecimal32uNumber(&p, &val32u);
  if (res != ERR_OK) {
    return res;
  }
  if (isNeg) {
    *val = (uint32_t)(-(int32_t)val32u);
  } else {
    *val = val32u;
  }
  *str = p;
  return ERR_OK;
}

%endif %- ScanDecimal32sNumber
%-BW_METHOD_END ScanDecimal32sNumber
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcmp
%ifdef strcmp
%define! Parstr1
%define! Parstr2
%define! RetVal
%include Common\Utilitystrcmp.Inc
/***
int16_t %'ModuleName'%.%strcmp(const char *, const char *)
{
  Method is implemented as macro in the header file as wrapper to the standard strcmp() function
}
*/

%endif %- strcmp
%-BW_METHOD_END strcmp
%-************************************************************************************************************
%-BW_METHOD_BEGIN strncmp
%ifdef strncmp
%define! Parstr1
%define! Parstr2
%define! Parsize
%define! RetVal
%include Common\Utilitystrncmp.Inc
/***
int16_t %'ModuleName'%.%strncmp(const char *, const char *, size_t size)
{
  /Method is implemented as macro in the header file as wrapper to the standard strncmp() function
}
*/

%endif %- strncmp
%-BW_METHOD_END strncmp
%-************************************************************************************************************
%-BW_METHOD_BEGIN strlen
%ifdef strlen
%define! Parstr
%define! RetVal
%include Common\Utilitystrlen.Inc
/***
word %'ModuleName'%.%strlen(const char *)
{
  Method is implemented as macro in the header file as wrapper to the standard strlen() function
}
*/

%endif %- strlen
%-BW_METHOD_END strlen
%-************************************************************************************************************
%if defined(ScanHex8uNumber) | defined(ScanHex16uNumber) | defined(ScanHex32uNumber)
static byte PreScanHexNumber(const unsigned char **str)
{
  const unsigned char *p = *str;

  while(*p==' ') { /* skip leading spaces */
    p++; /* skip space */
  }
  if (*p!='0') { /* must start with 0x */
    return ERR_FAILED;
  }
  p++; /* skip '0' */
  if (*p!='x') { /* must start with 0x */
    return ERR_FAILED;
  }
  p++; /* skip 'x' */
  *str = p;
  return ERR_OK;
}

static byte HexToDec(const unsigned char **p, unsigned char *val) {
  /* convert a hexadecimal character into a decimal value */
  unsigned char ch = **p;

  if (ch>='0' && ch<='9') {
    *val = (unsigned char)(ch-'0');
    (*p)++;
    return ERR_OK;
  } else if (ch>='a' && ch<='f') {
    *val = (unsigned char)(ch-'a'+10);
    (*p)++;
    return ERR_OK;
  } else if (ch>='A' && ch<='F') {
    *val = (unsigned char)(ch-'A'+10);
    (*p)++;
    return ERR_OK;
  }
  return ERR_FAILED;
}

%endif
%-BW_METHOD_BEGIN ScanHex32uNumber
%ifdef ScanHex32uNumber
%define! Parstr
%define! Parval
%define! RetVal
%include Common\UtilityScanHex32uNumber.Inc
byte %'ModuleName'%.%ScanHex32uNumber(const unsigned char **str, uint32_t *val)
{
  /* scans a decimal number, and stops at any non-number. Number can have any preceding zeros or spaces. */
  uint8_t nofDigits = 8+1; /* maximum number of digits to avoid overflow */
  const unsigned char *p = *str;
  byte v;

  if (PreScanHexNumber(&p)!=ERR_OK) { /* skip leading spaces, and scan '0x' */
    return ERR_FAILED;
  }
  *val = 0;
  while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
    *val = (uint32_t)((*val)*16 + v);
    nofDigits--;
  } /* while */
  if (nofDigits==0) {
    return ERR_OVERFLOW;
  }
  *str = p;
  return ERR_OK;
}

%endif %- ScanHex32uNumber
%-BW_METHOD_END ScanHex32uNumber
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanHex16uNumber
%ifdef ScanHex16uNumber
%define! Parstr
%define! Parval
%define! RetVal
%include Common\UtilityScanHex16uNumber.Inc
byte %'ModuleName'%.%ScanHex16uNumber(const unsigned char **str, word *val)
{
  /* scans a decimal number, and stops at any non-number. Number can have any preceding zeros or spaces. */
  uint8_t nofDigits = 4+1; /* maximum number of digits to avoid overflow */
  const unsigned char *p = *str;
  byte v;

  if (PreScanHexNumber(&p)!=ERR_OK) { /* skip leading spaces, and scan '0x' */
    return ERR_FAILED;
  }
  *val = 0;
  while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
    *val = (uint16_t)((*val)*16 + v);
    nofDigits--;
  } /* while */
  if (nofDigits==0) {
    return ERR_OVERFLOW;
  }
  *str = p;
  return ERR_OK;
}

%endif %- ScanHex16uNumber
%-BW_METHOD_END ScanHex16uNumber
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanHex8uNumber
%ifdef ScanHex8uNumber
%define! Parstr
%define! Parval
%define! RetVal
%include Common\UtilityScanHex8uNumber.Inc
byte %'ModuleName'%.%ScanHex8uNumber(const unsigned char **str, byte *val)
{
  /* scans a hex number with 0x, and stops at any non-number. Number can have any preceding zeros or spaces. */
  uint8_t nofDigits = 2+1; /* maximum number of digits to avoid overflow */
  const unsigned char *p = *str;
  byte v;

  if (PreScanHexNumber(&p)!=ERR_OK) { /* skip leading spaces, and scan '0x' */
    return ERR_FAILED;
  }
  *val = 0;
  while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
    *val = (uint8_t)((*val)*16 + v);
    nofDigits--;
  } /* while */
  if (nofDigits==0) {
    return ERR_OVERFLOW;
  }
  *str = p;
  return ERR_OK;
}

%endif %- ScanHex8uNumber
%-BW_METHOD_END ScanHex8uNumber
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanHex8uNumberNoPrefix
%ifdef ScanHex8uNumberNoPrefix
%define! Parstr
%define! Parval
%define! RetVal
%include Common\UtilityScanHex8uNumberNoPrefix.Inc
byte %'ModuleName'%.%ScanHex8uNumberNoPrefix(const unsigned char **str, byte *val)
{
  /* scans a hex number without 0x, and stops at any non-number. Number can have any preceding zeros or spaces. */
  uint8_t nofDigits = 2+1; /* maximum number of digits to avoid overflow */
  const unsigned char *p = *str;
  byte v;

  while(*p==' ') { /* skip leading spaces */
    p++; /* skip space */
  }
  *val = 0;
  while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
    *val = (uint8_t)((*val)*16 + v);
    nofDigits--;
  } /* while */
  if (nofDigits==0) {
    return ERR_OVERFLOW;
  }
  *str = p;
  return ERR_OK;
}

%endif %- ScanHex8uNumberNoPrefix
%-BW_METHOD_END ScanHex8uNumberNoPrefix
%-************************************************************************************************************
%-BW_METHOD_BEGIN strtailcmp
%ifdef strtailcmp
%define! Parstr
%define! Partail
%define! RetVal
%include Common\Utilitystrtailcmp.Inc
byte %'ModuleName'%.%strtailcmp(byte *str, byte *tail)
{
  int i, j;

  i = (int)%'ModuleName'%.%strlen((char*)str);
  j = (int)%'ModuleName'%.%strlen((char*)tail);
  if (j>i) { /* str is smaller than tail */
    return 1; /* cannot match */
  }
  /* compare strings */
  while(str[i]==tail[j]) {
    i--;
    j--;
    if (j<0) {
      return 0; /* match */
    }
  }
  return 1; /* !=0 means no match */
}

%endif %- strtailcmp
%-BW_METHOD_END strtailcmp
%-************************************************************************************************************
%-BW_METHOD_BEGIN strCutTail
%ifdef strCutTail
%define! Parstr
%define! Partail
%define! RetVal
%include Common\UtilitystrCutTail.Inc
byte %'ModuleName'%.%strCutTail(byte *str, byte *tail)
{
  /* cut the tail from the string */
  size_t strLen, tailLen;

  if (%'ModuleName'%.%strtailcmp(str, tail)!=0) { /* check if tail is present */
    return ERR_FAILED; /* tail not found */
  }
  tailLen = %'ModuleName'%.%strlen((char*)tail);
  strLen = %'ModuleName'%.%strlen((char*)str);
  /* write \0 to cut the tail */
  str[strLen-tailLen] = '\0';
  return ERR_OK;
}

%endif %- strCutTail
%-BW_METHOD_END strCutTail
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcatNum32sDotValue100
%ifdef strcatNum32sDotValue100
%define! Pardst
%define! PardstSize
%define! Parnum
%include Common\UtilitystrcatNum32sDotValue100.Inc
void %'ModuleName'%.%strcatNum32sDotValue100(byte *dst, size_t dstSize, long num)
{
  %'ModuleName'%.%strcatNum32s(dst, dstSize, num/100);
  %'ModuleName'%.%chcat(dst, dstSize, '.');
  if (num<0) {
    num = -num;
  }
  %'ModuleName'%.%strcatNum16uFormatted(dst, dstSize, (uint16_t)(num%%100), '0', 2);
}

%endif %- strcatNum32sDotValue100
%-BW_METHOD_END strcatNum32sDotValue100
%-************************************************************************************************************
%-BW_METHOD_BEGIN strFind
%ifdef strFind
%define! Parstr
%define! ParsubStr
%define! RetVal
%include Common\UtilitystrFind.Inc
int16_t %'ModuleName'%.%strFind(byte *str, byte *subStr)
{
  int16_t i, len;

  len = (int16_t)UTIL1_strlen((char*)subStr);
  for (i=0; *str!='\0'; i++, str++) {
    if (%'ModuleName'%.%strncmp((char*)str, (char*)subStr, len)==0) {
      return i; /* found */
    }
  }
  return -1; /* not found */
}

%endif %- strFind
%-BW_METHOD_END strFind
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
%-  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This bean is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
