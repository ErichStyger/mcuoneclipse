%-Driver generated by the Component Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Component Wizard
%- If you change these lines, Component Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    26.11.2012
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%ifdef LDD_I2C
  %ifdef @LDD_I2C@OnMasterBlockSent
    %define! Description_%@LDD_I2C@OnMasterBlockSent This event is called when I2C in master mode finishes the transmission of the data successfully. This event is not available for the SLAVE mode and if MasterSendBlock is disabled.  The event services the event of the inherited component and eventually invokes other events.
  %endif %- @LDD_I2C@OnMasterBlockSent
%endif %- LDD_I2C
%ifdef LDD_I2C
  %ifdef @LDD_I2C@OnMasterBlockReceived
    %define! Description_%@LDD_I2C@OnMasterBlockReceived This event is called when I2C is in master mode and finishes the reception of the data successfully. This event is not available for the SLAVE mode and if MasterReceiveBlock is disabled. The event services the event of the inherited component and eventually invokes other events.
  %endif %- @LDD_I2C@OnMasterBlockReceived
%endif %- LDD_I2C
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\GenericI2CSettings.Inc
%define! Abstract Common\GenericI2CAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

#ifndef __BWUserType_%'ModuleName'_TTIME
#define __BWUserType_%'ModuleName'_TTIME
  typedef struct {                                               %>40/* Time in binary format */
    byte hour;                                                   %>40/* hours */
    byte min;                                                    %>40/* minutes */
    byte sec;                                                    %>40/* seconds */
    bool mode;                                                   %>40/* clock mode, 0 for 12-hour mode, otherwise 0-24 hour mode */
    byte am_pm;                                                  %>40/* 0: AM, otherwise PM */
  } %'ModuleName'_TTIME;
#endif
#ifndef __BWUserType_%'ModuleName'_TDATE
#define __BWUserType_%'ModuleName'_TDATE
  typedef struct {                                               %>40/* Date in binary format */
    byte year;                                                   %>40/* year */
    byte month;                                                  %>40/* month */
    byte day;                                                    %>40/* day */
    bool dayOfWeek;                                              %>40/* Day of week, where 0 is the first day. In the range of 0..6 */
  } %'ModuleName'_TDATE;
#endif

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
#define %'ModuleName'%.WRITE_BUFFER_SIZE %WriteBufferSize /* size of internal buffer used, set in the component properties */

typedef enum %'ModuleName'_EnumSendFlags_ {
  %'ModuleName'_SEND_STOP,        /* STOP is sent */
  %'ModuleName'_DO_NOT_SEND_STOP  /* STOP is not sent */
} %'ModuleName'_EnumSendFlags;
%-
%-BW_CUSTOM_USERTYPE_END
%-BW_DEFINITION_START
%-************************************************************************************************************
%-INHERITED_EVENT_BEGIN LDD_I2C OnMasterBlockSent
%if defined(LDD_I2C) & defined(@LDD_I2C@OnMasterBlockSent)
void %@LDD_I2C@OnMasterBlockSent(LDD_TUserData *UserDataPtr);

%endif %- @LDD_I2C@OnMasterBlockSent
%-INHERITED_EVENT_END LDD_I2C OnMasterBlockSent
%-INHERITED_EVENT_BEGIN LDD_I2C OnMasterBlockReceived
%if defined(LDD_I2C) & defined(@LDD_I2C@OnMasterBlockReceived)
void %@LDD_I2C@OnMasterBlockReceived(LDD_TUserData *UserDataPtr);

%endif %- @LDD_I2C@OnMasterBlockReceived
%-INHERITED_EVENT_END LDD_I2C OnMasterBlockReceived
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
void %'ModuleName'%.%Init(void);
%include Common\GenericI2CInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
void %'ModuleName'%.%Deinit(void);
%include Common\GenericI2CDeinit.Inc

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadAddress
%ifdef ReadAddress
byte %'ModuleName'%.%ReadAddress(byte i2cAddr, byte *memAddr, byte memAddrSize, byte *data, word dataSize);
%define! Pari2cAddr
%define! ParmemAddr
%define! ParmemAddrSize
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\GenericI2CReadAddress.Inc

%endif %- ReadAddress
%-BW_METHOD_END ReadAddress
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteAddress
%ifdef WriteAddress
byte %'ModuleName'%.%WriteAddress(byte i2cAddr, byte *memAddr, byte memAddrSize, byte *data, word dataSize);
%define! Pari2cAddr
%define! ParmemAddr
%define! ParmemAddrSize
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\GenericI2CWriteAddress.Inc

%endif %- WriteAddress
%-BW_METHOD_END WriteAddress
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetSemaphore
%ifdef GetSemaphore
void* %'ModuleName'%.%GetSemaphore(void);
%define! RetVal
%include Common\GenericI2CGetSemaphore.Inc

%endif %- GetSemaphore
%-BW_METHOD_END GetSemaphore
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadBlock
%ifdef ReadBlock
byte %'ModuleName'%.%ReadBlock(void* data, word dataSize, %'ModuleName'_EnumSendFlags flags);
%define! Pardata
%define! PardataSize
%define! Parflags
%define! RetVal
%include Common\GenericI2CReadBlock.Inc

%endif %- ReadBlock
%-BW_METHOD_END ReadBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteBlock
%ifdef WriteBlock
byte %'ModuleName'%.%WriteBlock(void* data, word dataSize, %'ModuleName'_EnumSendFlags flags);
%define! Pardata
%define! PardataSize
%define! Parflags
%define! RetVal
%include Common\GenericI2CWriteBlock.Inc

%endif %- WriteBlock
%-BW_METHOD_END WriteBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN RequestBus
%ifdef RequestBus
void %'ModuleName'%.%RequestBus(void);
%include Common\GenericI2CRequestBus.Inc

%endif %- RequestBus
%-BW_METHOD_END RequestBus
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReleaseBus
%ifdef ReleaseBus
void %'ModuleName'%.%ReleaseBus(void);
%include Common\GenericI2CReleaseBus.Inc

%endif %- ReleaseBus
%-BW_METHOD_END ReleaseBus
%-************************************************************************************************************
%-BW_METHOD_BEGIN SelectSlave
%ifdef SelectSlave
byte %'ModuleName'%.%SelectSlave(byte i2cAddr);
%define! Pari2cAddr
%define! RetVal
%include Common\GenericI2CSelectSlave.Inc

%endif %- SelectSlave
%-BW_METHOD_END SelectSlave
%-************************************************************************************************************
%-BW_METHOD_BEGIN UnselectSlave
%ifdef UnselectSlave
byte %'ModuleName'%.%UnselectSlave(void);
%define! RetVal
%include Common\GenericI2CUnselectSlave.Inc

%endif %- UnselectSlave
%-BW_METHOD_END UnselectSlave
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadByteAddress8
%ifdef ReadByteAddress8
byte %'ModuleName'%.%ReadByteAddress8(byte i2cAddr, byte memAddr, byte *data);
%define! Pari2cAddr
%define! ParmemAddr
%define! Pardata
%define! RetVal
%include Common\GenericI2CReadByteAddress8.Inc

%endif %- ReadByteAddress8
%-BW_METHOD_END ReadByteAddress8
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteByteAddress8
%ifdef WriteByteAddress8
byte %'ModuleName'%.%WriteByteAddress8(byte i2cAddr, byte memAddr, byte data);
%define! Pari2cAddr
%define! ParmemAddr
%define! Pardata
%define! RetVal
%include Common\GenericI2CWriteByteAddress8.Inc

%endif %- WriteByteAddress8
%-BW_METHOD_END WriteByteAddress8
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanDevice
%ifdef ScanDevice
byte %'ModuleName'%.%ScanDevice(byte i2cAddr);
%define! Pari2cAddr
%define! RetVal
%include Common\GenericI2CScanDevice.Inc

%endif %- ScanDevice
%-BW_METHOD_END ScanDevice
%-************************************************************************************************************
%-BW_METHOD_BEGIN ProbeACK
%ifdef ProbeACK
byte %'ModuleName'%.%ProbeACK(void* data, word dataSize, %'ModuleName'_EnumSendFlags flags, word WaitTimeUS);
%define! Pardata
%define! PardataSize
%define! Parflags
%define! ParWaitTimeUS
%define! RetVal
%include Common\GenericI2CProbeACK.Inc

%endif %- ProbeACK
%-BW_METHOD_END ProbeACK
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN OnMasterBlockSent
%ifdef OnMasterBlockSent
%INTERFACE OnMasterBlockSent
void %OnMasterBlockSent(LDD_TUserData *UserDataPtr);
%define! ParUserDataPtr
%include Common\GenericI2COnMasterBlockSent.Inc

%endif %- OnMasterBlockSent
%-BW_METHOD_END OnMasterBlockSent
%-BW_METHOD_BEGIN OnMasterBlockReceived
%ifdef OnMasterBlockReceived
%INTERFACE OnMasterBlockReceived
void %OnMasterBlockReceived(LDD_TUserData *UserDataPtr);
%define! ParUserDataPtr
%include Common\GenericI2COnMasterBlockReceived.Inc

%endif %- OnMasterBlockReceived
%-BW_METHOD_END OnMasterBlockReceived
%-BW_METHOD_BEGIN OnRequestBus
%ifdef OnRequestBus
%INTERFACE OnRequestBus
void %OnRequestBus(void);
%include Common\GenericI2COnRequestBus.Inc

%endif %- OnRequestBus
%-BW_METHOD_END OnRequestBus
%-BW_METHOD_BEGIN OnReleaseBus
%ifdef OnReleaseBus
%INTERFACE OnReleaseBus
void %OnReleaseBus(void);
%include Common\GenericI2COnReleaseBus.Inc

%endif %- OnReleaseBus
%-BW_METHOD_END OnReleaseBus
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\GenericI2CSettings.Inc
%define! Abstract Common\GenericI2CAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
#ifndef NULL
  #define NULL 0L
#endif /* NULL */
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%-
%if defined(LDD_I2C)
typedef struct {
  volatile bool dataReceivedFlg; /* set to TRUE by the interrupt if we have received data */
  volatile bool dataTransmittedFlg; /* set to TRUE by the interrupt if we have set data */
  LDD_TDeviceData *handle; /* pointer to the device handle */
} %'ModuleName'%.TDataState;

static %'ModuleName'%.TDataState %'ModuleName'%.deviceData;

%if defined(Timeout)
#define %'ModuleName'%.TIMEOUT_US  %TimeoutUs  /* number of microseconds as specified in properties */
#define %'ModuleName'%.TIMEOUT_TICKS(factor) ((%'ModuleName'%.TIMEOUT_US*(factor))/1000/%@Timeout@'ModuleName'%.TICK_PERIOD_MS)
%endif
%endif
%if defined(RTOS) & %UseSemaphore='yes'
static xSemaphoreHandle %'ModuleName'%.busSem = NULL; /* Semaphore to protect I2C bus access */
%endif
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN RequestBus
%ifdef RequestBus
%include Common\GenericI2CRequestBus.Inc
void %'ModuleName'%.%RequestBus(void)
{
%if defined(OnRequestBus)
  %OnRequestBus();
%endif
%if defined(RTOS) & %UseSemaphore='yes'
  (void)%@RTOS@'ModuleName'%.xSemaphoreTakeRecursive(%'ModuleName'%.busSem, portMAX_DELAY);
%endif
}

%endif %- RequestBus
%-BW_METHOD_END RequestBus
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReleaseBus
%ifdef ReleaseBus
%include Common\GenericI2CReleaseBus.Inc
void %'ModuleName'%.%ReleaseBus(void)
{
%if defined(RTOS) & %UseSemaphore='yes'
  (void)%@RTOS@'ModuleName'%.xSemaphoreGiveRecursive(%'ModuleName'%.busSem);
%endif
%if defined(OnReleaseBus)
  %OnReleaseBus();
%endif
}

%endif %- ReleaseBus
%-BW_METHOD_END ReleaseBus
%-************************************************************************************************************
%-BW_METHOD_BEGIN SelectSlave
%ifdef SelectSlave
%define! Pari2cAddr
%define! RetVal
%include Common\GenericI2CSelectSlave.Inc
byte %'ModuleName'%.%SelectSlave(byte i2cAddr)
{
%if (defined(OnRequestBus)) | (defined(RTOS) & %UseSemaphore='yes')
  %'ModuleName'%.%RequestBus();
%endif
%if defined(LDD_I2C)
  if (%@LDD_I2C@'ModuleName'%.SelectSlaveDevice(%'ModuleName'%.deviceData.handle, LDD_I2C_ADDRTYPE_7BITS, i2cAddr)!=ERR_OK) {
  %if (defined(OnReleaseBus)) | (defined(RTOS) & %UseSemaphore='yes')
    %'ModuleName'%.%ReleaseBus();
  %endif
    return ERR_FAILED;
  }
%endif
%if defined(I2C)
  if (%@I2C@'ModuleName'%.SelectSlave(i2cAddr)!=ERR_OK) {
  %if (defined(OnReleaseBus)) | (defined(RTOS) & %UseSemaphore='yes')
    %'ModuleName'%.%ReleaseBus();
  %endif
    return ERR_FAILED;
  }
%endif
  return ERR_OK;
}

%endif %- SelectSlave
%-BW_METHOD_END SelectSlave
%-************************************************************************************************************
%-BW_METHOD_BEGIN UnselectSlave
%ifdef UnselectSlave
%define! RetVal
%include Common\GenericI2CUnselectSlave.Inc
byte %'ModuleName'%.%UnselectSlave(void)
{
%if (defined(OnReleaseBus)) | (defined(RTOS) & %UseSemaphore='yes')
  %'ModuleName'%.%ReleaseBus();
%endif
  return ERR_OK;
}

%endif %- UnselectSlave
%-BW_METHOD_END UnselectSlave
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadBlock
%ifdef ReadBlock
%define! Pardata
%define! PardataSize
%define! Parflags
%define! RetVal
%include Common\GenericI2CReadBlock.Inc
byte %'ModuleName'%.%ReadBlock(void* data, word dataSize, %'ModuleName'_EnumSendFlags flags)
{
  byte res = ERR_OK;
%if defined(LDD_I2C)
%if defined(Timeout)
  %@Timeout@'ModuleName'%.CounterHandle timeout;
  bool isTimeout;
%endif
%else
  word nof;
%endif

%if defined(LDD_I2C)
  for(;;) { /* breaks */
    %'ModuleName'%.deviceData.dataReceivedFlg = FALSE;
    res = %@LDD_I2C@'ModuleName'%.MasterReceiveBlock(%'ModuleName'%.deviceData.handle, data, dataSize, flags==%'ModuleName'_SEND_STOP?LDD_I2C_SEND_STOP:LDD_I2C_NO_SEND_STOP);
    if (res!=ERR_OK) {
      break; /* break for(;;) */
    }
%if defined(Timeout)
    timeout = %@Timeout@'ModuleName'%.GetCounter(%'ModuleName'%.TIMEOUT_TICKS(dataSize)); /* set up timeout counter */
    if (timeout==%@Timeout@'ModuleName'%.OUT_OF_HANDLE) {
      res = ERR_QFULL;
      break; /* break for(;;) */
    }
%endif
    do { /* Wait until data is received */
%if defined(Timeout)
      isTimeout = %@Timeout@'ModuleName'%.CounterExpired(timeout);
      if (isTimeout) {
        break; /* break while() */
      }
%endif
    } while (!%'ModuleName'%.deviceData.dataReceivedFlg);
%if defined(Timeout)
    %@Timeout@'ModuleName'%.LeaveCounter(timeout);
    if (isTimeout) {
      res = ERR_BUSY;
      break; /* break for(;;) */
    }
%endif
    break; /* break for(;;) */
  } /* for(;;) */
%else
  for(;;) { /* breaks */
    res = %@I2C@'ModuleName'%.RecvBlock(data, dataSize, &nof);
    if (res!=ERR_OK) {
      break; /* break for(;;) */
    }
    if (flags==%'ModuleName'_SEND_STOP) {
      res = %@I2C@'ModuleName'%.SendStop();
      if (res!=ERR_OK) {
        break; /* break for(;;) */
      }
    }
    break; /* break for(;;) */
  } /* for(;;) */
%endif
  return res;
}

%endif %- ReadBlock
%-BW_METHOD_END ReadBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteBlock
%ifdef WriteBlock
%define! Pardata
%define! PardataSize
%define! Parflags
%define! RetVal
%include Common\GenericI2CWriteBlock.Inc
byte %'ModuleName'%.%WriteBlock(void* data, word dataSize, %'ModuleName'_EnumSendFlags flags)
{
%if defined(I2C)
  word nof;
%endif
%if defined(Timeout)
  %@Timeout@'ModuleName'%.CounterHandle timeout;
  bool isTimeout;
%endif
  byte res = ERR_OK;

%if defined(LDD_I2C)
  for(;;) { /* breaks */
    %'ModuleName'%.deviceData.dataTransmittedFlg = FALSE;
    res = %@LDD_I2C@'ModuleName'%.MasterSendBlock(%'ModuleName'%.deviceData.handle, data, dataSize, flags==%'ModuleName'_SEND_STOP?LDD_I2C_SEND_STOP:LDD_I2C_NO_SEND_STOP);
    if (res!=ERR_OK) {
      break; /* break for(;;) */
    }
%if defined(Timeout)
    timeout = %@Timeout@'ModuleName'%.GetCounter(%'ModuleName'%.TIMEOUT_TICKS(dataSize)); /* set up timeout counter */
    if (timeout==%@Timeout@'ModuleName'%.OUT_OF_HANDLE) {
      res = ERR_QFULL;
      break; /* break for(;;) */
    }
%endif
    do { /* Wait until data is sent */
%if defined(Timeout)
      isTimeout = %@Timeout@'ModuleName'%.CounterExpired(timeout);
      if (isTimeout) {
        break; /* break while loop */
      }
%endif
    } while (!%'ModuleName'%.deviceData.dataTransmittedFlg);
%if defined(Timeout)
    %@Timeout@'ModuleName'%.LeaveCounter(timeout);
    if (isTimeout) {
      res = ERR_BUSY;
      break; /* break for(;;) */
    }
%endif
    break; /* break for(;;) */
  } /* for(;;) */
%else
  for(;;) { /* breaks */
    res = %@I2C@'ModuleName'%.SendBlock(data, dataSize, &nof);
    if (res!=ERR_OK) {
      (void)%@I2C@'ModuleName'%.SendStop();
      break; /* break for(;;) */
    }
    if (flags==%'ModuleName'_SEND_STOP) {
      res = %@I2C@'ModuleName'%.SendStop();
      if (res!=ERR_OK) {
        break; /* break for(;;) */
      }
    }
    break; /* break for(;;) */
  } /* for(;;) */
%endif
  return res;
}

%endif %- WriteBlock
%-BW_METHOD_END WriteBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadAddress
%ifdef ReadAddress
%define! Pari2cAddr
%define! ParmemAddr
%define! ParmemAddrSize
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\GenericI2CReadAddress.Inc
byte %'ModuleName'%.%ReadAddress(byte i2cAddr, byte *memAddr, byte memAddrSize, byte *data, word dataSize)
{
  byte res = ERR_OK;
%if defined(LDD_I2C)
%if defined(Timeout)
  %@Timeout@'ModuleName'%.CounterHandle timeout;
  bool isTimeout;
%endif
%else
  word nof;
%endif

  if (%'ModuleName'%.%SelectSlave(i2cAddr)!=ERR_OK) {
    return ERR_FAILED;
  }
%if defined(LDD_I2C)
  for(;;) { /* breaks */
    /* send device address and memory address */
    %'ModuleName'%.deviceData.dataTransmittedFlg = FALSE;
    res = %@LDD_I2C@'ModuleName'%.MasterSendBlock(%'ModuleName'%.deviceData.handle, memAddr, memAddrSize, LDD_I2C_NO_SEND_STOP);
    if (res!=ERR_OK) {
      break; /* break for(;;) */
    }
%if defined(Timeout)
    timeout = %@Timeout@'ModuleName'%.GetCounter(%'ModuleName'%.TIMEOUT_TICKS(memAddrSize)); /* set up timeout counter */
    if (timeout==%@Timeout@'ModuleName'%.OUT_OF_HANDLE) {
      res = ERR_QFULL;
      break; /* break for(;;) */
    }
%endif
    do { /* Wait until data is sent */
%if defined(Timeout)
      isTimeout = %@Timeout@'ModuleName'%.CounterExpired(timeout);
      if (isTimeout) {
        break; /* break while() */
      }
%endif
    } while (!%'ModuleName'%.deviceData.dataTransmittedFlg);
%if defined(Timeout)
    %@Timeout@'ModuleName'%.LeaveCounter(timeout);
    if (isTimeout) {
      res = ERR_BUSY;
      break; /* break for(;;) */
    }
%endif
    /* receive data */
    %'ModuleName'%.deviceData.dataReceivedFlg = FALSE;
    res = %@LDD_I2C@'ModuleName'%.MasterReceiveBlock(%'ModuleName'%.deviceData.handle, data, dataSize, LDD_I2C_SEND_STOP);
    if (res!=ERR_OK) {
      break; /* break for(;;) */
    }
%if defined(Timeout)
    timeout = %@Timeout@'ModuleName'%.GetCounter(%'ModuleName'%.TIMEOUT_TICKS(dataSize)); /* set up timeout counter */
    if (timeout==%@Timeout@'ModuleName'%.OUT_OF_HANDLE) {
      res = ERR_QFULL;
      break; /* break for(;;) */
    }
%endif
    do { /* Wait until data is received */
%if defined(Timeout)
      isTimeout = %@Timeout@'ModuleName'%.CounterExpired(timeout);
      if (isTimeout) {
        break; /* break while() */
      }
%endif
    } while (!%'ModuleName'%.deviceData.dataReceivedFlg);
%if defined(Timeout)
    %@Timeout@'ModuleName'%.LeaveCounter(timeout);
    if (isTimeout) {
      res = ERR_BUSY;
      break; /* break for(;;) */
    }
%endif
    break; /* break for(;;) */
  } /* for(;;) */
%else
  for(;;) { /* breaks */
    res = %@I2C@'ModuleName'%.SendBlock((void*)memAddr, memAddrSize, &nof);
    if (res!=ERR_OK) {
      (void)%@I2C@'ModuleName'%.SendStop();
      break; /* break for(;;) */
    }
    res = %@I2C@'ModuleName'%.RecvBlock(data, dataSize, &nof);
    if (res!=ERR_OK) {
      (void)%@I2C@'ModuleName'%.SendStop();
      break; /* break for(;;) */
    }
    res = %@I2C@'ModuleName'%.SendStop();
    if (res!=ERR_OK) {
      break; /* break for(;;) */
    }
    break; /* break for(;;) */
  } /* for(;;) */
%endif
  if (%'ModuleName'%.%UnselectSlave()!=ERR_OK) {
    return ERR_FAILED;
  }
  return res;
}

%endif %- ReadAddress
%-BW_METHOD_END ReadAddress
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteAddress
%ifdef WriteAddress
%define! Pari2cAddr
%define! ParmemAddr
%define! ParmemAddrSize
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\GenericI2CWriteAddress.Inc
byte %'ModuleName'%.%WriteAddress(byte i2cAddr, byte *memAddr, byte memAddrSize, byte *data, word dataSize)
{
  static byte writeBuf[%'ModuleName'%.WRITE_BUFFER_SIZE];
  byte *p;
  word i;
%if defined(I2C)
  word nof;
%endif
%if defined(Timeout)
  %@Timeout@'ModuleName'%.CounterHandle timeout;
  bool isTimeout;
%endif
  byte res = ERR_OK;

  if (%'ModuleName'%.%SelectSlave(i2cAddr)!=ERR_OK) {
    return ERR_FAILED;
  }
  if (memAddrSize+dataSize>%'ModuleName'%.WRITE_BUFFER_SIZE) {
    return ERR_FAILED;
  }
  i = 0; p = memAddr;
  while(i<%'ModuleName'%.WRITE_BUFFER_SIZE && memAddrSize>0) {
    writeBuf[i++] = *p++;
    memAddrSize--;
  }
  p = data;
  while(i<%'ModuleName'%.WRITE_BUFFER_SIZE && dataSize>0) {
    writeBuf[i++] = *p++;
    dataSize--;
  }
%if defined(LDD_I2C)
  for(;;) { /* breaks */
    /* send device address, memory address and data */
    %'ModuleName'%.deviceData.dataTransmittedFlg = FALSE;
    if (%@LDD_I2C@'ModuleName'%.MasterSendBlock(%'ModuleName'%.deviceData.handle, writeBuf, i, LDD_I2C_SEND_STOP)!=ERR_OK) {
      break; /* break for(;;) */
    }
%if defined(Timeout)
    timeout = %@Timeout@'ModuleName'%.GetCounter(%'ModuleName'%.TIMEOUT_TICKS(i)); /* set up timeout counter */
    if (timeout==%@Timeout@'ModuleName'%.OUT_OF_HANDLE) {
      res = ERR_QFULL;
      break; /* break for(;;) */
    }
%endif
    do { /* Wait until data is sent */
%if defined(Timeout)
      isTimeout = %@Timeout@'ModuleName'%.CounterExpired(timeout);
      if (isTimeout) {
        break; /* break while loop */
      }
%endif
    } while (!%'ModuleName'%.deviceData.dataTransmittedFlg);
%if defined(Timeout)
    %@Timeout@'ModuleName'%.LeaveCounter(timeout);
    if (isTimeout) {
      res = ERR_BUSY;
      break; /* break for(;;) */
    }
%endif
    break; /* break for(;;) */
  } /* for(;;) */
%else
  for(;;) { /* breaks */
    res = %@I2C@'ModuleName'%.SendBlock((void*)writeBuf, i, &nof);
    if (res!=ERR_OK) {
      (void)%@I2C@'ModuleName'%.SendStop();
      break; /* break for(;;) */
    }
    res = %@I2C@'ModuleName'%.SendStop();
    if (res!=ERR_OK) {
      break; /* break for(;;) */
    }
    break; /* break for(;;) */
  } /* for(;;) */
%endif
  if (%'ModuleName'%.%UnselectSlave()!=ERR_OK) {
    return ERR_FAILED;
  }
  return res;
}

%endif %- WriteAddress
%-BW_METHOD_END WriteAddress
%-************************************************************************************************************
%-INHERITED_EVENT_BEGIN LDD_I2C OnMasterBlockSent
%if defined(LDD_I2C) & defined(@LDD_I2C@OnMasterBlockSent)
%include Common\GeneralInternal.inc (OnMasterBlockSent)
void %@LDD_I2C@OnMasterBlockSent(LDD_TUserData *UserDataPtr)
{
  if (UserDataPtr==&%'ModuleName'%.deviceData) { /* it is our own message */
    %'ModuleName'%.TDataState *devicePtr = (%'ModuleName'%.TDataState*)UserDataPtr;

    devicePtr->dataTransmittedFlg = TRUE;
%ifdef OnMasterBlockSent
  } else { /* call user or inherited component event */
    %OnMasterBlockSent(UserDataPtr);
%endif %- OnMasterBlockSent
  }
}

%endif %- @LDD_I2C@OnMasterBlockSent
%-INHERITED_EVENT_END LDD_I2C OnMasterBlockSent
%-INHERITED_EVENT_BEGIN LDD_I2C OnMasterBlockReceived
%if defined(LDD_I2C) & defined(@LDD_I2C@OnMasterBlockReceived)
%include Common\GeneralInternal.inc (OnMasterBlockReceived)
void %@LDD_I2C@OnMasterBlockReceived(LDD_TUserData *UserDataPtr)
{
  if (UserDataPtr==&%'ModuleName'%.deviceData) { /* it is our own message */
    %'ModuleName'%.TDataState *devicePtr = (%'ModuleName'%.TDataState*)UserDataPtr;

    devicePtr->dataReceivedFlg = TRUE;
%ifdef OnMasterBlockReceived
  } else { /* call user or inherited component event */
    %OnMasterBlockReceived(UserDataPtr);
%endif %- OnMasterBlockReceived
  }
}

%endif %- @LDD_I2C@OnMasterBlockReceived
%-INHERITED_EVENT_END LDD_I2C OnMasterBlockReceived
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%include Common\GenericI2CInit.Inc
void %'ModuleName'%.%Init(void)
{
%if defined(LDD_I2C)
  %'ModuleName'%.deviceData.handle = %@LDD_I2C@'ModuleName'%.Init(&%'ModuleName'%.deviceData);
  if (%'ModuleName'%.deviceData.handle==NULL) {
    for(;;){} /* failure! */
  }
%endif
%if defined(RTOS) & %UseSemaphore='yes'
  %'ModuleName'%.busSem = %@RTOS@'ModuleName'%.xSemaphoreCreateRecursiveMutex();
  if (%'ModuleName'%.busSem==NULL) { /* semaphore creation failed */
    for(;;) {} /* error, not enough memory? */
  }
%endif
}

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
%include Common\GenericI2CDeinit.Inc
void %'ModuleName'%.%Deinit(void)
{
%if defined(LDD_I2C)
  %@LDD_I2C@'ModuleName'%.Deinit(&%'ModuleName'%.deviceData);
%endif
%if defined(RTOS) & %UseSemaphore='yes'
  %@RTOS@'ModuleName'%.vSemaphoreDelete(%'ModuleName'%.busSem);
%endif
}

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetSemaphore
%ifdef GetSemaphore
%define! RetVal
%include Common\GenericI2CGetSemaphore.Inc
void* %'ModuleName'%.%GetSemaphore(void)
{
%if defined(RTOS) & %UseSemaphore='yes'
  return %'ModuleName'%.busSem;
%else
  return NULL; /* RTOS and Semaphore enabled in properties */
%endif
}

%endif %- GetSemaphore
%-BW_METHOD_END GetSemaphore
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadByteAddress8
%ifdef ReadByteAddress8
%define! Pari2cAddr
%define! ParmemAddr
%define! Pardata
%define! RetVal
%include Common\GenericI2CReadByteAddress8.Inc
byte %'ModuleName'%.%ReadByteAddress8(byte i2cAddr, byte memAddr, byte *data)
{
  return %'ModuleName'%.ReadAddress(i2cAddr, &memAddr, sizeof(memAddr), data, 1);
}

%endif %- ReadByteAddress8
%-BW_METHOD_END ReadByteAddress8
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteByteAddress8
%ifdef WriteByteAddress8
%define! Pari2cAddr
%define! ParmemAddr
%define! Pardata
%define! RetVal
%include Common\GenericI2CWriteByteAddress8.Inc
byte %'ModuleName'%.%WriteByteAddress8(byte i2cAddr, byte memAddr, byte data)
{
  return %'ModuleName'%.WriteAddress(i2cAddr, &memAddr, sizeof(memAddr), &data, 1);
}

%endif %- WriteByteAddress8
%-BW_METHOD_END WriteByteAddress8
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanDevice
%ifdef ScanDevice
%define! Pari2cAddr
%define! RetVal
%include Common\GenericI2CScanDevice.Inc
byte %'ModuleName'%.%ScanDevice(byte i2cAddr)
{
  byte res = ERR_OK;
%if defined(LDD_I2C)
%if defined(Timeout)
  %@Timeout@'ModuleName'%.CounterHandle timeout;
  bool isTimeout;
%endif
  LDD_I2C_TErrorMask errMask;
%else
  word nof;
%endif
  byte dummy;

  if (%'ModuleName'%.%SelectSlave(i2cAddr)!=ERR_OK) {
    return ERR_FAILED;
  }
%if defined(LDD_I2C)
  for(;;) { /* breaks */
    /* send device address */
    %'ModuleName'%.deviceData.dataTransmittedFlg = FALSE;
    res = %@LDD_I2C@'ModuleName'%.MasterReceiveBlock(%'ModuleName'%.deviceData.handle, &dummy, 1, LDD_I2C_SEND_STOP);
    if (res!=ERR_OK) {
      break; /* break for(;;) */
    }
%if defined(Timeout)
    timeout = %@Timeout@'ModuleName'%.GetCounter(%'ModuleName'%.TIMEOUT_TICKS(1)); /* set up timeout counter */
    if (timeout==%@Timeout@'ModuleName'%.OUT_OF_HANDLE) {
      res = ERR_QFULL;
      break; /* break for(;;) */
    }
%endif
    do { /* Wait until data is sent */
%if defined(Timeout)
      isTimeout = %@Timeout@'ModuleName'%.CounterExpired(timeout);
      if (isTimeout) {
        break; /* break while() */
      }
%endif
    } while (!%'ModuleName'%.deviceData.dataTransmittedFlg);
    errMask = 0;
    (void)%@LDD_I2C@'ModuleName'%.GetError(%'ModuleName'%.deviceData.handle, &errMask);
%if defined(Timeout)
    %@Timeout@'ModuleName'%.LeaveCounter(timeout);
%endif
    if (errMask&LDD_I2C_MASTER_NACK) { /* master did not receive ACK from slave */
      res = ERR_NOTAVAIL; /* device did not respond with ACK */
    }
    break; /* break for(;;) */
  } /* for(;;) */
%else
  for(;;) { /* breaks */
    res = %@I2C@'ModuleName'%.RecvBlock((void*)&dummy, 1, &nof);
    if (res!=ERR_OK) {
      (void)%@I2C@'ModuleName'%.SendStop();
      break; /* break for(;;) */
    }
    res = %@I2C@'ModuleName'%.SendStop();
    if (res!=ERR_OK) {
      break; /* break for(;;) */
    }
    break; /* break for(;;) */
  } /* for(;;) */
%endif
  if (%'ModuleName'%.%UnselectSlave()!=ERR_OK) {
    return ERR_FAILED;
  }
  return res;
}

%endif %- ScanDevice
%-BW_METHOD_END ScanDevice
%-************************************************************************************************************
%-BW_METHOD_BEGIN ProbeACK
%ifdef ProbeACK
%define! Pardata
%define! PardataSize
%define! Parflags
%define! ParWaitTimeUS
%define! RetVal
%include Common\GenericI2CProbeACK.Inc
byte %'ModuleName'%.%ProbeACK(void* data, word dataSize, %'ModuleName'_EnumSendFlags flags, word WaitTimeUS)
{
%if defined(I2C)
  word nof;
%endif
  byte res = ERR_OK;

%if defined(LDD_I2C)
  %'ModuleName'%.deviceData.dataTransmittedFlg = FALSE;
  res = %@LDD_I2C@'ModuleName'%.MasterSendBlock(%'ModuleName'%.deviceData.handle, data, dataSize, flags==%'ModuleName'_SEND_STOP?LDD_I2C_SEND_STOP:LDD_I2C_NO_SEND_STOP);
  if (res!=ERR_OK) {
    return res;
  }
  %@Wait@'ModuleName'%.Waitus(WaitTimeUS);
  if (!%'ModuleName'%.deviceData.dataTransmittedFlg) {
    return ERR_FAILED; /* no ACK received? */
  }
%else
  (void)WaitTimeUS; /* not used */
  for(;;) { /* breaks */
    res = %@I2C@'ModuleName'%.SendBlock(data, dataSize, &nof);
    if (res!=ERR_OK) {
      (void)%@I2C@'ModuleName'%.SendStop();
      break; /* break for(;;) */
    }
    if (flags==%'ModuleName'_SEND_STOP) {
      res = %@I2C@'ModuleName'%.SendStop();
      if (res!=ERR_OK) {
        break; /* break for(;;) */
      }
    }
    break; /* break for(;;) */
  } /* for(;;) */
%endif
  return res;
}

%endif %- ProbeACK
%-BW_METHOD_END ProbeACK
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_METHOD_BEGIN OnRequestBus
%ifdef OnRequestBus
%IMPLEMENTATION OnRequestBus
%include Common\GenericI2COnRequestBus.Inc
void %OnRequestBus(void)
{
  /* Write your code here ... */
}

%endif %- OnRequestBus
%-BW_METHOD_END OnRequestBus
%-BW_METHOD_BEGIN OnReleaseBus
%ifdef OnReleaseBus
%IMPLEMENTATION OnReleaseBus
%include Common\GenericI2COnReleaseBus.Inc
void %OnReleaseBus(void)
{
  /* Write your code here ... */
}

%endif %- OnReleaseBus
%-BW_METHOD_END OnReleaseBus
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
%if %initOnStartup='yes'
  %'ModuleName'%.%Init();
%endif
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This component is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
