%-Driver generated by the Component Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Component Wizard
%- If you change these lines, Component Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    16.12.2010
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_Delay The method waits in delay loop.
%define! Description_Read The method reads one byte of data from the bus.
%define! Description_GetAck The method reads ACK from the bus.
%define! Description_Write The method sends one byte of data to the bus.
%define! Description_SetAck The method sends ACK to the bus.
%define! Description_InternalStop The method generates the Stop condition on the bus.
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\GenericSWI2CSettings.Inc
%define! Abstract Common\GenericSWI2CAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
%-BW_CUSTOM_USERTYPE_END


%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
void %'ModuleName'%.%Init(void);
%include Common\GenericSWI2CInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendChar
%ifdef SendChar
byte %'ModuleName'%.%SendChar(byte Chr);
%define! ParChr
%define! RetVal
%include Common\GenericSWI2CSendChar.Inc

%endif %- SendChar
%-BW_METHOD_END SendChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN RecvChar
%ifdef RecvChar
byte %'ModuleName'%.%RecvChar(byte *Chr);
%define! ParChr
%define! RetVal
%include Common\GenericSWI2CRecvChar.Inc

%endif %- RecvChar
%-BW_METHOD_END RecvChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendBlock
%ifdef SendBlock
byte %'ModuleName'%.%SendBlock(void *Ptr, word Siz, word *Snt);
%define! ParPtr
%define! ParSiz
%define! ParSnt
%define! RetVal
%include Common\GenericSWI2CSendBlock.Inc

%endif %- SendBlock
%-BW_METHOD_END SendBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN RecvBlock
%ifdef RecvBlock
byte %'ModuleName'%.%RecvBlock(void *Ptr, word Siz, word *Rcv);
%define! ParPtr
%define! ParSiz
%define! ParRcv
%define! RetVal
%include Common\GenericSWI2CRecvBlock.Inc

%endif %- RecvBlock
%-BW_METHOD_END RecvBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendStop
%ifdef SendStop
byte %'ModuleName'%.%SendStop(void);
%define! RetVal
%include Common\GenericSWI2CSendStop.Inc

%endif %- SendStop
%-BW_METHOD_END SendStop
%-************************************************************************************************************
%-BW_METHOD_BEGIN SelectSlave
%ifdef SelectSlave
byte %'ModuleName'%.%SelectSlave(byte Slv);
%define! ParSlv
%define! RetVal
%include Common\GenericSWI2CSelectSlave.Inc

%endif %- SelectSlave
%-BW_METHOD_END SelectSlave
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetSelected
%ifdef GetSelected
byte %'ModuleName'%.%GetSelected(byte *Slv);
%define! ParSlv
%define! RetVal
%include Common\GenericSWI2CGetSelected.Inc

%endif %- GetSelected
%-BW_METHOD_END GetSelected
%-************************************************************************************************************
%-BW_METHOD_BEGIN ResetBus
%ifdef ResetBus
bool %'ModuleName'%.%ResetBus(void);
%define! RetVal
%include Common\GenericSWI2CResetBus.Inc

%endif %- ResetBus
%-BW_METHOD_END ResetBus
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendBlockContinue
%ifdef SendBlockContinue
byte %'ModuleName'%.%SendBlockContinue(void *Ptr, word Siz, word *Snt);
%define! ParPtr
%define! ParSiz
%define! ParSnt
%define! RetVal
%include Common\GenericSWI2CSendBlockContinue.Inc

%endif %- SendBlockContinue
%-BW_METHOD_END SendBlockContinue
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN OnNACK
%ifdef OnNACK
%INTERFACE OnNACK
void %OnNACK(void);
%include Common\GenericSWI2COnNACK.Inc

%endif %- OnNACK
%-BW_METHOD_END OnNACK
%-BW_METHOD_BEGIN OnTxChar
%ifdef OnTxChar
%INTERFACE OnTxChar
void %OnTxChar(void);
%include Common\GenericSWI2COnTxChar.Inc

%endif %- OnTxChar
%-BW_METHOD_END OnTxChar
%-BW_METHOD_BEGIN OnRxChar
%ifdef OnRxChar
%INTERFACE OnRxChar
void %OnRxChar(void);
%include Common\GenericSWI2COnRxChar.Inc

%endif %- OnRxChar
%-BW_METHOD_END OnRxChar
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\GenericSWI2CSettings.Inc
%define! Abstract Common\GenericSWI2CAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%-
%if defined(OperatingSystemId) & OperatingSystemId = 'FreeRTOS'
#define %'ModuleName'%.HAS_RTOS  1 /* FreeRTOS present */
%else
#define %'ModuleName'%.HAS_RTOS  0 /* No RTOS present */
%endif
%if %Yield='yes'
#define %'ModuleName'%.YIELD     1 /* Yield is enabled in the component properties */
%else
#define %'ModuleName'%.YIELD     0 /* Yield is diabled in the component properties */
%endif

#if %'ModuleName'%.HAS_RTOS
/* include RTOS header files */
#include "FreeRTOS.h" /* for yielding */
#endif

#if %'ModuleName'%.HAS_RTOS && %'ModuleName'%.YIELD
  #define %'ModuleName'%.OSYIELD() taskYIELD()
#else
  #define %'ModuleName'%.OSYIELD() /* do nothing */
#endif

#define ACK         0U
#define NOACK       1U
#define OUTPUT      1U
#define INPUT       0U
#define WRITE       0U
#define READ        1U
#define TRIALS      %NofTrials /* defined by component properties */

#define %'ModuleName'%.DELAY_NS    %DelayNs   /* delay time in ns, as specified in the component properties */

static byte SlaveAddr;             /* destination slave address      */

#define SCL_SetDir(dir) %@SCL@'ModuleName'%.SetDir(dir)
#define SCL_ClrVal()    %@SCL@'ModuleName'%.ClrVal()
#define SCL_GetVal()    %@SCL@'ModuleName'%.GetVal()

#define SDA_SetDir(dir) %@SDA@'ModuleName'%.SetDir(dir)
#define SDA_ClrVal()    %@SDA@'ModuleName'%.ClrVal()
#define SDA_GetVal()    %@SDA@'ModuleName'%.GetVal()

%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-UNLOCKED
/* Internal method prototypes */
%-INTERNAL_LOC_METHOD_BEG Delay
static void Delay(void);
%-INTERNAL_LOC_METHOD_END Delay
%-INTERNAL_LOC_METHOD_BEG Read
static byte Read(void);
%-INTERNAL_LOC_METHOD_END Read
%-INTERNAL_LOC_METHOD_BEG GetAck
static bool GetAck(void);
%-INTERNAL_LOC_METHOD_END GetAck
%-INTERNAL_LOC_METHOD_BEG Write
static void Write(byte Data);
%-INTERNAL_LOC_METHOD_END Write
%-INTERNAL_LOC_METHOD_BEG SetAck
static void SetAck(bool Ack);
%-INTERNAL_LOC_METHOD_END SetAck
%-INTERNAL_LOC_METHOD_BEG InternalStop
static void InternalStop(void);
%-INTERNAL_LOC_METHOD_END InternalStop
%-

%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG Delay
%include Common\GeneralInternalGlobal.inc (Delay)
static void Delay(void)
{
  %'ModuleName'%.OSYIELD();
  %@Wait@'ModuleName'%.Waitns(%'ModuleName'%.DELAY_NS);
}

%-INTERNAL_METHOD_END Delay
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%include Common\GenericSWI2CInit.Inc
void %'ModuleName'%.%Init(void)
{
  SlaveAddr = 0;
}

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG Write
%define! ParData
%include Common\GeneralInternalGlobal.inc (Write)
static void Write(byte Data)
{
  byte Shift;
  byte I;
  word timeout;

  Shift = 0x80U;
  for (I = 0x08U; I != 0U; I--) {
    if (Data & Shift) {
      SDA_SetDir((bool)INPUT);   /* SDA HIGH */
    } else {
      SDA_SetDir((bool)OUTPUT);
      SDA_ClrVal();              /* SDA LOW */
    }
    Delay();
    Shift = (byte)(Shift >> 1);
    SCL_SetDir((bool)INPUT);     /* CLOCK HIGH PULSE */
    Delay();
    timeout = 65535U;
    while((SCL_GetVal()==0U)&&(timeout!=0U)) { /* WAIT FOR CLOCK HIGH PULSE */
      timeout--;
      %'ModuleName'%.OSYIELD();
    }
    Delay();
    SCL_SetDir((bool)OUTPUT);
    SCL_ClrVal();                /* CLOCK LOW PULSE */
    Delay();
  }
}

%-INTERNAL_METHOD_END Write
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG Read
%define! RetVal
%include Common\GeneralInternalGlobal.inc (Read)
static byte Read(void)
{
  byte Shift;
  byte I;
  word timeout;

  Shift = 0U;
  SDA_SetDir((bool)INPUT);       /* SDA INPUT MODE */
  Delay(); /* give SDA setup time */
  for (I = 0x08U; I != 0U; I--) {
    SCL_SetDir((bool)INPUT);     /* CLOCK HIGH PULSE */
    Delay();
    timeout = 65535U;
    while((SCL_GetVal()==0U)&&(timeout!=0U)) { /* WAIT FOR CLOCK HIGH PULSE */
      timeout--;
      %'ModuleName'%.OSYIELD();
    }
    Delay();
    Shift = (byte)(Shift << 1);
    if (SDA_GetVal()) {
      Shift++;
    }
    SCL_SetDir((bool)OUTPUT);
    SCL_ClrVal();                /* CLOCK LOW PULSE */
    Delay();
  }
  return Shift;
}

%-INTERNAL_METHOD_END Read
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG GetAck
%define! RetVal
%include Common\GeneralInternalGlobal.inc (GetAck)
static bool GetAck(void)
{
  word timeout;

  SDA_SetDir((bool)INPUT);       /* SDA HIGH */
  Delay();
  SCL_SetDir((bool)INPUT);       /* CLOCK HIGH PULSE */
  Delay();
  timeout = 65535U;
  while((SCL_GetVal()==0U)&&(timeout!=0U)) { /* WAIT FOR CLOCK HIGH PULSE */
    timeout--;
    %'ModuleName'%.OSYIELD();
  }
  return((bool)SDA_GetVal());    /* ACKNOWLEDGE VALUE */
}

%-INTERNAL_METHOD_END GetAck
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG SetAck
%define! ParAck
%include Common\GeneralInternalGlobal.inc (SetAck)
static void SetAck(bool Ack)
{
  word timeout;

  Delay();
  if (Ack) {
    SDA_SetDir((bool)INPUT);     /* MASTER NOACKNOWLEDGE - SDA HIGH */
  } else {
    SDA_SetDir((bool)OUTPUT);
    SDA_ClrVal();                /* MASTER ACKNOWLEDGE - SDA LOW */
  }
  Delay();
  SCL_SetDir((bool)INPUT);       /* HIGH CLOCK PULSE */
  Delay();
  timeout = 65535U;
  while((SCL_GetVal()==0U)&&(timeout!=0U)) { /* WAIT FOR CLOCK HIGH PULSE */
    timeout--;
    %'ModuleName'%.OSYIELD();
  }
  Delay();
  SCL_SetDir((bool)OUTPUT);
  SCL_ClrVal();                  /* LOW CLOCK PULSE */
  Delay();
  SDA_SetDir((bool)INPUT);       /* ACKNOWLEDGE END - SDA HIGH  */
  Delay();
}

%-INTERNAL_METHOD_END SetAck
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG InternalStop
%include Common\GeneralInternalGlobal.inc (InternalStop)
static void InternalStop(void)
{
  Delay();
  SDA_SetDir((bool)OUTPUT);
  SDA_ClrVal();                  /* STOP SETUP */
  SCL_SetDir((bool)INPUT);       /* CLOCK HIGH PULSE + STOP SETUP TIME */
  Delay();
  SDA_SetDir((bool)INPUT);       /* STOP CONDITION */
  Delay();                       /* stop setup time to SCL low (which might follow) */
}

%-INTERNAL_METHOD_END InternalStop
%-************************************************************************************************************
%-BW_METHOD_BEGIN ResetBus
%ifdef ResetBus
%define! RetVal
%include Common\GenericSWI2CResetBus.Inc
bool %'ModuleName'%.%ResetBus(void)
{
  char i;

  if(SDA_GetVal() && SCL_GetVal()) {
    return TRUE;
  }
  SCL_SetDir((bool)INPUT);
  SDA_SetDir((bool)INPUT);
  Delay();
  if(!SCL_GetVal()) {
    return FALSE; /* SCL held low externally, nothing we can do */
  }
  for(i = 0; i<9; i++) { /* up to 9 clocks until SDA goes high */
    SCL_SetDir((bool)OUTPUT);
    SCL_ClrVal();
    Delay();
    SCL_SetDir((bool)INPUT);
    Delay();
    if( SDA_GetVal()) {
      break; /* finally SDA high so we can generate a STOP */
    }
  } /* for */
  if(!SDA_GetVal()) {
    return FALSE; /* after 9 clocks still nothing */
  }
  InternalStop();
  return(SDA_GetVal() && SCL_GetVal()); /* both high then we succeeded */
}

%endif %- ResetBus
%-BW_METHOD_END ResetBus
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendChar
%ifdef SendChar
%define! ParChr
%define! RetVal
%include Common\GenericSWI2CSendChar.Inc
byte %'ModuleName'%.%SendChar(byte Chr)
{
  word Trial;
  bool Acknowledge;
  word timeout;

  Trial = TRIALS;
  do {
    SDA_SetDir((bool)INPUT);     /* SDA HIGH - START SETUP*/
    SCL_SetDir((bool)INPUT);     /* CLOCK HIGH PULSE */
    Delay();                       /* CLOCK HIGH PULSE & BUS FREE TIME */
    /* check that we have a valid start condition: SDA needs to be high */
    timeout = 65535U;
    while((SDA_GetVal()==0U)&&(timeout!=0U)) { /* WAIT FOR CLOCK HIGH PULSE */
      timeout--;
      %'ModuleName'%.OSYIELD();
    }
    Delay();
    if (timeout==0) {
      InternalStop();
      return ERR_BUSY;
    }
    SDA_SetDir((bool)OUTPUT);
    SDA_ClrVal();                /* START CONDITION */
    Delay();                       /* START HOLD TIME */
    SCL_SetDir((bool)OUTPUT);
    SCL_ClrVal();                /* CLOCK LOW PULSE */
    Delay();
    Write((byte)(SlaveAddr + WRITE));
    Acknowledge = GetAck();
    --Trial;
  } while ((Trial != 0U) && Acknowledge);
  if (Acknowledge) {               /* WRONG ACKNOWLEDGE */
%if defined(OnNACK)
    %OnNACK();
%endif
    SCL_SetDir((bool)OUTPUT);
    SCL_ClrVal();                /* CLOCK LOW PULSE */
    InternalStop();
    return ERR_BUSY;
  } else {
    SCL_SetDir((bool)OUTPUT);
    SCL_ClrVal();                /* CLOCK LOW PULSE */
    Delay();
  }
  Write(Chr);
  if (GetAck()) {                  /* WRONG ACKNOWLEDGE */
%if defined(OnNACK)
    %OnNACK();
%endif
    SCL_SetDir((bool)OUTPUT);
    SCL_ClrVal();                /* CLOCK LOW PULSE */
    InternalStop();
    return ERR_BUSY;
  } else {
%if defined(OnTxChar)
    %OnTxChar();
%endif
    SCL_SetDir((bool)OUTPUT);
    SCL_ClrVal();                /* CLOCK LOW PULSE */
    Delay();
  }
  return ERR_OK;
}

%endif %- SendChar
%-BW_METHOD_END SendChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN RecvChar
%ifdef RecvChar
%define! ParChr
%define! RetVal
%include Common\GenericSWI2CRecvChar.Inc
byte %'ModuleName'%.%RecvChar(byte *Chr)
{
  word Trial;
  bool Acknowledge;
  word timeout;

  Trial = TRIALS;
  do {
    SDA_SetDir((bool)INPUT);     /* SDA HIGH - START SETUP */
    SCL_SetDir((bool)INPUT);     /* CLOCK HIGH PULSE */
    Delay();                     /* CLOCK HIGH PULSE & BUS FREE TIME */
    /* check that we have a valid start condition: SDA needs to be high */
    timeout = 65535U;
    while((SDA_GetVal()==0U)&&(timeout!=0U)) { /* WAIT FOR CLOCK HIGH PULSE */
      timeout--;
      %'ModuleName'%.OSYIELD();
    }
    Delay();
    if (timeout==0) {
      InternalStop();
      return ERR_BUSY;
    }
    SDA_SetDir((bool)OUTPUT);
    SDA_ClrVal();                /* START CONDITION */
    Delay();                       /* START HOLD TIME */
    SCL_SetDir((bool)OUTPUT);
    SCL_ClrVal();                /* CLOCK LOW PULSE */
    Delay();
    Write((byte)(SlaveAddr + READ));
    Acknowledge = GetAck();
    --Trial;
  } while ((Trial != 0U) && Acknowledge);
  if (Acknowledge) {
%if defined(OnNACK)
    %OnNACK();
%endif
    SCL_SetDir((bool)OUTPUT);
    SCL_ClrVal();                /* CLOCK LOW PULSE */
    InternalStop();
    return ERR_BUSY;
  } else {
    SCL_SetDir((bool)OUTPUT);
    SCL_ClrVal();                /* CLOCK LOW PULSE */
    Delay();
  }
  *Chr = Read();
%if defined(OnRxChar)
  %OnRxChar();
%endif
  SetAck((bool)NOACK);
  return ERR_OK;
}

%endif %- RecvChar
%-BW_METHOD_END RecvChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendBlock
%ifdef SendBlock
%define! ParPtr
%define! ParSiz
%define! ParSnt
%define! RetVal
%include Common\GenericSWI2CSendBlock.Inc
byte %'ModuleName'%.%SendBlock(void *Ptr, word Siz, word *Snt)
{
  register word I;
  bool Acknowledge;
  word Trial;
  word timeout;

  *Snt = 0U;
  Trial = TRIALS;
  do {
    SDA_SetDir((bool)INPUT);     /* SDA HIGH  - START SETUP */
    SCL_SetDir((bool)INPUT);     /* CLOCK HIGH PULSE */
    Delay();                     /* CLOCK HIGH PULSE + BUS FREE TIME */
    /* check that we have a valid start condition: SDA needs to be high */
    timeout = 65535U;
    while((SDA_GetVal()==0U)&&(timeout!=0U)) { /* WAIT FOR CLOCK HIGH PULSE */
      timeout--;
      %'ModuleName'%.OSYIELD();
    }
    Delay();
    if (timeout==0) {
      return ERR_BUSY;
    }
    SDA_SetDir((bool)OUTPUT);
    SDA_ClrVal();                /* START CONDITION */
    Delay();                     /* START HOLD TIME */
    SCL_SetDir((bool)OUTPUT);
    SCL_ClrVal();                /* CLOCK LOW PULSE */
    Delay();
    Write((byte)(SlaveAddr + WRITE));
    Acknowledge = GetAck();
    --Trial;
  } while ((Trial != 0U) && Acknowledge);
  if (Acknowledge) {
%if defined(OnNACK)
    %OnNACK();
%endif
    return ERR_BUSY;
  } else {
    SCL_SetDir((bool)OUTPUT);
    SCL_ClrVal();                /* CLOCK LOW PULSE */
    Delay();
  }
  for (I = 0U; I < Siz; I++) {
    Write (*((const byte*)Ptr + I) );
    if (GetAck()) {
%if defined(OnNACK)
      %OnNACK();
%endif
      SCL_SetDir((bool)OUTPUT);
      SCL_ClrVal();              /* CLOCK LOW PULSE */
      InternalStop();
      return ERR_BUSY;
    } else {
%if defined(OnTxChar)
      %OnTxChar();
%endif
      SCL_SetDir((bool)OUTPUT);
      SCL_ClrVal();              /* CLOCK LOW PULSE */
      Delay();
    }
    ++(*Snt);
  }
  Delay();
  timeout = 65535U;
  while((SDA_GetVal()==0U)&&(timeout!=0U)) { /* WAIT FOR CLOCK HIGH PULSE */
    timeout--;
    %'ModuleName'%.OSYIELD();
  }
  if (timeout==0) {
    return ERR_BUSY;
  }
  return ERR_OK;
}

%endif %- SendBlock
%-BW_METHOD_END SendBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendBlockContinue
%ifdef SendBlockContinue
%define! ParPtr
%define! ParSiz
%define! ParSnt
%define! RetVal
%include Common\GenericSWI2CSendBlockContinue.Inc
byte %'ModuleName'%.%SendBlockContinue(void *Ptr, word Siz, word *Snt)
{
  register word I;
  word Trial;
  word timeout;

  *Snt = 0U;
  Trial = TRIALS;
  for (I = 0U; I < Siz; I++) {
    Write (*((const byte*)Ptr + I) );
    if (GetAck()) {
%if defined(OnNACK)
      %OnNACK();
%endif
      SCL_SetDir((bool)OUTPUT);
      SCL_ClrVal();              /* CLOCK LOW PULSE */
      InternalStop();
      return ERR_BUSY;
    } else {
      SCL_SetDir((bool)OUTPUT);
      SCL_ClrVal();              /* CLOCK LOW PULSE */
      Delay();
    }
    ++(*Snt);
  }
  Delay();
  timeout = 65535U;
  while((SDA_GetVal()==0U)&&(timeout!=0U)) { /* WAIT FOR CLOCK HIGH PULSE */
    timeout--;
    %'ModuleName'%.OSYIELD();
  }
  if (timeout==0) {
    return ERR_BUSY;
  }
  return ERR_OK;
}

%endif %- SendBlockContinue
%-BW_METHOD_END SendBlockContinue
%-************************************************************************************************************
%-BW_METHOD_BEGIN RecvBlock
%ifdef RecvBlock
%define! ParPtr
%define! ParSiz
%define! ParRcv
%define! RetVal
%include Common\GenericSWI2CRecvBlock.Inc
byte %'ModuleName'%.%RecvBlock(void *Ptr, word Siz, word *Rcv)
{
  register word I;
  bool Acknowledge;
  word Trial;
  word timeout;

  *Rcv = 0U;
  Trial = TRIALS;
  do {
    SDA_SetDir((bool)INPUT);     /* SDA HIGH - START SETUP */
    SCL_SetDir((bool)INPUT);     /* CLOCK HIGH PULSE */
    Delay();                     /* CLOCK HIGH PULSE + BUS FREE TIME */
    /* check that we have a valid start condition: SDA needs to be high */
    timeout = 65535U;
    while((SDA_GetVal()==0U)&&(timeout!=0U)) { /* WAIT FOR CLOCK HIGH PULSE */
      timeout--;
      %'ModuleName'%.OSYIELD();
    }
    Delay();
    if (timeout==0) {
      /* InternalStop(); */
      return ERR_BUSY;
    }
    SDA_SetDir((bool)OUTPUT);
    SDA_ClrVal();                /* START CONDITION */
    Delay();                     /* START HOLD TIME */
    SCL_SetDir((bool)OUTPUT);
    SCL_ClrVal();                /* CLOCK LOW PULSE */
    Delay();
    Write((byte)(SlaveAddr + READ));
    Acknowledge = GetAck();
    --Trial;
  } while ((Trial != 0U) && Acknowledge);
  if (Acknowledge) {
%if defined(OnNACK)
    %OnNACK();
%endif
    /* SCL_SetDir((bool)OUTPUT); */
    /* SCL_ClrVal(); */               /* CLOCK LOW PULSE */
    /* InternalStop(); */
    return ERR_BUSY;
  } else {
    SCL_SetDir((bool)OUTPUT);
    SCL_ClrVal();                /* CLOCK LOW PULSE */
    Delay();
  }
  for (I = 0U; I < Siz; I++) {
    *((byte *)Ptr + I) = Read();
%if defined(OnRxChar)
    %OnRxChar();
%endif
    timeout = 65535U;
    while((SDA_GetVal()==0U)&&(timeout!=0U)) { /* WAIT FOR CLOCK HIGH PULSE */
      timeout--;
      %'ModuleName'%.OSYIELD();
    }
    if (timeout==0) {
      /* InternalStop(); */
      return ERR_BUSY;
    }
    if (I == (Siz - 1U)) {
      SetAck((bool)NOACK);
    } else {
      SetAck((bool)ACK);
    }
    ++(*Rcv);
  }
  return ERR_OK;
}

%endif %- RecvBlock
%-BW_METHOD_END RecvBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendStop
%ifdef SendStop
%define! RetVal
%include Common\GenericSWI2CSendStop.Inc
byte %'ModuleName'%.%SendStop(void)
{
  Delay();
  SDA_SetDir((bool)OUTPUT);
  SDA_ClrVal();                  /* STOP SETUP */
  Delay();
  SCL_SetDir((bool)INPUT);       /* HIGH CLOCK PULSE + STOP SETUP TIME */
  Delay();
  SDA_SetDir((bool)INPUT);       /* STOP CONDITION */
  Delay(); /* add stop time */
  return ERR_OK;
}

%endif %- SendStop
%-BW_METHOD_END SendStop
%-************************************************************************************************************
%-BW_METHOD_BEGIN SelectSlave
%ifdef SelectSlave
%define! ParSlv
%define! RetVal
%include Common\GenericSWI2CSelectSlave.Inc
byte %'ModuleName'%.%SelectSlave(byte Slv)
{
  SlaveAddr = (byte)(Slv<<1);
  return ERR_OK;
}

%endif %- SelectSlave
%-BW_METHOD_END SelectSlave
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetSelected
%ifdef GetSelected
%define! ParSlv
%define! RetVal
%include Common\GenericSWI2CGetSelected.Inc
byte %'ModuleName'%.%GetSelected(byte *Slv)
{
  *Slv = (byte)(SlaveAddr>>1);
  return ERR_OK;
}

%endif %- GetSelected
%-BW_METHOD_END GetSelected
%-************************************************************************************************************
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_METHOD_BEGIN OnNACK
%ifdef OnNACK
%IMPLEMENTATION OnNACK
%include Common\GenericSWI2COnNACK.Inc
void %OnNACK(void)
{
  /* Write your code here ... */
}

%endif %- OnNACK
%-BW_METHOD_END OnNACK
%-BW_METHOD_BEGIN OnTxChar
%ifdef OnTxChar
%IMPLEMENTATION OnTxChar
%include Common\GenericSWI2COnTxChar.Inc
void %OnTxChar(void)
{
  /* Write your code here ... */
}

%endif %- OnTxChar
%-BW_METHOD_END OnTxChar
%-BW_METHOD_BEGIN OnRxChar
%ifdef OnRxChar
%IMPLEMENTATION OnRxChar
%include Common\GenericSWI2COnRxChar.Inc
void %OnRxChar(void)
{
  /* Write your code here ... */
}

%endif %- OnRxChar
%-BW_METHOD_END OnRxChar
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
  %'ModuleName'%.%Init();
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This component is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
