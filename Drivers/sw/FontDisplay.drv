%-Driver generated by the Bean Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Bean Wizard
%- If you change these lines, Bean Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Damian Schmid
%define DriverVersion 01.00
%define DriverDate    27.11.2008
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\FontDisplaySettings.Inc
%define! Abstract Common\FontDisplayAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"

typedef %@GDisplay@'ModuleName'%.PixelDim   %'ModuleName'%.PixelDim;%>40/* type which can hold a integral type for the x/y pixel dimension. This is depending on the display used. */
typedef %@GDisplay@'ModuleName'%.PixelColor %'ModuleName'%.PixelColor;%>40/* Type definining the color type (depens on display used). */
typedef GFONT_Callbacks %'ModuleName'%.Font;                     %>40/* Pointer to GFONT_Callbacks */

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
%-BW_CUSTOM_USERTYPE_END


%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteString
%ifdef WriteString
void %'ModuleName'%.%WriteString(byte *str, %'ModuleName'_PixelColor color, %'ModuleName'_PixelDim *xCursor, %'ModuleName'_PixelDim *yCursor, %'ModuleName'_Font *font);
%define! Parstr
%define! Parcolor
%define! ParxCursor
%define! ParyCursor
%define! Parfont
%include Common\FontDisplayWriteString.Inc

%endif %- WriteString
%-BW_METHOD_END WriteString
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteChar
%ifdef WriteChar
void %'ModuleName'%.%WriteChar(byte ch, %'ModuleName'_PixelColor color, %'ModuleName'_PixelDim *xCursor, %'ModuleName'_PixelDim *yCursor, %'ModuleName'_Font *font);
%define! Parcolor
%define! Parch
%define! ParxCursor
%define! ParyCursor
%define! Parfont
%include Common\FontDisplayWriteChar.Inc

%endif %- WriteChar
%-BW_METHOD_END WriteChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetCharWidth
%ifdef GetCharWidth
void %'ModuleName'%.%GetCharWidth(byte ch, %'ModuleName'_PixelDim *charWidth, %'ModuleName'_PixelDim *totalWidth, %'ModuleName'_Font *font);
%define! ParcharWidth
%define! PartotalWidth
%define! Parfont
%define! Parch
%include Common\FontDisplayGetCharWidth.Inc

%endif %- GetCharWidth
%-BW_METHOD_END GetCharWidth
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetStringWidth
%ifdef GetStringWidth
%'ModuleName'_PixelDim %'ModuleName'%.%GetStringWidth(byte *str, %'ModuleName'_Font *font, %'ModuleName'_PixelDim *lastCharSpace);
%define! Parstr
%define! Parfont
%define! ParlastCharSpace
%define! RetVal
%include Common\FontDisplayGetStringWidth.Inc

%endif %- GetStringWidth
%-BW_METHOD_END GetStringWidth
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetFontHeight
%ifdef GetFontHeight
void %'ModuleName'%.%GetFontHeight(%'ModuleName'_Font *font, %'ModuleName'_PixelDim *charHeight, %'ModuleName'_PixelDim *totalHeight);
%define! ParcharHeight
%define! PartotalHeight
%define! Parfont
%include Common\FontDisplayGetFontHeight.Inc

%endif %- GetFontHeight
%-BW_METHOD_END GetFontHeight
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetStringHeight
%ifdef GetStringHeight
%'ModuleName'_PixelDim %'ModuleName'%.%GetStringHeight(byte *str, %'ModuleName'_Font *font, %'ModuleName'_PixelDim *lastLineSpace);
%define! Parstr
%define! Parfont
%define! ParlastLineSpace
%define! RetVal
%include Common\FontDisplayGetStringHeight.Inc

%endif %- GetStringHeight
%-BW_METHOD_END GetStringHeight
%-************************************************************************************************************
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\FontDisplaySettings.Inc
%define! Abstract Common\FontDisplayAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
#include <stddef.h> /* for NULL */
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%-
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteChar
%ifdef WriteChar
%define! Parcolor
%define! Parch
%define! ParxCursor
%define! ParyCursor
%define! Parfont
%include Common\FontDisplayWriteChar.Inc
void %'ModuleName'%.%WriteChar(byte ch, %'ModuleName'_PixelColor color, %'ModuleName'_PixelDim *xCursor, %'ModuleName'_PixelDim *yCursor, %'ModuleName'_Font *font)
{
  PGFONT_CharInfo charStruct;                                    %>40/* font information */
  byte *data;                                                    %>40/* actual character of string text[] */
  byte w;                                                        %>40/* counter variable row bits of character */
  byte h;                                                        %>40/* counter variable column bits of character */
  %'ModuleName'%.PixelDim currY;
  %'ModuleName'%.PixelDim currX;
  signed char b;                                                 %>40/* bit position in byte stream */

  if (ch=='\t') {                                                %>40/* tabulator */
   ch = ' ';                                                     %>40/* use a space instead */
  }
  charStruct = font->GetFontChar((byte)ch);
  if (ch=='\n') {                                                %>40/* move to a new line */
   *yCursor += font->boundingBoxHeight;                          %>40/* set next cursor position */
   return;
  }
  if (ch=='\r') {                                                %>40/* move to beginning of line */
   return;                                                       %>40/* do nothing. Only the caller may know what the beginning of line is */
  }
  data = (byte*)charStruct->CharBMP;                             %>40/* get the pointer */
  if (data != NULL) {                                            %>40/* printable character. Only if we have a character info. This is not the case e.g. for \n */
    currY =  (%'ModuleName'%.PixelDim)(*yCursor
           + font->boundingBoxHeight                             %>40/* height of box. This includes the space between lines plus the space under the base line */
           - font->lineSpaceBoxHeight                            %>40/* space between two lines */
           - font->underlineBoxHeight                            %>40/* space below the base line */
           - charStruct->offsetY
           - charStruct->height);
    currX = (%'ModuleName'%.PixelDim)(*xCursor + charStruct->offsetX);
    h = 0;
    for(;;) {                                                    %>40/* breaks, process line by line */
      w = 0;                                                     %>40/* width position */
      b = 7;                                                     %>40/* bit position, MSB first */
      for(;;) {                                                  %>40/* breaks, prints one pixel line */
        if ((((*data)&(1<<b))>>b)==1) { /* note that we do not change the background pixels */
          %@GDisplay@'ModuleName'%.PutPixel((%'ModuleName'%.PixelDim)(currX+w), currY, color);
        }
        w++;                                                     %>40/* width counter */
        b--;                                                     %>40/* next pixel */
        if((b==-1)||(w==charStruct->width)) {                    %>40/* last bit of byte reached or last bit of the width reached */
          if(w==charStruct->width) {                             %>40/* last bit of the row from the current character */
            break;                                               %>40/* out of while loop */
          } else {
            b = 7;
            data++;                                              %>40/* next byte */
          }
        }
      } /* for */
      %if WatchdogEnabled='yes'
      %@Watchdog@'ModuleName'%.Clear();                          %>40/* kick the dog */
      %endif
      data++;                                                    %>40/* next byte */
      h++;                                                       %>40/* height counter increment */
      currY++;                                                   %>40/* one row up */
      if(h==(charStruct->height)){                               %>40/* finished character */
        break;
      }                                                          %>40/* next row of character */
    } /* for */
    *xCursor += charStruct->dwidth;                              %>40/* set next cursor position */
  } /* if printable character */
}

%endif %- WriteChar
%-BW_METHOD_END WriteChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteString
%ifdef WriteString
%define! Parstr
%define! Parcolor
%define! ParxCursor
%define! ParyCursor
%define! Parfont
%include Common\FontDisplayWriteString.Inc
void %'ModuleName'%.%WriteString(byte *str, %'ModuleName'_PixelColor color, %'ModuleName'_PixelDim *xCursor, %'ModuleName'_PixelDim *yCursor, %'ModuleName'_Font *font)
{
  %'ModuleName'_PixelDim x = *xCursor;

  while(*str!='\0') {
    if (*str=='\r') {
      *xCursor = x;
    } else if (*str=='\n') {
      *xCursor = x;
      *yCursor += font->boundingBoxHeight;
    } else {
      %'ModuleName'%.%WriteChar(*str, color, xCursor, yCursor, font);
    }
    str++;
  }
}

%endif %- WriteString
%-BW_METHOD_END WriteString
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetCharWidth
%ifdef GetCharWidth
%define! ParcharWidth
%define! PartotalWidth
%define! Parfont
%define! Parch
%include Common\FontDisplayGetCharWidth.Inc
void %'ModuleName'%.%GetCharWidth(byte ch, %'ModuleName'_PixelDim *charWidth, %'ModuleName'_PixelDim *totalWidth, %'ModuleName'_Font *font)
{
  PGFONT_CharInfo charStruct;

  charStruct = font->GetFontChar((byte)ch);
  if (charStruct != NULL) {
    *charWidth = (%'ModuleName'_PixelDim)(charStruct->width+charStruct->offsetX);
    *totalWidth = (%'ModuleName'_PixelDim)charStruct->dwidth;
  } else {
    *charWidth = 0;
    *totalWidth = 0;
  }
}

%endif %- GetCharWidth
%-BW_METHOD_END GetCharWidth
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetStringWidth
%ifdef GetStringWidth
%define! Parstr
%define! Parfont
%define! ParlastCharSpace
%define! RetVal
%include Common\FontDisplayGetStringWidth.Inc
%'ModuleName'_PixelDim %'ModuleName'%.%GetStringWidth(byte *str, %'ModuleName'_Font *font, %'ModuleName'_PixelDim *lastCharSpace)
{
  unsigned char *p;                                              %>40/* pointer to the actual character */
  %'ModuleName'_PixelDim currWidth;                              %>40/* current width of string */
  %'ModuleName'_PixelDim maxWidth;                               %>40/* maximum width of string */
  %'ModuleName'_PixelDim maxWidthSpace;                          %>40/* last space of maximum string */
  %'ModuleName'_PixelDim charSpace;                              %>40/* last character space */
  %'ModuleName'_PixelDim charWidth, totalWidth;                  %>40/* character and total width of character */

  currWidth = maxWidth = 0;
  charWidth = totalWidth = 0;
  charSpace = maxWidthSpace = 0;
  p = str;
  for (;;) {                                                     %>40/* breaks */
    if (*p=='\n' || *p=='\r' || *p=='\0') {                      %>40/* multi-line string */
      currWidth -= charSpace;                                    %>40/* subtract last space */
      if (currWidth > maxWidth) {                                %>40/* remember maximum line */
        maxWidth = currWidth;
        maxWidthSpace = charSpace;
      }
      currWidth = charSpace = 0;
      if (*p == '\0') {
        break;
      }
    } else {
      %'ModuleName'%.%GetCharWidth(*p, &charWidth, &totalWidth, font);
      currWidth += totalWidth;
      charSpace = (%'ModuleName'_PixelDim)(totalWidth-charWidth);%>40/* calculate space of last/current character */
    }
    p++;                                                         %>40/* next character */
  } /* for */
  if (lastCharSpace != NULL) {
    *lastCharSpace = maxWidthSpace;
  }
  return maxWidth;                                               %>40/* return width */
}

%endif %- GetStringWidth
%-BW_METHOD_END GetStringWidth
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetFontHeight
%ifdef GetFontHeight
%define! ParcharHeight
%define! PartotalHeight
%define! Parfont
%include Common\FontDisplayGetFontHeight.Inc
void %'ModuleName'%.%GetFontHeight(%'ModuleName'_Font *font, %'ModuleName'_PixelDim *charHeight, %'ModuleName'_PixelDim *totalHeight)
{
  *charHeight = (%'ModuleName'_PixelDim)(font->boundingBoxHeight-font->lineSpaceBoxHeight);
  *totalHeight = font->boundingBoxHeight;
}

%endif %- GetFontHeight
%-BW_METHOD_END GetFontHeight
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetStringHeight
%ifdef GetStringHeight
%define! Parstr
%define! Parfont
%define! ParlastLineSpace
%define! RetVal
%include Common\FontDisplayGetStringHeight.Inc
%'ModuleName'_PixelDim %'ModuleName'%.%GetStringHeight(byte *str, %'ModuleName'_Font *font, %'ModuleName'_PixelDim *lastLineSpace)
{
  word nofLines;
  %'ModuleName'_PixelDim charHeight, totalHeight;

  if (*str == '\0') {
    if (lastLineSpace != NULL) {
      *lastLineSpace = 0;
    }
    return 0;
  }
  nofLines = 1;
  while (*str != '\0') {                                         %>40/* breaks */
    if (*str=='\n') {                                            %>40/* multi-line string */
      nofLines++;
    }
    str++;                                                       %>40/* next character */
  }
  %'ModuleName'%.%GetFontHeight(font, &charHeight, &totalHeight);
  if (lastLineSpace != NULL) {
    *lastLineSpace = (%'ModuleName'_PixelDim)(totalHeight-charHeight);
  }
  return (%'ModuleName'_PixelDim)((nofLines-1)*totalHeight + charHeight);%>40/* return height */
}

%endif %- GetStringHeight
%-BW_METHOD_END GetStringHeight
%-************************************************************************************************************
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This bean is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
