%-Driver generated by the Bean Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Bean Wizard
%- If you change these lines, Bean Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    21.07.2009
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%include FatFS_Files.prg
%-
%INTERFACE
%define! Settings Common\FAT_FileSystemSettings.Inc
%define! Abstract Common\FAT_FileSystemAbstract.Inc
%include Common\Header.h

/* Wrappers to FatFS types and constants */
#define %'ModuleName'%.FATFS            FATFS
#define %'ModuleName'%.DIR              DIR
#define %'ModuleName'%.FIL              FIL
#define %'ModuleName'%.FILINFO          FILINFO
#define %'ModuleName'%.FS_READONLY      _FS_READONLY
#define %'ModuleName'%.USE_LFN          _USE_LFN
#define %'ModuleName'%.MAX_LFN          _MAX_LFN
#define %'ModuleName'%.FS_REENTRANT     _FS_REENTRANT
#define %'ModuleName'%.MAX_SS           _MAX_SS
#define %'ModuleName'%.FS_RPATH         _FS_RPATH
#define %'ModuleName'%.FRESULT          FRESULT
#define %'ModuleName'%.DRESULT          DRESULT

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
#include "ff.h"
#include "diskio.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"
%include sw\CommonSupport.prg

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

#ifndef __BWUserType_%'ModuleName'_CHARP
#define __BWUserType_%'ModuleName'_CHARP
  typedef char * %'ModuleName'%.CHARP;                           %>40/* alias to a char pointer */
#endif
#ifndef __BWUserType_%'ModuleName'_INT
#define __BWUserType_%'ModuleName'_INT
  typedef int %'ModuleName'%.INT;                                %>40/* alias to int type. */
#endif

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%ifdef ParseCommand
#define %'ModuleName'%.PARSE_COMMAND_ENABLED  1  /* set to 1 if method ParseCommand() is present, 0 otherwise */
%else
#define %'ModuleName'%.PARSE_COMMAND_ENABLED  0 /* set to 1 if method ParseCommand() is present, 0 otherwise */
%endif %- ParseCommand

%-BW_CUSTOM_USERTYPE_END


%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN open
%ifdef open
#define %'ModuleName'%.%open(fp, path, mode) \
  f_open(fp, path, mode)
%define! Parfp
%define! Parpath
%define! Parmode
%define! RetVal
%include Common\FAT_FileSystemopen.Inc

%endif %- open
%-BW_METHOD_END open
%-************************************************************************************************************
%-BW_METHOD_BEGIN close
%ifdef close
#define %'ModuleName'%.%close(fp) \
  f_close(fp)

%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemclose.Inc

%endif %- close
%-BW_METHOD_END close
%-************************************************************************************************************
%-BW_METHOD_BEGIN read
%ifdef read
#define %'ModuleName'%.%read(fp, buff, btr, br) \
  f_read(fp, buff, btr, br)

%define! Parfp
%define! Parbuff
%define! Parbtr
%define! Parbr
%define! RetVal
%include Common\FAT_FileSystemread.Inc

%endif %- read
%-BW_METHOD_END read
%-************************************************************************************************************
%-BW_METHOD_BEGIN write
%ifdef write
#define %'ModuleName'%.%write(fp, buff, btw, bw) \
  f_write(fp, buff, btw, bw)

%define! Parfp
%define! Parbuff
%define! Parbtw
%define! Parbw
%define! RetVal
%include Common\FAT_FileSystemwrite.Inc

%endif %- write
%-BW_METHOD_END write
%-************************************************************************************************************
%-BW_METHOD_BEGIN opendir
%ifdef opendir
#define %'ModuleName'%.%opendir(dj, path) \
  f_opendir(dj, path)

%define! Pardj
%define! Parpath
%define! RetVal
%include Common\FAT_FileSystemopendir.Inc

%endif %- opendir
%-BW_METHOD_END opendir
%-************************************************************************************************************
%-BW_METHOD_BEGIN readdir
%ifdef readdir
#define %'ModuleName'%.%readdir(dj, fno) \
  f_readdir(dj, fno)

%define! Pardir
%define! Parfno
%define! RetVal
%include Common\FAT_FileSystemreaddir.Inc

%endif %- readdir
%-BW_METHOD_END readdir
%-************************************************************************************************************
%-BW_METHOD_BEGIN lseek
%ifdef lseek
#define %'ModuleName'%.%lseek(fp, ofs) \
  f_lseek(fp, ofs)

%define! Parfp
%define! Parofs
%define! RetVal
%include Common\FAT_FileSystemlseek.Inc

%endif %- lseek
%-BW_METHOD_END lseek
%-************************************************************************************************************
%-BW_METHOD_BEGIN unlink
%ifdef unlink
#define %'ModuleName'%.%unlink(path) \
  f_unlink(path)

%define! Parpath
%define! RetVal
%include Common\FAT_FileSystemunlink.Inc

%endif %- unlink
%-BW_METHOD_END unlink
%-************************************************************************************************************
%-BW_METHOD_BEGIN mount
%ifdef mount
#define %'ModuleName'%.%mount(vol, fs) \
  f_mount(vol, fs)

%define! Parvol
%define! Parfs
%define! RetVal
%include Common\FAT_FileSystemmount.Inc

%endif %- mount
%-BW_METHOD_END mount
%-************************************************************************************************************
%-BW_METHOD_BEGIN getfree
%ifdef getfree
#define %'ModuleName'%.getfree(path, nclst, fs) f_getfree(path, nclst, fs)
%define! Parpath
%define! Parnclst
%define! Parfatfs
%define! RetVal
%include Common\FAT_FileSystemgetfree.Inc

%endif %- getfree
%-BW_METHOD_END getfree
%-************************************************************************************************************
%-BW_METHOD_BEGIN sync
%ifdef sync
#define %'ModuleName'%.%sync(fp) \
  f_sync(fp)

%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemsync.Inc

%endif %- sync
%-BW_METHOD_END sync
%-************************************************************************************************************
%-BW_METHOD_BEGIN rename
%ifdef rename
#define %'ModuleName'%.%rename(path_old, path_new) \
  f_rename(path_old, path_new)
%define! Parpath_old
%define! Parpath_new
%define! RetVal
%include Common\FAT_FileSystemrename.Inc

%endif %- rename
%-BW_METHOD_END rename
%-************************************************************************************************************
%-BW_METHOD_BEGIN isWriteProtected
%ifdef isWriteProtected
#define %'ModuleName'%.%isWriteProtected() \
%if WriteEnabled='no'
  %'ModuleName'%.FS_READONLY
%else
  %@Memory@'ModuleName'%.isWriteProtected()
%endif

%define! RetVal
%include Common\FAT_FileSystemisWriteProtected.Inc

%endif %- isWriteProtected
%-BW_METHOD_END isWriteProtected
%-************************************************************************************************************
%-BW_METHOD_BEGIN mkdir
%ifdef mkdir
#define %'ModuleName'%.%mkdir(path) \
  f_mkdir(path)
%define! Parpath
%define! RetVal
%include Common\FAT_FileSystemmkdir.Inc

%endif %- mkdir
%-BW_METHOD_END mkdir
%-************************************************************************************************************
%-BW_METHOD_BEGIN chmod
%ifdef chmod
#define %'ModuleName'%.%chmod(FileName, Attribute, AttributeMask) \
  f_chmod(FileName, Attribute, AttributeMask)

%define! ParFileName
%define! ParAttribute
%define! ParAttributeMask
%define! RetVal
%include Common\FAT_FileSystemchmod.Inc

%endif %- chmod
%-BW_METHOD_END chmod
%-************************************************************************************************************
%-BW_METHOD_BEGIN truncate
%ifdef truncate
#define %'ModuleName'%.%truncate(FILP) \
  f_truncate(FILP)

%define! ParFileObject
%define! RetVal
%include Common\FAT_FileSystemtruncate.Inc

%endif %- truncate
%-BW_METHOD_END truncate
%-************************************************************************************************************
%-BW_METHOD_BEGIN stat
%ifdef stat
#define %'ModuleName'%.%stat(FileName, FileInfo) \
  f_stat(FileName, FileInfo)

%define! ParFileName
%define! ParFileInfo
%define! RetVal
%include Common\FAT_FileSystemstat.Inc

%endif %- stat
%-BW_METHOD_END stat
%-************************************************************************************************************
%-BW_METHOD_BEGIN utime
%ifdef utime
#define %'ModuleName'%.%utime(FileName, TimeDate) \
  f_utime(FileName, TimeDate)

%define! ParFileName
%define! ParTimeDate
%define! RetVal
%include Common\FAT_FileSystemutime.Inc

%endif %- utime
%-BW_METHOD_END utime
%-************************************************************************************************************
%-BW_METHOD_BEGIN mkfs
%ifdef mkfs
#define %'ModuleName'%.%mkfs(drive, PartitioningRule, AllocSize) \
  f_mkfs(drive, PartitioningRule, AllocSize)

%define! Pardrive
%define! ParPartitioningRule
%define! ParAllocSize
%define! RetVal
%include Common\FAT_FileSystemmkfs.Inc

%endif %- mkfs
%-BW_METHOD_END mkfs
%-************************************************************************************************************
%-BW_METHOD_BEGIN forward
%ifdef forward
#define %'ModuleName'%.%forward(FileObject, Func, ByteToFwd, ByteFwd) \
  f_forward(FileObject, Func, ByteToFwd, ByteFwd)

%define! ParFileObject
%define! ParFunc
%define! ParByteToFwd
%define! ParByteFwd
%define! RetVal
%include Common\FAT_FileSystemforward.Inc

%endif %- forward
%-BW_METHOD_END forward
%-************************************************************************************************************
%-BW_METHOD_BEGIN chdir
%ifdef chdir
#define %'ModuleName'%.%chdir(Path) \
  f_chdir(Path)

%define! ParPath
%define! RetVal
%include Common\FAT_FileSystemchdir.Inc

%endif %- chdir
%-BW_METHOD_END chdir
%-************************************************************************************************************
%-BW_METHOD_BEGIN chdrive
%ifdef chdrive
#define %'ModuleName'%.%chdrive(Drive) \
  f_chdrive(Drive)

%define! ParDrive
%define! RetVal
%include Common\FAT_FileSystemchdrive.Inc

%endif %- chdrive
%-BW_METHOD_END chdrive
%-************************************************************************************************************
%-BW_METHOD_BEGIN getcwd
%ifdef getcwd
#define %'ModuleName'%.%getcwd(Buffer, BufferLen) \
  f_getcwd(Buffer, BufferLen)

%define! ParBuffer
%define! ParBufferLen
%define! RetVal
%include Common\FAT_FileSystemgetcwd.Inc

%endif %- getcwd
%-BW_METHOD_END getcwd
%-************************************************************************************************************
%-BW_METHOD_BEGIN errFResultMsg
%ifdef errFResultMsg
char* %'ModuleName'%.%errFResultMsg(int errNo);
%define! ParerrNo
%define! RetVal
%include Common\FAT_FileSystemerrFResultMsg.Inc

%endif %- errFResultMsg
%-BW_METHOD_END errFResultMsg
%-************************************************************************************************************
%-BW_METHOD_BEGIN errDResultMsg
%ifdef errDResultMsg
char* %'ModuleName'%.%errDResultMsg(int errNo);
%define! ParerrNo
%define! RetVal
%include Common\FAT_FileSystemerrDResultMsg.Inc

%endif %- errDResultMsg
%-BW_METHOD_END errDResultMsg
%-************************************************************************************************************
%-BW_METHOD_BEGIN isDiskPresent
%ifdef isDiskPresent
#define %'ModuleName'%.%isDiskPresent() \
  %@Memory@'ModuleName'%.CardPresent()

%define! RetVal
%include Common\FAT_FileSystemisDiskPresent.Inc

%endif %- isDiskPresent
%-BW_METHOD_END isDiskPresent
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_gets
%ifdef f_gets
#define %'ModuleName'%.%f_gets(buff, len, fil) \
  f_gets(buff,len,fil)

%define! Parbuff
%define! Parlen
%define! Parfil
%define! RetVal
%include Common\FAT_FileSystemf_gets.Inc

%endif %- f_gets
%-BW_METHOD_END f_gets
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_puts
%ifdef f_puts
#define %'ModuleName'%.%f_puts(str, fil) \
  f_puts(str, fil)

%define! Parbuff
%define! Parfil
%define! RetVal
%include Common\FAT_FileSystemf_puts.Inc

%endif %- f_puts
%-BW_METHOD_END f_puts
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_putc
%ifdef f_putc
#define %'ModuleName'%.%f_putc(c, fil) \
  f_putc(c, fil)

%define! Parbuff
%define! Parfil
%define! RetVal
%include Common\FAT_FileSystemf_putc.Inc

%endif %- f_putc
%-BW_METHOD_END f_putc
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_printf
%ifdef f_printf
#define %'ModuleName'%.%f_printf \
  f_printf

%define! ParVariable_1
%define! Parstr
%define! ParVariable_2
%define! RetVal
%include Common\FAT_FileSystemf_printf.Inc

%endif %- f_printf
%-BW_METHOD_END f_printf
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_eof
%ifdef f_eof
#define %'ModuleName'%.%f_eof(fp) \
  f_eof(fp)

%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemf_eof.Inc

%endif %- f_eof
%-BW_METHOD_END f_eof
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_error
%ifdef f_error
#define %'ModuleName'%.%f_error(fp) \
  f_error(fp)

%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemf_error.Inc

%endif %- f_error
%-BW_METHOD_END f_error
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_tell
%ifdef f_tell
#define %'ModuleName'%.%f_tell(fp) \
  f_tell(fp)

%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemf_tell.Inc

%endif %- f_tell
%-BW_METHOD_END f_tell
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_size
%ifdef f_size
#define %'ModuleName'%.%f_size(fp) \
  f_size(fp)

%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemf_size.Inc

%endif %- f_size
%-BW_METHOD_END f_size
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
byte %'ModuleName'%.%Init(void);
%define! RetVal
%include Common\FAT_FileSystemInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
void %'ModuleName'%.%Deinit(void);
%include Common\FAT_FileSystemDeinit.Inc

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN get_fattime
%ifdef get_fattime
uint32_t %'ModuleName'%.%get_fattime(void);
%define! RetVal
%include Common\FAT_FileSystemget_fattime.Inc

%endif %- get_fattime
%-BW_METHOD_END get_fattime
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
byte %'ModuleName'%.%ParseCommand(const unsigned char *cmd, bool *handled, const %@Shell@'ModuleName'%.StdIOType *io);
%define! Parcmd
%define! Parhandled
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemParseCommand.Inc

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN CheckCardPresence
%ifdef CheckCardPresence
byte %'ModuleName'%.%CheckCardPresence(bool *cardMounted, byte drive, FATFS *fileSystemObject, const %@Shell@'ModuleName'%.StdIOType *io);
%define! ParcardMounted
%define! Pardrive
%define! ParfileSystemObject
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemCheckCardPresence.Inc

%endif %- CheckCardPresence
%-BW_METHOD_END CheckCardPresence
%-************************************************************************************************************
%-BW_METHOD_BEGIN MountFileSystem
%ifdef MountFileSystem
byte %'ModuleName'%.%MountFileSystem(FATFS *fileSystemObject, byte logicalDrive, const %@Shell@'ModuleName'%.StdIOType *io);
%define! ParfileSystemObject
%define! ParlogicalDrive
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemMountFileSystem.Inc

%endif %- MountFileSystem
%-BW_METHOD_END MountFileSystem
%-************************************************************************************************************
%-BW_METHOD_BEGIN UnMountFileSystem
%ifdef UnMountFileSystem
byte %'ModuleName'%.%UnMountFileSystem(byte logicalDrive, const %@Shell@'ModuleName'%.StdIOType *io);
%define! ParlogicalDrive
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemUnMountFileSystem.Inc

%endif %- UnMountFileSystem
%-BW_METHOD_END UnMountFileSystem
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintDirectory
%ifdef PrintDirectory
byte %'ModuleName'%.%PrintDirectory(const byte *dirName, const %@Shell@'ModuleName'%.StdIOType *io);
%define! PardirName
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemPrintDirectory.Inc

%endif %- PrintDirectory
%-BW_METHOD_END PrintDirectory
%-************************************************************************************************************
%-BW_METHOD_BEGIN CopyFile
%ifdef CopyFile
byte %'ModuleName'%.%CopyFile(const byte *srcFileName, const byte *dstFileName, const %@Shell@'ModuleName'%.StdIOType *io);
%define! ParsrcFileName
%define! PardstFileName
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemCopyFile.Inc

%endif %- CopyFile
%-BW_METHOD_END CopyFile
%-************************************************************************************************************
%-BW_METHOD_BEGIN DeleteFile
%ifdef DeleteFile
byte %'ModuleName'%.%DeleteFile(const byte *fileName, const %@Shell@'ModuleName'%.StdIOType *io);
%define! ParfileName
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemDeleteFile.Inc

%endif %- DeleteFile
%-BW_METHOD_END DeleteFile
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintFile
%ifdef PrintFile
byte %'ModuleName'%.%PrintFile(const byte *fileName, const %@Shell@'ModuleName'%.StdIOType *io);
%define! ParfileName
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemPrintFile.Inc

%endif %- PrintFile
%-BW_METHOD_END PrintFile
%-************************************************************************************************************
%-BW_METHOD_BEGIN MakeDirectory
%ifdef MakeDirectory
byte %'ModuleName'%.%MakeDirectory(const byte *dirName, const %@Shell@'ModuleName'%.StdIOType *io);
%define! PardirName
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemMakeDirectory.Inc

%endif %- MakeDirectory
%-BW_METHOD_END MakeDirectory
%-************************************************************************************************************
%-BW_METHOD_BEGIN ChangeDirectory
%ifdef ChangeDirectory
byte %'ModuleName'%.%ChangeDirectory(const byte *dirName, const %@Shell@'ModuleName'%.StdIOType *io);
%define! PardirName
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemChangeDirectory.Inc

%endif %- ChangeDirectory
%-BW_METHOD_END ChangeDirectory
%-************************************************************************************************************
%-BW_METHOD_BEGIN RenameFile
%ifdef RenameFile
byte %'ModuleName'%.%RenameFile(const byte *srcFileName, const byte *dstFileName, const %@Shell@'ModuleName'%.StdIOType *io);
%define! ParsrcFileName
%define! PardstFileName
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemRenameFile.Inc

%endif %- RenameFile
%-BW_METHOD_END RenameFile
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintSector
%ifdef PrintSector
byte %'ModuleName'%.%PrintSector(byte drive, dword sectorNo, const %@Shell@'ModuleName'%.StdIOType *io);
%define! Pardrive
%define! ParsectorNo
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemPrintSector.Inc

%endif %- PrintSector
%-BW_METHOD_END PrintSector
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintDiskInfo
%ifdef PrintDiskInfo
byte %'ModuleName'%.%PrintDiskInfo(byte drive, const %@Shell@'ModuleName'%.StdIOType *io);
%define! Pardrive
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemPrintDiskInfo.Inc

%endif %- PrintDiskInfo
%-BW_METHOD_END PrintDiskInfo
%-************************************************************************************************************
%-BW_METHOD_BEGIN Benchmark
%ifdef Benchmark
byte %'ModuleName'%.%Benchmark(const %@Shell@'ModuleName'%.StdIOType *io);
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemBenchmark.Inc

%endif %- Benchmark
%-BW_METHOD_END Benchmark
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN OnIdle
%ifdef OnIdle
%INTERFACE OnIdle
void %OnIdle(void);
%include Common\FAT_FileSystemOnIdle.Inc

%endif %- OnIdle
%-BW_METHOD_END OnIdle
%-BW_METHOD_BEGIN OnSchedule
%ifdef OnSchedule
%INTERFACE OnSchedule
void %OnSchedule(void);
%include Common\FAT_FileSystemOnSchedule.Inc

%endif %- OnSchedule
%-BW_METHOD_END OnSchedule
%-BW_METHOD_BEGIN OnCreateSyncObject
%ifdef OnCreateSyncObject
%INTERFACE OnCreateSyncObject
void %OnCreateSyncObject(void *sobj);
%define! Parsobj
%include Common\FAT_FileSystemOnCreateSyncObject.Inc

%endif %- OnCreateSyncObject
%-BW_METHOD_END OnCreateSyncObject
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\FAT_FileSystemSettings.Inc
%define! Abstract Common\FAT_FileSystemAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "ff.h"
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%if defined(Shell)
#define %'ModuleName'_8_3_SIZE       sizeof("12345678.txt") /* length of a 8.3 file name (13 including the zero byte) */

#if %'ModuleName'%.USE_LFN == 0                                  %>40 /* No LFN */
#define %'ModuleName'%.DEF_NAMEBUF(name)                         %>40 byte name[%'ModuleName'%.8_3_SIZE]
#define %'ModuleName'%.PTR_NAMEBUF(name)                         %>40 &name[0]
#define %'ModuleName'%.SIZE_NAMEBUF(name)                        %>40 sizeof(name)
#define %'ModuleName'%.INIT_NAMEBUF(name)
#define %'ModuleName'%.FREE_NAMEBUF(name)

#elif %'ModuleName'%.USE_LFN == 1                                %>40 /* LFN with static LFN working buffer */
static TCHAR %'ModuleName'%.FileName[%'ModuleName'%.MAX_LFN+1];
static TCHAR %'ModuleName'%.FileName2[%'ModuleName'%.MAX_LFN+1];
#define %'ModuleName'%.DEF_NAMEBUF(name)
#define %'ModuleName'%.PTR_NAMEBUF(name)                         %>40 &%'ModuleName'%.name[0]
#define %'ModuleName'%.SIZE_NAMEBUF(name)                        %>40 sizeof(%'ModuleName'%.name)
#define %'ModuleName'%.INIT_NAMEBUF(name)
#define %'ModuleName'%.FREE_NAMEBUF(name)

#elif %'ModuleName'%.USE_LFN == 2                                %>40 /* LFN with dynamic LFN working buffer on the stack */
#define %'ModuleName'%.DEF_NAMEBUF(name)                         %>40 byte name[%'ModuleName'%.MAX_LFN+1]
#define %'ModuleName'%.PTR_NAMEBUF(name)                         %>40 &name[0]
#define %'ModuleName'%.SIZE_NAMEBUF(name)                        %>40 sizeof(name)
#define %'ModuleName'%.INIT_NAMEBUF(name)
#define %'ModuleName'%.FREE_NAMEBUF(name)

#elif %'ModuleName'%.USE_LFN == 3                                %>40 /* LFN with dynamic LFN working buffer on the heap */
#define %'ModuleName'%.DEF_NAMEBUF(name)                         %>40 byte *name
#define %'ModuleName'%.PTR_NAMEBUF(name)                         %>40 name
#define %'ModuleName'%.SIZE_NAMEBUF(name)                        %>40 (%'ModuleName'%.MAX_LFN+1)
#define %'ModuleName'%.INIT_NAMEBUF(name)                        %>40 { name = ff_memalloc(%'ModuleName'%.MAX_LFN+1); \
                                                                 %>40   if (!name) { \
                                                                 %>40     %@Shell@'ModuleName'%.SendStr((unsigned char*)"ff_memalloc failed!", io->stdErr); \
                                                                 %>40     return ERR_FAILED; \
                                                                 %>40   } \
                                                                 %>40 }
#define %'ModuleName'%.FREE_NAMEBUF(name)                        %>40 ff_memfree(name)

#else
  #error Wrong LFN configuration.
#endif

static void FatFsFResultMsg(byte *msg, %'ModuleName'_FRESULT errNo, const %@Shell@'ModuleName'%.StdIOType *io) {
  unsigned char buf[sizeof("1234")];

  %@Shell@'ModuleName'%.SendStr((unsigned char*)"ERROR: ", io->stdErr);
  %@Shell@'ModuleName'%.SendStr(msg, io->stdErr);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)": (", io->stdErr);
  %@Utility@'ModuleName'%.Num16sToStr(buf, sizeof(buf), errNo);
  %@Shell@'ModuleName'%.SendStr(buf, io->stdErr);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)") ", io->stdErr);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)%'ModuleName'%.errFResultMsg(errNo), io->stdErr);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdErr);
}
%ifdef PrintSector

static void FatFsDResultMsg(byte *msg, %'ModuleName'_DRESULT errNo, const %@Shell@'ModuleName'%.StdIOType *io) {
  unsigned char buf[sizeof("1234")];

  %@Shell@'ModuleName'%.SendStr((unsigned char*)"ERROR: ", io->stdErr);
  %@Shell@'ModuleName'%.SendStr(msg, io->stdErr);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)": (", io->stdErr);
  %@Utility@'ModuleName'%.Num16sToStr(buf, sizeof(buf), errNo);
  %@Shell@'ModuleName'%.SendStr(buf, io->stdErr);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)") ", io->stdErr);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)%'ModuleName'%.errDResultMsg(errNo), io->stdErr);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdErr);
}
%endif

static void CmdUsageError(const unsigned char *cmd, byte *usage, const %@Shell@'ModuleName'%.StdIOType *io) {
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"*** error while reading command: ", io->stdErr);
  %@Shell@'ModuleName'%.SendStr(cmd, io->stdErr);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n*** Usage: ", io->stdErr);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)usage, io->stdErr);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdErr);
}

/*!
 * \brief Writes a directory listing of the given path
 * \param[in] dirPathPtr Pointer to a directory path string. Pass "\\" for the root directory
 * \param[in] io Callback to write directory output
 * \return Error code, otherwise ERR_OK
 */
static byte PrintDir(const byte *dirPathPtr, const %@Shell@'ModuleName'%.StdIOType *io) {
  %'ModuleName'%.FILINFO fInfo;
  %'ModuleName'%.FRESULT fres;
  uint32_t p1;
  UINT s1, s2;
  %'ModuleName'%.DIR dir;  /* Directory object */
  byte buf[sizeof("yyyy-mm-dd hh:ss")+1];
#if !%'ModuleName'%.FS_READONLY
  %'ModuleName'%.FATFS *fs;
#endif
#if %'ModuleName'%.USE_LFN
  %'ModuleName'%.DEF_NAMEBUF(fileName);
#endif

  %@Shell@'ModuleName'%.SendStr((unsigned char*)"Directory of ", io->stdOut);
  %@Shell@'ModuleName'%.SendStr(dirPathPtr, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
  fres = %'ModuleName'%.opendir(&dir, (char*)dirPathPtr);
  if (fres != FR_OK) {
    FatFsFResultMsg((unsigned char*)"opendir failed", fres, io);
    return ERR_FAULT;
  }
  p1 = s1 = s2 = 0;
#if %'ModuleName'%.USE_LFN
  %'ModuleName'%.INIT_NAMEBUF(fileName);
  fInfo.lfname = (char*)fileName;
  fInfo.lfsize = %'ModuleName'%.SIZE_NAMEBUF(fileName);
#endif
  for(;;) {
    fres = %'ModuleName'%.readdir(&dir, &fInfo);
    if (fres != FR_OK) {
      FatFsFResultMsg((unsigned char*)"readdir failed", fres, io);
      break;
    }
    if (!fInfo.fname[0]) { /* end of directory list */
      break;
    }
    /* file attributes */
    if (fInfo.fattrib & AM_DIR) { /* directory */
      s2++;
      io->stdOut('D');
    } else {
      s1++;
      p1 += fInfo.fsize;
      io->stdOut('-');
    }
    if (fInfo.fattrib & AM_RDO) { /* read only */
      io->stdOut('R');
    } else {
      io->stdOut('-');
    }
    if (fInfo.fattrib & AM_HID) { /* hidden */
      io->stdOut('H');
    } else {
      io->stdOut('-');
    }
    if (fInfo.fattrib & AM_SYS) { /* system */
      io->stdOut('S');
    } else {
      io->stdOut('-');
    }
    if (fInfo.fattrib & AM_ARC) { /* archive */
      io->stdOut('A');
    } else {
      io->stdOut('-');
    }
    io->stdOut(' ');
    /* file date & time */
    buf[0] = '\0';
    %@Utility@'ModuleName'%.strcatNum16sFormatted(buf, sizeof(buf), (int16_t)((fInfo.fdate >> 9) + 1980), ' ', 4); /* year */
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)"-");
    %@Utility@'ModuleName'%.strcatNum16sFormatted(buf, sizeof(buf), (int16_t)((fInfo.fdate >> 5) & 15), '0', 2); /* month */
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)"-");
    %@Utility@'ModuleName'%.strcatNum16sFormatted(buf, sizeof(buf), (int16_t)(fInfo.fdate & 31), '0', 2); /* day */
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)" ");
    %@Utility@'ModuleName'%.strcatNum16sFormatted(buf, sizeof(buf), (int16_t)((fInfo.ftime >> 11)), '0', 2); /* hour */
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)":");
    %@Utility@'ModuleName'%.strcatNum16sFormatted(buf, sizeof(buf), (int16_t)((fInfo.ftime >> 5) & 63), '0', 2); /* minute */
    %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
    io->stdOut(' ');
    buf[0] = '\0';
    /* file size */
    %@Utility@'ModuleName'%.strcatNum32uFormatted(buf, sizeof(buf), fInfo.fsize, ' ', 10); /* size */
    %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
    /* file name */
    io->stdOut(' ');
    %@Shell@'ModuleName'%.SendStr((unsigned char*)fInfo.fname, io->stdOut);
#if %'ModuleName'%.USE_LFN
    io->stdOut(' ');
    %@Shell@'ModuleName'%.SendStr((unsigned char*)fInfo.lfname, io->stdOut);
#endif
    io->stdOut('\r');
    io->stdOut('\n');
  }
  /* number of files and bytes used */
  buf[0] = '\0';
  %@Utility@'ModuleName'%.strcatNum16u(buf, sizeof(buf), (uint16_t)s1);
  %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)" File(s), ", io->stdOut);
  buf[0] = '\0';
  %@Utility@'ModuleName'%.strcatNum32u(buf, sizeof(buf), p1);
  %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)" bytes total\r\n", io->stdOut);
  /* number of directories and number of free bytes */
  buf[0] = '\0';
  %@Utility@'ModuleName'%.strcatNum16u(buf, sizeof(buf), (uint16_t)s2);
  %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)" Dir(s)", io->stdOut);
#if !%'ModuleName'%.FS_READONLY
  /* number of free bytes */
  fres = %'ModuleName'%.getfree((char*)dirPathPtr, &p1, &fs);
  if (fres != FR_OK) {
    FatFsFResultMsg((unsigned char*)"getfree failed", fres, io);
  } else {
    io->stdOut(',');
    io->stdOut(' ');
    buf[0] = '\0';
    %@Utility@'ModuleName'%.strcatNum32s(buf, sizeof(buf), (long)(p1*fs->csize/2));
    %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
    %@Shell@'ModuleName'%.SendStr((unsigned char*)" KBytes free", io->stdOut);
  }
#endif
  io->stdOut('\r');
  io->stdOut('\n');
#if %'ModuleName'%.USE_LFN
  %'ModuleName'%.FREE_NAMEBUF(fileName);
#endif
  return ERR_OK;
}

%ifdef PrintDirectory
static byte DirCmd(const unsigned char *cmd, const %@Shell@'ModuleName'%.ConstStdIOType *io) {
  /* precondition: cmd starts with "dir" */
  byte res = ERR_OK;
  %'ModuleName'%.DEF_NAMEBUF(fileName);

  %'ModuleName'%.INIT_NAMEBUF(fileName);
  if (*(cmd+sizeof("dir")-1)== ' ') { /* space after "dir": read name */
    if (%@Utility@'ModuleName'%.ReadEscapedName(cmd+sizeof("dir"), %'ModuleName'%.PTR_NAMEBUF(fileName),
          %'ModuleName'%.SIZE_NAMEBUF(fileName), NULL, NULL, NULL)==ERR_OK
       )
    {
      /* ok, have now directory name */
    } else {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"reading directory name failed!\r\n", io->stdErr);
      res = ERR_FAILED;
    }
  } else { /* use current directory */
#if %'ModuleName'%.FS_RPATH >= 2
    %'ModuleName'%.FRESULT fres;
    fres = %'ModuleName'%.getcwd((char*)%'ModuleName'%.PTR_NAMEBUF(fileName), %'ModuleName'%.SIZE_NAMEBUF(fileName));
    if(fres!=FR_OK) {
      FatFsFResultMsg((unsigned char*)"getcwd failed", fres, io);
      res = ERR_FAILED;
    } else {
      /* ok, have now directory name */
    }
#else
    %@Utility@'ModuleName'%.strcpy(%'ModuleName'%.PTR_NAMEBUF(fileName), %'ModuleName'%.SIZE_NAMEBUF(fileName), (unsigned char*)"\\"); /* use root */
#endif
  }
  if (res == ERR_OK) {
    res = %'ModuleName'%.PrintDirectory(%'ModuleName'%.PTR_NAMEBUF(fileName), io);
  }
  %'ModuleName'%.FREE_NAMEBUF(fileName);
  return res;
}

%endif %-ifdef PrintDirectory
%ifdef CopyFile
static byte CopyCmd(const unsigned char *cmd, const %@Shell@'ModuleName'%.ConstStdIOType *io) {
  /* precondition: cmd starts with "copy" */
  byte res = ERR_OK;
  size_t lenRead;
  %'ModuleName'%.DEF_NAMEBUF(fileName);
  %'ModuleName'%.DEF_NAMEBUF(fileName2);

  %'ModuleName'%.INIT_NAMEBUF(fileName);
  %'ModuleName'%.INIT_NAMEBUF(fileName2);
  if (   (%@Utility@'ModuleName'%.ReadEscapedName(cmd+sizeof("copy"), %'ModuleName'%.PTR_NAMEBUF(fileName),
          %'ModuleName'%.SIZE_NAMEBUF(fileName), &lenRead, NULL, NULL)==ERR_OK)
      && *(cmd+sizeof("copy")+lenRead)==' '
      && (%@Utility@'ModuleName'%.ReadEscapedName(cmd+sizeof("copy")+lenRead+1, %'ModuleName'%.PTR_NAMEBUF(fileName2),
          %'ModuleName'%.SIZE_NAMEBUF(fileName2), NULL, NULL, NULL)==ERR_OK)
     )
  {
    res = %'ModuleName'%.%CopyFile(%'ModuleName'%.PTR_NAMEBUF(fileName), %'ModuleName'%.PTR_NAMEBUF(fileName2), io);
  } else {
    CmdUsageError(cmd, (unsigned char*)"copy srcFileName dstFileName", io);
    res = ERR_FAILED;
  }
  %'ModuleName'%.FREE_NAMEBUF(fileName);
  %'ModuleName'%.FREE_NAMEBUF(fileName2);
  return res;
}
%endif

%ifdef DeleteFile
static byte DeleteCmd(const unsigned char *cmd, const %@Shell@'ModuleName'%.ConstStdIOType *io) {
  /* precondition: cmd starts with "delete" */
  byte res = ERR_OK;
  %'ModuleName'%.DEF_NAMEBUF(fileName);

  %'ModuleName'%.INIT_NAMEBUF(fileName);
  if (%@Utility@'ModuleName'%.ReadEscapedName(cmd+sizeof("delete"), %'ModuleName'%.PTR_NAMEBUF(fileName),
        %'ModuleName'%.SIZE_NAMEBUF(fileName), NULL, NULL, NULL)==ERR_OK
     )
  {
    res = %'ModuleName'%.%DeleteFile(%'ModuleName'%.PTR_NAMEBUF(fileName), io);
  } else {
    CmdUsageError(cmd, (unsigned char*)"delete fileName", io);
    res = ERR_FAILED;
  }
  %'ModuleName'%.FREE_NAMEBUF(fileName);
  return res;
}

%endif
%ifdef MakeDirectory
static byte MkdirCmd(const unsigned char *cmd, const %@Shell@'ModuleName'%.ConstStdIOType *io) {
  /* precondition: cmd starts with "mkdir" */
  byte res = ERR_OK;
  %'ModuleName'%.DEF_NAMEBUF(fileName);

  %'ModuleName'%.INIT_NAMEBUF(fileName);
  if (%@Utility@'ModuleName'%.ReadEscapedName(cmd+sizeof("mkdir"), %'ModuleName'%.PTR_NAMEBUF(fileName),
        %'ModuleName'%.SIZE_NAMEBUF(fileName), NULL, NULL, NULL)==ERR_OK
     )
  {
    res = %'ModuleName'%.%MakeDirectory(%'ModuleName'%.PTR_NAMEBUF(fileName), io);
  } else {
    CmdUsageError(cmd, (unsigned char*)"mkdir directoryName", io);
    res = ERR_FAILED;
  }
  %'ModuleName'%.FREE_NAMEBUF(fileName);
  return res;
}

%endif
static byte RenameCmd(const unsigned char *cmd, const %@Shell@'ModuleName'%.ConstStdIOType *io) {
  /* precondition: cmd starts with "rename" */
  byte res = ERR_OK;
  size_t lenRead;
  %'ModuleName'%.DEF_NAMEBUF(fileName);
  %'ModuleName'%.DEF_NAMEBUF(fileName2);

  %'ModuleName'%.INIT_NAMEBUF(fileName);
  %'ModuleName'%.INIT_NAMEBUF(fileName2);
  if (   (%@Utility@'ModuleName'%.ReadEscapedName(cmd+sizeof("rename"), %'ModuleName'%.PTR_NAMEBUF(fileName),
          %'ModuleName'%.SIZE_NAMEBUF(fileName), &lenRead, NULL, NULL)==ERR_OK)
      && *(cmd+sizeof("rename")+lenRead)==' '
      && (%@Utility@'ModuleName'%.ReadEscapedName(cmd+sizeof("rename")+lenRead+1,
          %'ModuleName'%.PTR_NAMEBUF(fileName2),
          %'ModuleName'%.SIZE_NAMEBUF(fileName2), NULL, NULL, NULL)==ERR_OK)
     )
  {
    res = %'ModuleName'%.%RenameFile((unsigned char*)%'ModuleName'%.PTR_NAMEBUF(fileName), (unsigned char*)%'ModuleName'%.PTR_NAMEBUF(fileName2), io);
  } else {
    CmdUsageError(cmd, (unsigned char*)"rename srcFileName dstFileName", io);
    res = ERR_FAILED;
  }
  %'ModuleName'%.FREE_NAMEBUF(fileName);
  %'ModuleName'%.FREE_NAMEBUF(fileName2);
  return res;
}
%if defined(PrintSector)

static byte SectorCmd(const unsigned char *cmd, const %@Shell@'ModuleName'%.ConstStdIOType *io) {
  /* precondition: cmd starts with "sector" */
  uint8_t res;
  uint32_t sectorNo;
  const unsigned char *p = cmd+sizeof("sector");

  res = %@Utility@'ModuleName'%.ScanDecimal32uNumber(&p, &sectorNo);
  if (res == ERR_OK) { /* format fine */
    %'ModuleName'%.%PrintSector(0, sectorNo, io);
  } else {
    CmdUsageError(cmd, (unsigned char*)"sector <number>", io);
    return ERR_FAILED;
  }
  return ERR_OK;
}
%endif %-defined(PrintSector)
%if defined(PrintFile)

static byte PrintCmd(const unsigned char *cmd, const %@Shell@'ModuleName'%.ConstStdIOType *io) {
  /* precondition: cmd starts with "print" */
  byte res = ERR_OK;
  %'ModuleName'%.DEF_NAMEBUF(fileName);

  %'ModuleName'%.INIT_NAMEBUF(fileName);
  if (%@Utility@'ModuleName'%.ReadEscapedName(cmd+sizeof("print"), %'ModuleName'%.PTR_NAMEBUF(fileName),
        %'ModuleName'%.SIZE_NAMEBUF(fileName), NULL, NULL, NULL)==ERR_OK
     )
  {
    res = %'ModuleName'%.%PrintFile(%'ModuleName'%.PTR_NAMEBUF(fileName), io);
  } else {
    CmdUsageError(cmd, (unsigned char*)"print fileName", io);
    res = ERR_FAILED;
  }
  %'ModuleName'%.FREE_NAMEBUF(fileName);
  return res;
}
%endif %-defined(PrintFile)
%if defined(ChangeDirectory)

static byte CdCmd(const unsigned char *cmd, const %@Shell@'ModuleName'%.ConstStdIOType *io) {
  /* precondition: cmd starts with "cd" */
#if %'ModuleName'%.FS_RPATH > 0
  byte res = ERR_OK;
  %'ModuleName'%.DEF_NAMEBUF(fileName);

  %'ModuleName'%.INIT_NAMEBUF(fileName);
  if (*(cmd+sizeof("cd")-1)== ' ') { /* space after "cd": read name */
    if (%@Utility@'ModuleName'%.ReadEscapedName(cmd+sizeof("cd"), %'ModuleName'%.PTR_NAMEBUF(fileName),
          %'ModuleName'%.SIZE_NAMEBUF(fileName), NULL, NULL, NULL)==ERR_OK
       )
    {
      res = %'ModuleName'%.%ChangeDirectory(%'ModuleName'%.PTR_NAMEBUF(fileName), io);
    } else {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"reading directory name failed!\r\n", io->stdErr);
      res = ERR_FAILED;
    }
  } else { /* print current directory */
#if %'ModuleName'%.FS_RPATH >= 2
    %'ModuleName'%.FRESULT fres;

    fres = %'ModuleName'%.getcwd((char*)%'ModuleName'%.PTR_NAMEBUF(fileName), %'ModuleName'%.SIZE_NAMEBUF(fileName));
    if(fres!=FR_OK) {
      FatFsFResultMsg((unsigned char*)"getcwd failed", fres, io);
      res = ERR_FAILED;
    } else {
      %@Shell@'ModuleName'%.SendStr(%'ModuleName'%.PTR_NAMEBUF(fileName), io->stdOut);
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
    }
#else
    %@Utility@'ModuleName'%.strcpy(%'ModuleName'%.PTR_NAMEBUF(fileName), %'ModuleName'%.SIZE_NAMEBUF(fileName), (unsigned char*)"\\"); /* use root */
#endif
  }
  %'ModuleName'%.FREE_NAMEBUF(fileName);
  return res;
#else
  (void)cmd;
  #warning "relative directories not enabled in FatFS!"
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"relative directories not available in file system\r\n", io->stdErr);
  return ERR_FAILED;
#endif
}

%endif %- defined(ChangeDirectory)

static uint8_t PrintStatus(const %@Shell@'ModuleName'%.StdIOType *io) {
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"%'ModuleName'", (unsigned char*)"\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  present", %'ModuleName'%.isDiskPresent()?(unsigned char*)"yes\r\n":(unsigned char*)"no\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  protected", %'ModuleName'%.isWriteProtected()?(unsigned char*)"yes\r\n":(unsigned char*)"no\r\n", io->stdOut);
  return ERR_OK;
}

static uint8_t PrintHelp(const %@Shell@'ModuleName'%.StdIOType *io) {
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"%'ModuleName'", (unsigned char*)"Group of %'ModuleName' commands\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  help|status", (unsigned char*)"Print help or status information\r\n", io->stdOut);
%ifdef ChangeDirectory
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  cd [<directoryName>]", (const unsigned char*)"Change the current directory or display the name of the current directory\r\n", io->stdOut);
%endif
%ifdef PrintDirectory
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  dir [<directoryName>]", (const unsigned char*)"Prints a directory\r\n", io->stdOut);
%endif
%ifdef CopyFile
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  copy <src> <dst>", (const unsigned char*)"Copy a file\r\n", io->stdOut);
%endif
%ifdef DeleteFile
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  delete <filename>", (const unsigned char*)"Delete a file\r\n", io->stdOut);
%endif
%ifdef MakeDirectory
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  mkdir <directory>", (const unsigned char*)"Create a directory\r\n", io->stdOut);
%endif
%ifdef RenameFile
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  rename <src> <dst>", (const unsigned char*)"Rename a file\r\n", io->stdOut);
%endif
%ifdef PrintFile
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  print <filename>", (const unsigned char*)"Print a file\r\n", io->stdOut);
%endif
%ifdef PrintSector
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  sector <number>", (const unsigned char*)"Print disk sector\r\n", io->stdOut);
%endif
%ifdef PrintDiskInfo
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  diskinfo", (const unsigned char*)"Print disk information\r\n", io->stdOut);
%endif
%ifdef Benchmark
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  benchmark", (const unsigned char*)"Run disk benchmark\r\n", io->stdOut);
%endif
  return ERR_OK;
}

%endif
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************

/* Unicode support functions */
#if _USE_LFN  /* Unicode - OEM code conversion */
#if _USE_LFN == 3   /* Memory functions */
void *ff_memalloc(UINT size) { /* Allocate memory block */
%if defined(RTOS)
  /* FreeRTOS */
  return %@RTOS@'ModuleName'%.pvPortMalloc(size);
%else
  #error "No RTOS defined?"
%endif
}

void ff_memfree (void* ptr) {  /* Free memory block */
%if defined(RTOS)
  /* FreeRTOS */
  %@RTOS@'ModuleName'%.vPortFree(ptr);
%else
  #error "No RTOS defined?"
%endif
}
#endif
#endif

#if _FS_REENTRANT
/*!
* \brief Create a Synchronization Object
* This function is called in f_mount function to create a new
* synchronization object, such as semaphore and mutex. When a FALSE is
* returned, the f_mount function fails with FR_INT_ERR.
* \param[in] vol Corresponding logical drive being processed
* \param[out] sobj Pointer to return the created sync object
* \return TRUE: Function succeeded, FALSE: Could not create due to any error
*/
%if defined(UserSyncFunctions) & %UserSyncFunctions='yes'
#if 0
int ff_cre_syncobj(uint8_t vol, _SYNC_t *sobj)
{
  /* You have decided in the component properties to implement your own user sync functions,
     with you own _SYNC_t type (e.g. HANDLE).
     You need to implement your own version of this function in your application.
  */
}
#endif
%else
int ff_cre_syncobj(uint8_t vol, _SYNC_t *sobj) {
  (void)vol; /* argument not used */
%if defined(RTOS)
  *sobj = %@RTOS@'ModuleName'%.xSemaphoreCreateMutex(); /* create semaphore */
  %if defined(OnCreateSyncObject)
  %OnCreateSyncObject(*sobj);
  %endif
  return (*sobj != NULL) ? TRUE : FALSE;
%- *sobj = OSMutexCreate(0, &err);                         /* uC/OS-II */
%- ret = (err == OS_NO_ERR) ? TRUE : FALSE;
%else
  /* _FS_REENTRANT enabled, no RTOS enabled, and you don't want to provide your own sync method.
     That means that you cannot have parallel access to the file system object.
     If you have parallel access to the memory bus, you need to handle this from the memory component.
   */
  (void)sobj;
  return TRUE;
%endif
}
%endif

/*!
* \brief Delete a Synchronization Object
* This function is called in f_mount function to delete a synchronization
* object that created with ff_cre_syncobj function. When a FALSE is
* returned, the f_mount function fails with FR_INT_ERR.
* \param[out] sobj Sync object tied to the logical drive to be deleted
* \return TRUE: Function succeeded, FALSE: Could not create due to any error
*/
%if defined(UserSyncFunctions) & %UserSyncFunctions='yes'
#if 0
int ff_del_syncobj(_SYNC_t sobj) {
  /* You have decided in the component properties to implement your own user sync functions,
     with you own _SYNC_t type (e.g. HANDLE).
     You need to implement your own version of this function in your application.
  */
}
#endif
%else
int ff_del_syncobj(_SYNC_t sobj) {
%if defined(RTOS)
  %@RTOS@'ModuleName'%.vQueueDelete(sobj); /* FreeRTOS: free up memory for semaphore */
  return TRUE; /* everything ok */
%-      OSMutexDel(sobj, OS_DEL_ALWAYS, &err);          /* uC/OS-II */
%-      ret = (err == OS_NO_ERR) ? TRUE : FALSE;
%else
  /* _FS_REENTRANT enabled, no RTOS enabled, and you don't want to provide your own sync method.
     That means that you cannot have parallel access to the file system object.
     If you have parallel access to the memory bus, you need to handle this from the memory component.
   */
  (void)sobj; /* unused parameter */
  return TRUE;
%endif
}
%endif

/*!
* \brief Request Grant to Access the Volume
* This function is called on entering file functions to lock the volume.
* When a FALSE is returned, the file function fails with FR_TIMEOUT.
* \param[in] sobj Sync object to wait
* \return TRUE: Function succeeded, FALSE: Could not create due to any error
*/
%if defined(UserSyncFunctions) & %UserSyncFunctions='yes'
#if 0
int ff_req_grant (_SYNC_t sobj) {
  /* You have decided in the component properties to implement your own user sync functions,
     with you own _SYNC_t type (e.g. HANDLE).
     You need to implement your own version of this function in your application.
  */
}
#endif
%else
int ff_req_grant (_SYNC_t sobj) {
%if defined(RTOS)
  if (%@RTOS@'ModuleName'%.xSemaphoreTake(sobj, _FS_TIMEOUT) == pdTRUE) {
    %@Memory@'ModuleName'%.Activate(); /* select memory device */
    return TRUE; /* success */
  } else {  /* failed to get the sync object? */
    return FALSE; /* failure */
  }
%-      OSMutexPend(sobj, _FS_TIMEOUT, &err));                  /* uC/OS-II */
%-      return (err == OS_NO_ERR) ? TRUE : FALSE;
%else
  /* _FS_REENTRANT enabled, no RTOS enabled, and you don't want to provide your own sync method.
     That means that you cannot have parallel access to the file system object.
     If you have parallel access to the memory bus, you need to handle this from the memory component.
   */
  (void)sobj; /* unused parameter */
  %@Memory@'ModuleName'%.Activate(); /* select memory device */
  return TRUE; /* success */
%endif
}
%endif

/*!
* \brief Release Grant to Access the Volume
* This function is called on leaving file functions to unlock the volume.
* \param[in] sobj Sync object to be signaled
*/
%if defined(UserSyncFunctions) & %UserSyncFunctions='yes'
#if 0
void ff_rel_grant (_SYNC_t sobj) {
  /* You have decided in the component properties to implement your own user sync functions,
     with you own _SYNC_t type (e.g. HANDLE).
     You need to implement your own version of this function in your application.
  */
}
#endif
%else
void ff_rel_grant (_SYNC_t sobj) {
  %@Memory@'ModuleName'%.Deactivate(); /* un-select memory device */
%if defined(RTOS)
  (void)%@RTOS@'ModuleName'%.xSemaphoreGive(sobj); /* FreeRTOS */
%-      OSMutexPost(sobj);              /* uC/OS-II */
%else
  /* _FS_REENTRANT enabled, no RTOS enabled, and you don't want to provide your own sync method.
     That means that you cannot have parallel access to the file system object.
     If you have parallel access to the memory bus, you need to handle this from the memory component.
   */
  (void)sobj; /* unused parameter */
%endif
}
%endif
#endif /* _FS_REENTRANT */

%-BW_METHOD_BEGIN open
%ifdef open
%define! Parfp
%define! Parpath
%define! Parmode
%define! RetVal
%include Common\FAT_FileSystemopen.Inc
/*
FRESULT %'ModuleName'%.%open(FIL *fp, const XCHAR *path, BYTE mode)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- open
%-BW_METHOD_END open
%-************************************************************************************************************
%-BW_METHOD_BEGIN close
%ifdef close
%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemclose.Inc
/*
FRESULT %'ModuleName'%.%close(FIL *fp)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- close
%-BW_METHOD_END close
%-************************************************************************************************************
%-BW_METHOD_BEGIN read
%ifdef read
%define! Parfp
%define! Parbuff
%define! Parbtr
%define! Parbr
%define! RetVal
%include Common\FAT_FileSystemread.Inc
/*
FRESULT %'ModuleName'%.%read(FIL *fp, void *buff, UINT btr, UINT *br)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- read
%-BW_METHOD_END read
%-************************************************************************************************************
%-BW_METHOD_BEGIN write
%ifdef write
%define! Parfp
%define! Parbuff
%define! Parbtw
%define! Parbw
%define! RetVal
%include Common\FAT_FileSystemwrite.Inc
/*
FRESULT %'ModuleName'%.%write(FIL *fp, const *void buff, UINT btw, UINT *bw)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- write
%-BW_METHOD_END write
%-************************************************************************************************************
%-BW_METHOD_BEGIN opendir
%ifdef opendir
%define! Pardj
%define! Parpath
%define! RetVal
%include Common\FAT_FileSystemopendir.Inc
/*
FRESULT %'ModuleName'%.%opendir(DIR *dj, const XCHAR *path)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- opendir
%-BW_METHOD_END opendir
%-************************************************************************************************************
%-BW_METHOD_BEGIN readdir
%ifdef readdir
%define! Pardir
%define! Parfno
%define! RetVal
%include Common\FAT_FileSystemreaddir.Inc
/*
FRESULT %'ModuleName'%.%readdir(DIR *dj, FILINFO *fno)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- readdir
%-BW_METHOD_END readdir
%-************************************************************************************************************
%-BW_METHOD_BEGIN lseek
%ifdef lseek
%define! Parfp
%define! Parofs
%define! RetVal
%include Common\FAT_FileSystemlseek.Inc
/*
FRESULT %'ModuleName'%.%lseek(FIL *fp, DWORD ofs)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- lseek
%-BW_METHOD_END lseek
%-************************************************************************************************************
%-BW_METHOD_BEGIN unlink
%ifdef unlink
%define! Parpath
%define! RetVal
%include Common\FAT_FileSystemunlink.Inc
/*
FRESULT %'ModuleName'%.%unlink(const XCHAR *path)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- unlink
%-BW_METHOD_END unlink
%-************************************************************************************************************
%-BW_METHOD_BEGIN mount
%ifdef mount
%define! Parvol
%define! Parfs
%define! RetVal
%include Common\FAT_FileSystemmount.Inc
/*
FRESULT %'ModuleName'%.%mount(byte vol, FATFS *fs)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- mount
%-BW_METHOD_END mount
%-************************************************************************************************************
%-BW_METHOD_BEGIN getfree
%ifdef getfree
%define! Parpath
%define! Parnclst
%define! Parfatfs
%define! RetVal
%include Common\FAT_FileSystemgetfree.Inc
/*
FRESULT %'ModuleName'%.%getfree(const XCHAR *path, dword *nclst, FATFS **fatfs)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- getfree
%-BW_METHOD_END getfree
%-************************************************************************************************************
%-BW_METHOD_BEGIN sync
%ifdef sync
%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemsync.Inc
/*
FRESULT %'ModuleName'%.%sync(FIL *fp)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- sync
%-BW_METHOD_END sync
%-************************************************************************************************************
%-BW_METHOD_BEGIN rename
%ifdef rename
%define! Parpath_old
%define! Parpath_new
%define! RetVal
%include Common\FAT_FileSystemrename.Inc
/*
FRESULT %'ModuleName'%.%rename(const XCHAR *path_old, const XCHAR *path_new)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- rename
%-BW_METHOD_END rename
%-************************************************************************************************************
%-BW_METHOD_BEGIN isWriteProtected
%ifdef isWriteProtected
%define! RetVal
%include Common\FAT_FileSystemisWriteProtected.Inc
/*
bool %'ModuleName'%.%isWriteProtected(void)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- isWriteProtected
%-BW_METHOD_END isWriteProtected
%-************************************************************************************************************
%-BW_METHOD_BEGIN mkdir
%ifdef mkdir
%define! Parpath
%define! RetVal
%include Common\FAT_FileSystemmkdir.Inc
/*
FRESULT %'ModuleName'%.%mkdir(const XCHAR *path)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- mkdir
%-BW_METHOD_END mkdir
%-************************************************************************************************************
%-BW_METHOD_BEGIN chmod
%ifdef chmod
%define! ParFileName
%define! ParAttribute
%define! ParAttributeMask
%define! RetVal
%include Common\FAT_FileSystemchmod.Inc
/*
FRESULT %'ModuleName'%.%chmod(const TCHAR* FileName, byte Attribute, byte AttributeMask)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- chmod
%-BW_METHOD_END chmod
%-************************************************************************************************************
%-BW_METHOD_BEGIN truncate
%ifdef truncate
%define! ParFileObject
%define! RetVal
%include Common\FAT_FileSystemtruncate.Inc
/*
FRESULT %'ModuleName'%.%truncate(FIL *FileObject)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- truncate
%-BW_METHOD_END truncate
%-************************************************************************************************************
%-BW_METHOD_BEGIN stat
%ifdef stat
%define! ParFileName
%define! ParFileInfo
%define! RetVal
%include Common\FAT_FileSystemstat.Inc
/*
FRESULT %'ModuleName'%.%stat(const TCHAR* FileName, FILINFO* FileInfo)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- stat
%-BW_METHOD_END stat
%-************************************************************************************************************
%-BW_METHOD_BEGIN utime
%ifdef utime
%define! ParFileName
%define! ParTimeDate
%define! RetVal
%include Common\FAT_FileSystemutime.Inc
/*
FRESULT %'ModuleName'%.%utime(const TCHAR* FileName, const FILINFO* TimeDate)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- utime
%-BW_METHOD_END utime
%-************************************************************************************************************
%-BW_METHOD_BEGIN mkfs
%ifdef mkfs
%define! Pardrive
%define! ParPartitioningRule
%define! ParAllocSize
%define! RetVal
%include Common\FAT_FileSystemmkfs.Inc
/*
FRESULT %'ModuleName'%.%mkfs(byte drive, byte PartitioningRule, UINT  AllocSize)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- mkfs
%-BW_METHOD_END mkfs
%-************************************************************************************************************
%-BW_METHOD_BEGIN forward
%ifdef forward
%define! ParFileObject
%define! ParFunc
%define! ParByteToFwd
%define! ParByteFwd
%define! RetVal
%include Common\FAT_FileSystemforward.Inc
/*
FRESULT %'ModuleName'%.%forward(FIL* FileObject, UINT (*Func)(const BYTE*,UINT), UINT ByteToFwd, UINT* ByteFwd )
{
  *** method is implemented as macro in the header file
}
*/

%endif %- forward
%-BW_METHOD_END forward
%-************************************************************************************************************
%-BW_METHOD_BEGIN chdir
%ifdef chdir
%define! ParPath
%define! RetVal
%include Common\FAT_FileSystemchdir.Inc
/*
FRESULT %'ModuleName'%.%chdir(const TCHAR* Path)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- chdir
%-BW_METHOD_END chdir
%-************************************************************************************************************
%-BW_METHOD_BEGIN chdrive
%ifdef chdrive
%define! ParDrive
%define! RetVal
%include Common\FAT_FileSystemchdrive.Inc
/*
FRESULT %'ModuleName'%.%chdrive(byte Drive)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- chdrive
%-BW_METHOD_END chdrive
%-************************************************************************************************************
%-BW_METHOD_BEGIN getcwd
%ifdef getcwd
%define! ParBuffer
%define! ParBufferLen
%define! RetVal
%include Common\FAT_FileSystemgetcwd.Inc
/*
FRESULT %'ModuleName'%.%getcwd(TCHAR* Buffer, UINT BufferLen)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- getcwd
%-BW_METHOD_END getcwd
%-************************************************************************************************************
%-BW_METHOD_BEGIN errFResultMsg
%ifdef errFResultMsg
%define! ParerrNo
%define! RetVal
%include Common\FAT_FileSystemerrFResultMsg.Inc
char* %'ModuleName'%.%errFResultMsg(int errNo)
{
  switch(errNo) {
    case FR_OK:                  return (char*)"Succeeded";
    case FR_DISK_ERR:            return (char*)"A hard error occurred in the low level disk I/O layer";
    case FR_INT_ERR:             return (char*)"Assertion failed";
    case FR_NOT_READY:           return (char*)"The physical drive cannot work";
    case FR_NO_FILE:             return (char*)"Could not find the file";
    case FR_NO_PATH:             return (char*)"Could not find the path";
    case FR_INVALID_NAME:        return (char*)"The path name format is invalid";
    case FR_DENIED:              return (char*)"Access denied due to prohibited access or directory full";
    case FR_EXIST:               return (char*)"Access denied due to prohibited access";
    case FR_INVALID_OBJECT:      return (char*)"The file/directory object is invalid";
    case FR_WRITE_PROTECTED:     return (char*)"The physical drive is write protected";
    case FR_INVALID_DRIVE:       return (char*)"The logical drive number is invalid";
    case FR_NOT_ENABLED:         return (char*)"The volume has no work area";
    case FR_NO_FILESYSTEM:       return (char*)"There is no valid FAT volume on the physical drive";
    case FR_MKFS_ABORTED:        return (char*)"The f_mkfs() aborted due to any parameter error";
    case FR_TIMEOUT:             return (char*)"Could not get a grant to access the volume within defined period";
    case FR_LOCKED:              return (char*)"The operation is rejected according to the file sharing policy";
    case FR_NOT_ENOUGH_CORE:     return (char*)"LFN working buffer could not be allocated";
    case FR_TOO_MANY_OPEN_FILES: return (char*)"Number of open files > _FS_SHARE";
    /*default:                     return (char*)"unknown";*/
  } /* switch */
  return (char*)"*error*";
}

%endif %- errFResultMsg
%-BW_METHOD_END errFResultMsg
%-************************************************************************************************************
%-BW_METHOD_BEGIN errDResultMsg
%ifdef errDResultMsg
%define! ParerrNo
%define! RetVal
%include Common\FAT_FileSystemerrDResultMsg.Inc
char* %'ModuleName'%.%errDResultMsg(int errNo)
{
  switch(errNo) {
    case RES_OK:     return (char*)"Successful";
    case RES_ERROR:  return (char*)"R/W Error";
    case RES_WRPRT:  return (char*)"Write Protected";
    case RES_NOTRDY: return (char*)"Not Ready";
    case RES_PARERR: return (char*)"Invalid Parameter";
    /*default:         return (char*)"unknown";*/
  } /* switch */
  return (char*)"*error*";
}

%endif %- errDResultMsg
%-BW_METHOD_END errDResultMsg
%-************************************************************************************************************
%-BW_METHOD_BEGIN isDiskPresent
%ifdef isDiskPresent
%define! RetVal
%include Common\FAT_FileSystemisDiskPresent.Inc
/*
bool %'ModuleName'%.%isDiskPresent(void)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- isDiskPresent
%-BW_METHOD_END isDiskPresent
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_gets
%ifdef f_gets
%define! Parbuff
%define! Parlen
%define! Parfil
%define! RetVal
%include Common\FAT_FileSystemf_gets.Inc
/*
%'ModuleName'_CHARP %'ModuleName'%.%f_gets(TCHAR* buff, int len, FIL *fil)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- f_gets
%-BW_METHOD_END f_gets
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_puts
%ifdef f_puts
%define! Parbuff
%define! Parfil
%define! RetVal
%include Common\FAT_FileSystemf_puts.Inc
/*
%'ModuleName'_INT %'ModuleName'%.%f_puts(const TCHAR* str, FIL *fil)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- f_puts
%-BW_METHOD_END f_puts
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_putc
%ifdef f_putc
%define! Parbuff
%define! Parfil
%define! RetVal
%include Common\FAT_FileSystemf_putc.Inc
/*
%'ModuleName'_INT %'ModuleName'%.%f_putc(TCHAR c, FIL *fil)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- f_putc
%-BW_METHOD_END f_putc
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_printf
%ifdef f_printf
%define! ParVariable_1
%define! Parstr
%define! ParVariable_2
%define! RetVal
%include Common\FAT_FileSystemf_printf.Inc
/*
%'ModuleName'_INT %'ModuleName'%.%f_printf(FIL* fil, const TCHAR* str, ...)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- f_printf
%-BW_METHOD_END f_printf
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_eof
%ifdef f_eof
%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemf_eof.Inc
/*
byte %'ModuleName'%.%f_eof(FIL *fil)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- f_eof
%-BW_METHOD_END f_eof
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_error
%ifdef f_error
%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemf_error.Inc
/*
byte %'ModuleName'%.%f_error(FIL *fil)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- f_error
%-BW_METHOD_END f_error
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_tell
%ifdef f_tell
%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemf_tell.Inc
/*
dword %'ModuleName'%.%f_tell(FIL *fil)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- f_tell
%-BW_METHOD_END f_tell
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_size
%ifdef f_size
%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemf_size.Inc
/*
dword %'ModuleName'%.%f_size(FIL *fil)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- f_size
%-BW_METHOD_END f_size
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%define! RetVal
%include Common\FAT_FileSystemInit.Inc
byte %'ModuleName'%.%Init(void)
{
  return %@Memory@'ModuleName'%.Init(NULL);
}

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
%include Common\FAT_FileSystemDeinit.Inc
void %'ModuleName'%.%Deinit(void)
{
  %@Memory@'ModuleName'%.Deinit(NULL);
}

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN get_fattime
%ifdef get_fattime
%if defined(UseTimeDate) & %UseTimeDate='no'
#if 0 /* usage of DateTime component disabled in properties */
%endif

#if !_FS_READONLY
%define! RetVal
%include Common\FAT_FileSystemget_fattime.Inc
uint32_t %'ModuleName'%.%get_fattime(void)
{
  /* 31-25: Year(0-127 org.1980), 24-21: Month(1-12), 20-16: Day(1-31) */
  /* 15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) */
  /* Pack date and time into a uint32_t variable */
%if defined(RTC)
  TIMEREC time;
  DATEREC date;
  uint8_t res;

  res = %@RTC@'ModuleName'%.GetTime(&time);                      %>40 /* get time information */
  if (res!=ERR_OK) {
    return 0; /* failed */
  }
  res = %@RTC@'ModuleName'%.GetDate(&date);                      %>40 /* get date information */
  if (res!=ERR_OK) {
    return 0; /* failed */
  }
  return ((uint32_t)(date.Year - 1980) << 25)
       | ((uint32_t)date.Month << 21)
       | ((uint32_t)date.Day << 16)
       | ((uint32_t)time.Hour << 11)
       | ((uint32_t)time.Min << 5)
       | ((uint32_t)time.Sec);
%else
  /* Get time and date information and store it in 'time' and 'date'.
     If not using the DateTime component, you need to implement your own method here.
   */
  return 0;
%endif
}
#endif /*!_FS_READONLY*/

%if defined(UseTimeDate) & %UseTimeDate='no'
#endif /* usage of DateTime component disabled in properties */
%endif

%endif %- get_fattime
%-BW_METHOD_END get_fattime
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
%define! Parcmd
%define! Parhandled
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemParseCommand.Inc
byte %'ModuleName'%.%ParseCommand(const unsigned char *cmd, bool *handled, const %@Shell@'ModuleName'%.StdIOType *io)
{
  if (%@Utility@'ModuleName'%.strcmp((char*)cmd, %@Shell@'ModuleName'%.CMD_HELP)==0 || %@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' help")==0) {
    *handled = TRUE;
    return PrintHelp(io);
  } else if ((%@Utility@'ModuleName'%.strcmp((char*)cmd, %@Shell@'ModuleName'%.CMD_STATUS)==0) || (%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' status")==0)) {
    *handled = TRUE;
    return PrintStatus(io);
%ifdef ChangeDirectory
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "%'ModuleName' cd", sizeof("%'ModuleName' cd")-1)==0) {
    *handled = TRUE;
    return CdCmd(cmd+sizeof("%'ModuleName'"), io);
%endif
%ifdef PrintDirectory
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "%'ModuleName' dir", sizeof("%'ModuleName' dir")-1)==0) {
    *handled = TRUE;
    return DirCmd(cmd+sizeof("%'ModuleName'"), io);
%endif
%ifdef PrintFile
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "%'ModuleName' copy", sizeof("%'ModuleName' copy")-1)==0) {
    *handled = TRUE;
    return CopyCmd(cmd+sizeof("%'ModuleName'"), io);
%endif
%ifdef DeleteFile
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "%'ModuleName' delete", sizeof("%'ModuleName' delete")-1)==0) {
    *handled = TRUE;
    return DeleteCmd(cmd+sizeof("%'ModuleName'"), io);
%endif
%ifdef MakeDirectory
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "%'ModuleName' mkdir", sizeof("%'ModuleName' mkdir")-1)==0) {
    *handled = TRUE;
    return MkdirCmd(cmd+sizeof("%'ModuleName'"), io);
%endif
%ifdef RenameFile
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "%'ModuleName' rename", sizeof("%'ModuleName' rename")-1)==0) {
    *handled = TRUE;
    return RenameCmd(cmd+sizeof("%'ModuleName'"), io);
%endif
%ifdef PrintFile
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "%'ModuleName' print", sizeof("%'ModuleName' print")-1)==0) {
    *handled = TRUE;
    return PrintCmd(cmd+sizeof("%'ModuleName'"), io);
%endif
%ifdef PrintDiskInfo
  } else if (%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' diskinfo")==0) {
    *handled = TRUE;
    return %'ModuleName'%.%PrintDiskInfo(0, io);
%endif
%ifdef PrintSector
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "%'ModuleName' sector", sizeof("%'ModuleName' sector")-1)==0) {
    *handled = TRUE;
    return SectorCmd(cmd+sizeof("%'ModuleName'"), io);
%endif
%ifdef Benchmark
  } else if (%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' benchmark")==0) {
    *handled = TRUE;
    return %'ModuleName'%.%Benchmark(io);
%endif
  }
  return ERR_OK;
}

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN CheckCardPresence
%ifdef CheckCardPresence
%define! ParcardMounted
%define! Pardrive
%define! ParfileSystemObject
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemCheckCardPresence.Inc
byte %'ModuleName'%.%CheckCardPresence(bool *cardMounted, byte drive, FATFS *fileSystemObject, const %@Shell@'ModuleName'%.StdIOType *io)
{
  if (!(*cardMounted) && %'ModuleName'%.isDiskPresent()) {
    /* card inserted */
    if (%'ModuleName'%.MountFileSystem(fileSystemObject, drive, io)==ERR_OK) {
      *cardMounted = TRUE;
      if (io!=NULL) {
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"File System mounted\r\n", io->stdOut);
      }
    } else {
      return ERR_FAILED;
    }
  } else if (*cardMounted && !%'ModuleName'%.isDiskPresent()) {
    /* card removed */
    if (%'ModuleName'%.UnMountFileSystem(drive, io)==ERR_OK) {
      *cardMounted = FALSE;
      if (io!=NULL) {
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"File System unmounted\r\n", io->stdOut);
      }
    } else {
      return ERR_FAILED;
    }
  }
  return ERR_OK;
}

%endif %- CheckCardPresence
%-BW_METHOD_END CheckCardPresence
%-************************************************************************************************************
%-BW_METHOD_BEGIN MountFileSystem
%ifdef MountFileSystem
%define! ParfileSystemObject
%define! ParlogicalDrive
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemMountFileSystem.Inc
/*!
 * \brief Mounts the file system for a drive
 * \param[in] fileSystemObject Pointer to the file system object
 * \param[in] logicalDrive The drive number to be used
 * \param[in] io IO handler for output
 * \return Error code, ERR_OK for success.
 */
byte %'ModuleName'%.%MountFileSystem(FATFS *fileSystemObject, byte logicalDrive, const %@Shell@'ModuleName'%.StdIOType *io)
{
  %'ModuleName'%.FRESULT fres;

  fres = %'ModuleName'%.mount(logicalDrive, fileSystemObject);
  if (fres != FR_OK) {
    FatFsFResultMsg((unsigned char*)"mount failed", fres, io);
    return ERR_FAILED;
  }
  return ERR_OK;
}

%endif %- MountFileSystem
%-BW_METHOD_END MountFileSystem
%-************************************************************************************************************
%-BW_METHOD_BEGIN UnMountFileSystem
%ifdef UnMountFileSystem
%define! ParlogicalDrive
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemUnMountFileSystem.Inc
/*!
 * \brief Unmounts the file system for a drive
 * \param[in] logicalDrive The drive number to be used
 * \param[in] io IO handler for output
 * \return Error code, ERR_OK for success.
 */
byte %'ModuleName'%.%UnMountFileSystem(byte logicalDrive, const %@Shell@'ModuleName'%.StdIOType *io)
{
  %'ModuleName'%.FRESULT fres;

  fres = %'ModuleName'%.mount(logicalDrive, NULL);
  if (fres != FR_OK) {
    FatFsFResultMsg((unsigned char*)"unmount failed", fres, io);
    return ERR_FAILED;
  }
  return ERR_OK;
}

%endif %- UnMountFileSystem
%-BW_METHOD_END UnMountFileSystem
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintDirectory
%ifdef PrintDirectory
%define! PardirName
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemPrintDirectory.Inc
/*!
 * \brief Prints a directory listing
 * \param[in] dirName Directory to be used
 * \param[in] io IO handler for output
 * \return Error code, ERR_OK for success.
 */
byte %'ModuleName'%.%PrintDirectory(const byte *dirName, const %@Shell@'ModuleName'%.StdIOType *io)
{
  byte res;

  res = PrintDir(dirName, io);
  if (res != ERR_OK) {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"PrintDir failed\r\n", io->stdErr);
    return res;
  }
  return ERR_OK;
}

%endif %- PrintDirectory
%-BW_METHOD_END PrintDirectory
%-************************************************************************************************************
%-BW_METHOD_BEGIN CopyFile
%ifdef CopyFile
%define! ParsrcFileName
%define! PardstFileName
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemCopyFile.Inc
/*!
 * \brief Copy the source file to a destination file
 * \param[in] srcFileName Source file name
 * \param[in] dstFileName Destination file name
 * \param[in] io IO handler for output
 * \return Error code, ERR_OK for success.
 */
byte %'ModuleName'%.%CopyFile(const byte *srcFileName, const byte *dstFileName, const %@Shell@'ModuleName'%.StdIOType *io)
{
#if !%'ModuleName'%.FS_READONLY
  %'ModuleName'%.FIL fsrc, fdst;  /* file objects */
  %'ModuleName'%.FRESULT fres;
  uint8_t buffer[%FileCopyBufferSize];   /* copy buffer */
  UINT br, bw;          /* file read/write counters */
  byte res =  ERR_OK;

  if (%'ModuleName'%.isWriteProtected()) {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"disk is write protected!\r\n", io->stdErr);
    return ERR_FAILED;
  }
  /* open source file */
  fres = %'ModuleName'%.open(&fsrc, (char*)srcFileName, FA_OPEN_EXISTING | FA_READ);
  if (fres != FR_OK) {
    FatFsFResultMsg((unsigned char*)"open source file failed", fres, io);
    return ERR_FAILED;
  }
  /* create destination file */
  fres = %'ModuleName'%.open(&fdst, (char*)dstFileName, FA_CREATE_ALWAYS | FA_WRITE);
  if (fres != FR_OK) {
    FatFsFResultMsg((unsigned char*)"open destination file failed", fres, io);
    return ERR_FAILED;
  }
  /* now copy source to destination */
  for (;;) {
    fres = %'ModuleName'%.read(&fsrc, buffer, sizeof(buffer), &br);
    if (fres != FR_OK) {
      FatFsFResultMsg((unsigned char*)"reading source file failed", fres, io);
      res = ERR_FAILED;
      break;
    }
    if (br == 0) { /* EOF */
      break; /* get out of loop */
    }
    fres = %'ModuleName'%.write(&fdst, buffer, br, &bw);
    if (fres != ERR_OK) {
      FatFsFResultMsg((unsigned char*)"writing destination file failed", fres, io);
      res = ERR_FAILED;
      break;
    }
    if (bw < br) {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"failed writing destination file, or disk full\r\n", io->stdErr);
      res = ERR_FAILED;
      break;
    }
  } /* for */
  /* close all files */
  fres = %'ModuleName'%.close(&fsrc);
  if (fres != FR_OK) {
    FatFsFResultMsg((unsigned char*)"closing source file failed", fres, io);
    res = ERR_FAILED;
  }
  fres = %'ModuleName'%.close(&fdst);
  if (fres != FR_OK) {
    FatFsFResultMsg((unsigned char*)"closing destination file failed", fres, io);
    res = ERR_FAILED;
  }
  return res;
#else
  (void)srcFileName; /* unused argument */
  (void)dstFileName; /* unused argument */
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"File System is in Read-Only mode\r\n", io->stdErr);
  return ERR_FAILED;
#endif
}

%endif %- CopyFile
%-BW_METHOD_END CopyFile
%-************************************************************************************************************
%-BW_METHOD_BEGIN DeleteFile
%ifdef DeleteFile
%define! ParfileName
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemDeleteFile.Inc
/*!
 * \brief Deletes a file
 * \param[in] fileName Name of file to be deleted
 * \param[in] io IO handler for output
 * \return Error code, ERR_OK for success.
 */
byte %'ModuleName'%.%DeleteFile(const byte *fileName, const %@Shell@'ModuleName'%.StdIOType *io)
{
  %'ModuleName'%.FRESULT fres;

  if (%'ModuleName'%.isWriteProtected()) {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"disk is write protected!\r\n", io->stdErr);
    return ERR_FAILED;
  }
  fres = %'ModuleName'%.unlink((char*)fileName);
  if (fres != FR_OK) {
    FatFsFResultMsg((unsigned char*)"unlink failed", fres, io);
    return ERR_FAILED;
  }
  return ERR_OK;
}

%endif %- DeleteFile
%-BW_METHOD_END DeleteFile
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintFile
%ifdef PrintFile
%define! ParfileName
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemPrintFile.Inc
/*!
 * \brief Print the content of a file
 * \param[in] fileName Name of file to be printed
 * \param[in] io IO handler for output
 * \return Error code, ERR_OK for success.
 */
byte %'ModuleName'%.%PrintFile(const byte *fileName, const %@Shell@'ModuleName'%.StdIOType *io)
{
  %'ModuleName'%.FIL file;
  %'ModuleName'%.FRESULT fres;
  UINT nofRead = 0;
  byte buf[%FilePrintBufferSize];
  byte res = ERR_OK;

  fres = %'ModuleName'%.open(&file, (const TCHAR *)fileName, FA_READ);
  if (fres == FR_OK) {
    do {
      nofRead = 0;
      fres=%'ModuleName'%.read(&file, buf, sizeof(buf)-1, &nofRead); /* read one byte less for zero byte */
      if (fres != FR_OK) {
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"fread failed\r\n", io->stdErr);
        res = ERR_FAILED;
      } else {
        buf[nofRead] = '\0'; /* terminate buffer */
        %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
      }
    } while(nofRead>0 && fres==FR_OK);
    fres=%'ModuleName'%.close(&file);
    if (fres != FR_OK) {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"fclose failed\r\n", io->stdErr);
      res = ERR_FAILED;
    }
  } else {
    FatFsFResultMsg((unsigned char*)"open file failed", fres, io);
    res = ERR_FAILED;
  }
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
  return res;
}

%endif %- PrintFile
%-BW_METHOD_END PrintFile
%-************************************************************************************************************
%-BW_METHOD_BEGIN MakeDirectory
%ifdef MakeDirectory
%define! PardirName
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemMakeDirectory.Inc
/*!
 * \brief Creates a new directory
 * \param[in] dirName Name of the directory to be created
 * \param[in] io IO handler for output
 * \return Error code, ERR_OK for success.
 */
byte %'ModuleName'%.%MakeDirectory(const byte *dirName, const %@Shell@'ModuleName'%.StdIOType *io)
{
  %'ModuleName'%.FRESULT fres;

  if (%'ModuleName'%.isWriteProtected()) {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"disk is write protected!\r\n", io->stdErr);
    return ERR_FAILED;
  }
  fres = %'ModuleName'%.mkdir((char*)dirName);
  if(fres!=FR_OK) {
    FatFsFResultMsg((unsigned char*)"mkdir failed", fres, io);
    return ERR_FAILED;
  }
  return ERR_OK;
}

%endif %- MakeDirectory
%-BW_METHOD_END MakeDirectory
%-************************************************************************************************************
%-BW_METHOD_BEGIN ChangeDirectory
%ifdef ChangeDirectory
%define! PardirName
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemChangeDirectory.Inc
byte %'ModuleName'%.%ChangeDirectory(const byte *dirName, const %@Shell@'ModuleName'%.StdIOType *io)
{
#if %'ModuleName'%.FS_RPATH > 0
  %'ModuleName'%.FRESULT fres;

  if ((fres=%'ModuleName'%.chdir((char*)dirName)) != FR_OK) {
    FatFsFResultMsg((unsigned char*)"chdir failed", fres, io);
    return ERR_FAILED;
  }
  return ERR_OK;
#else
  (void)dirName;
  #warning "relative directories not enabled in FatFS!"
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"cd command not available as relative directories not enable in file system\r\n", io->stdErr);
  return ERR_FAILED;
#endif
}

%endif %- ChangeDirectory
%-BW_METHOD_END ChangeDirectory
%-************************************************************************************************************
%-BW_METHOD_BEGIN RenameFile
%ifdef RenameFile
%define! ParsrcFileName
%define! PardstFileName
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemRenameFile.Inc
/*!
 * \brief Renames a file
 * \param[in] srcFileName Source/existing file name
 * \param[in] dstFileName Destination/new file name
 * \param[in] io IO handler for output
 * \return Error code, ERR_OK for success.
 */
byte %'ModuleName'%.%RenameFile(const byte *srcFileName, const byte *dstFileName, const %@Shell@'ModuleName'%.StdIOType *io)
{
  %'ModuleName'%.FRESULT fres;

  if (%'ModuleName'%.isWriteProtected()) {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"disk is write protected!\r\n", io->stdErr);
    return ERR_FAILED;
  }
  fres = %'ModuleName'%.rename((char*)srcFileName, (char*)dstFileName);
  if(fres!=FR_OK) {
    FatFsFResultMsg((unsigned char*)"rename failed", fres, io);
    return ERR_FAILED;
  }
  return ERR_OK;
}

%endif %- RenameFile
%-BW_METHOD_END RenameFile
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintSector
%ifdef PrintSector
%define! Pardrive
%define! ParsectorNo
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemPrintSector.Inc
%if defined(UseRTOSDynamicMemory) & %UseRTOSDynamicMemory='yes'
#define PRINT_BUF_SIZE   %'ModuleName'%.MAX_SS
%else
static byte print_buf[%'ModuleName'%.MAX_SS];
#define PRINT_BUF_SIZE   sizeof(print_buf)
%endif
byte %'ModuleName'%.%PrintSector(byte drive, dword sectorNo, const %@Shell@'ModuleName'%.StdIOType *io)
{
  word i;
  unsigned char buf[8];
  %'ModuleName'%.DRESULT dres;
%if defined(UseRTOSDynamicMemory) & %UseRTOSDynamicMemory='yes'
#if FRTOS_MEMORY_SCHEME==1 /* this scheme does not allow deallocation of memory */
  static unsigned char *print_buf=NULL; /* use global buffer pointer, allocated only once, and not deallocated! */
#else
  unsigned char *print_buf;
#endif
%endif

  if ((disk_initialize(drive)&STA_NOINIT)!=RES_OK) {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"disk initialize failed\r\n", io->stdErr);
    return ERR_FAILED;
  }
%if defined(UseRTOSDynamicMemory) & %UseRTOSDynamicMemory='yes'
#if FRTOS_MEMORY_SCHEME==1 /* this scheme does not allow deallocation of memory */
  if (print_buf!=NULL) { /* only if not allocated yet */
    print_buf = %@RTOS@'ModuleName'%.pvPortMalloc(PRINT_BUF_SIZE);
  }
#else
  print_buf = %@RTOS@'ModuleName'%.pvPortMalloc(PRINT_BUF_SIZE);
#endif
  if (print_buf == NULL) {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"allocating memory failed\r\n", io->stdErr);
    return ERR_FAILED;
  }
%endif
  dres = disk_read(drive, &print_buf[0], sectorNo, 1);
  if (dres==RES_OK) { /* read one sector */
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"dumping disk sector: 0x", io->stdOut);
    buf[0] = '\0';
    %@Utility@'ModuleName'%.strcatNum32Hex(buf, PRINT_BUF_SIZE, sectorNo);
    %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
    for(i=0; i<PRINT_BUF_SIZE; i++) {
      if ((i%%16)==0) { /* new line to make things readable */
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n0x", io->stdOut);
        buf[0] = '\0';
        %@Utility@'ModuleName'%.strcatNum16Hex(buf, PRINT_BUF_SIZE, i);
        %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
        %@Shell@'ModuleName'%.SendStr((unsigned char*)": ", io->stdOut);
      }
      buf[0] = '\0';
      %@Utility@'ModuleName'%.strcatNum8Hex(buf, PRINT_BUF_SIZE, (uint8_t)print_buf[i]);
      %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
      %@Shell@'ModuleName'%.SendStr((unsigned char*)" ", io->stdOut);
    }
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
  } else {
    FatFsDResultMsg((unsigned char*)"disk_read failed", dres, io);
  }
%if defined(UseRTOSDynamicMemory) & %UseRTOSDynamicMemory='yes'
#if FRTOS_MEMORY_SCHEME!=1 /* this scheme does not allow deallocation of memory */
  %@RTOS@'ModuleName'%.vPortFree(print_buf);
#endif
%endif
  if (dres==RES_OK) {
    return ERR_OK;
  } else {
    return ERR_FAILED;
  }
}

%endif %- PrintSector
%-BW_METHOD_END PrintSector
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintDiskInfo
%ifdef PrintDiskInfo
%define! Pardrive
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemPrintDiskInfo.Inc
/*!
 * \brief Prints information about the disk
 * \param[in] drive Disk drive number, starting with zero
 * \param[in] io IO handler for output
 * \return Error code, ERR_OK for success.
 */
byte %'ModuleName'%.%PrintDiskInfo(byte drive, const %@Shell@'ModuleName'%.StdIOType *io)
{
  /* see for details:
   * http://www.retroleum.co.uk/electronics-articles/basic-mmc-card-access/
   */
  uint8_t buf[8];
  int32_t val32;
  int16_t val16;
  int8_t val8;
  uint8_t buff[64];
  uint8_t driverVersion; /* 0: SPI, 1: SDHC_LDD */

  if ((disk_initialize(drive)&STA_NOINIT)!=0) {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"disk initialize failed\r\n", io->stdErr);
    return ERR_FAILED;
  }
  if (disk_ioctl(0, MMC_GET_DRIVER_VERSION, &driverVersion)!=RES_OK) {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"failed identification of driver version\r\n", io->stdErr);
    return ERR_FAILED;
  }
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"Card type", (unsigned char*)"", io->stdOut);
  if (disk_ioctl(0, MMC_GET_TYPE, &val8)==RES_OK) {
    if (val8&CT_SD1) {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"SD1 ", io->stdOut);
    }
    if (val8&CT_SD2) {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"SD2 ", io->stdOut);
    }
    if (val8&CT_BLOCK) {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"BLOCK ", io->stdOut);
    }
    if (val8&CT_MMC) {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"MMC ", io->stdOut);
    }
    if (val8&CT_SDC) {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"SDC ", io->stdOut);
    }
    if (val8&CT_ATA) {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"ATA ", io->stdOut);
    }
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
  } else {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"ERROR\r\n", io->stdOut);
  }
  if (driverVersion==0) { /* only SPI cards implement this */
    %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"SDC version", (unsigned char*)"", io->stdOut);
    if (disk_ioctl(0, MMC_GET_SDC_VERSION, &val8)==RES_OK) {
      if (val8==1) {
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"SDC ver 1.XX or MMC\r\n", io->stdOut);
      } else if (val8==2) {
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"SDC ver 2.00\r\n", io->stdOut);
      } else {
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"unknown\r\n", io->stdOut);
      }
    } else {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"ERROR\r\n", io->stdOut);
    }
  }
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"Sector count", (unsigned char*)"", io->stdOut);
  if (disk_ioctl(0, GET_SECTOR_COUNT, &val32)==RES_OK) {
    %@Utility@'ModuleName'%.Num32sToStr(buf, sizeof(buf), val32);
    %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
  } else {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"ERROR\r\n", io->stdOut);
  }
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"Sector size", (unsigned char*)"", io->stdOut);
  if (disk_ioctl(0, GET_SECTOR_SIZE, &val16)==RES_OK) {
    %@Utility@'ModuleName'%.Num16sToStr(buf, sizeof(buf), val16);
    %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
  } else {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"ERROR\r\n", io->stdOut);
  }
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"READ_BL_LEN", (unsigned char*)"", io->stdOut);
  if (disk_ioctl(0, MMC_GET_READ_BL_LEN, &val16)==RES_OK) {
    %@Utility@'ModuleName'%.Num16sToStr(buf, sizeof(buf), val16);
    %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
  } else {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"ERROR\r\n", io->stdOut);
  }
  if (driverVersion==0) { /* only SPI cards implement this */
    %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"Block size", (unsigned char*)"", io->stdOut);
    if (disk_ioctl(0, GET_BLOCK_SIZE, &val32)==RES_OK) {
      %@Utility@'ModuleName'%.Num32sToStr(buf, sizeof(buf), val32);
      %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
    } else {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"ERROR\r\n", io->stdOut);
    }
    %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"CSD", (unsigned char*)"", io->stdOut);
    if (disk_ioctl(0, MMC_GET_CSD, &buff[0])==RES_OK) {
      for(val8=0; val8<16; val8++) {
        buf[0] = '\0';
        %@Utility@'ModuleName'%.strcatNum8Hex(buf, sizeof(buf), (uint8_t)buff[val8]);
        %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
        %@Shell@'ModuleName'%.SendStr((unsigned char*)" ", io->stdOut);
      }
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
    } else {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"ERROR\r\n", io->stdOut);
    }
    %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"CID", (unsigned char*)"", io->stdOut);
    if (disk_ioctl(0, MMC_GET_CID, &buff[0])==RES_OK) {
      for(val8=0; val8<16; val8++) {
        buf[0] = '\0';
        %@Utility@'ModuleName'%.strcatNum8Hex(buf, sizeof(buf), (uint8_t)buff[val8]);
        %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
        %@Shell@'ModuleName'%.SendStr((unsigned char*)" ", io->stdOut);
      }
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n               Manufacturer ", io->stdOut);
      for(val8=3; val8<=8; val8++) {
        io->stdOut(buff[val8]);
      }
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n               Serial Number ", io->stdOut);
      buf[0] = '\0';
      %@Utility@'ModuleName'%.strcatNum32Hex(buf, sizeof(buf), (uint32_t)((buff[0xa]<<24)|(buff[0xb]<<16)|(buff[0xc]<<8)|buff[0xd]));
      %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
    } else {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"ERROR\r\n", io->stdOut);
    }
    %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"OCR", (unsigned char*)"", io->stdOut);
    if (disk_ioctl(0, MMC_GET_OCR, &buff[0])==RES_OK) {
      for(val8=0; val8<4; val8++) {
        buf[0] = '\0';
        %@Utility@'ModuleName'%.strcatNum8Hex(buf, sizeof(buf), (uint8_t)buff[val8]);
        %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
        %@Shell@'ModuleName'%.SendStr((unsigned char*)" ", io->stdOut);
      }
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
    } else {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"ERROR\r\n", io->stdOut);
    }
    %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"SD Status", (unsigned char*)"", io->stdOut);
    if (disk_ioctl(0, MMC_GET_SDSTAT, &buff[0])==RES_OK) {
      for(val8=0; val8<64; val8++) {
        buf[0] = '\0';
        if (val8!=0 && (val8%%16)==0) { /* new line to make things readable */
          %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n               ", io->stdOut);
        }
        %@Utility@'ModuleName'%.strcatNum8Hex(buf, sizeof(buf), (uint8_t)buff[val8]);
       %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
       %@Shell@'ModuleName'%.SendStr((unsigned char*)" ", io->stdOut);
      }
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
    } else {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"ERROR\r\n", io->stdOut);
    }
  }
  if (driverVersion==1) { /* only LLD_SDHD cards implement this */
    buff[1] = sizeof(buf)-2; /* size of buffer */
    buff[0] = MMC_GET_LLD_CMD_HIGH_CAPACITY; /* cmd */
    if (disk_ioctl(0, MMC_GET_LLD_INFO, &buff[0])==RES_OK) {
      %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"High capacity", (unsigned char*)(buff[2]!=0?"yes\r\n":"no\r\n"), io->stdOut);
    }
    buff[0] = MMC_GET_LLD_CMD_HIGH_SPEED; /* cmd */
    if (disk_ioctl(0, MMC_GET_LLD_INFO, &buff[0])==RES_OK) {
      %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"High speed", (unsigned char*)(buff[2]!=0?"yes\r\n":"no\r\n"), io->stdOut);
    }
    buff[0] = MMC_GET_LLD_CMD_LOW_VOLTAGE; /* cmd */
    if (disk_ioctl(0, MMC_GET_LLD_INFO, &buff[0])==RES_OK) {
      %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"Low voltage", (unsigned char*)(buff[2]!=0?"yes\r\n":"no\r\n"), io->stdOut);
    }
    buff[0] = MMC_GET_LLD_CMD_DATA_WIDTHS; /* cmd */
    if (disk_ioctl(0, MMC_GET_LLD_INFO, &buff[0])==RES_OK) {
      %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"Data widths", (unsigned char*)"", io->stdOut);
      if (buff[2]&0x1) {
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"1 ", io->stdOut);
      }
      if (buff[2]&0x2) {
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"4 ", io->stdOut);
      }
      if (buff[2]&0x4) {
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"8 ", io->stdOut);
      }
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
    }
    buff[0] = MMC_GET_LLD_CMD_OPERATIONS; /* cmd */
    if (disk_ioctl(0, MMC_GET_LLD_INFO, &buff[0])==RES_OK) {
      %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"Operations", (unsigned char*)"", io->stdOut);
      if (buff[2]&0x1) {
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"BlockRead ", io->stdOut);
      }
      if (buff[2]&0x2) {
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"BlockWrite ", io->stdOut);
      }
      if (buff[2]&0x4) {
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"BlockErase ", io->stdOut);
      }
      if (buff[2]&0x8) {
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"WriteProtect ", io->stdOut);
      }
      if (buff[2]&0x10) {
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"I/O ", io->stdOut);
      }
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
    }
  }
  return ERR_OK;
}

%endif %- PrintDiskInfo
%-BW_METHOD_END PrintDiskInfo
%-************************************************************************************************************
%-BW_METHOD_BEGIN Benchmark
%ifdef Benchmark
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemBenchmark.Inc
/*! \brief Simple benchmark function: first we are going to write a file, then we will copy it */
byte %'ModuleName'%.%Benchmark(const %@Shell@'ModuleName'%.StdIOType *io)
{
  static FIL fp;
  uint16_t i;
  UINT bw;
  uint8_t read_buf[10];
  TIMEREC time, startTime;
  int32_t start_mseconds, mseconds;

  if (%'ModuleName'%.isWriteProtected()) {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"disk is write protected!\r\n", io->stdErr);
    return ERR_FAILED;
  }
  /* write benchmark */
  %@Shell@'ModuleName'%.SendStr((const unsigned char*)"Benchmark: open file, write 10k times 10 bytes (100'000 bytes), close file:\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendStr((const unsigned char*)"Deleting existing benchmark files...\r\n", io->stdOut);
  (void)%'ModuleName'%.%DeleteFile((const unsigned char*)"./bench.txt", io);
  (void)%'ModuleName'%.%DeleteFile((const unsigned char*)"./copy.txt", io);

  %@Shell@'ModuleName'%.SendStr((const unsigned char*)"Creating benchmark file...\r\n", io->stdOut);
  (void)%@RTC@'ModuleName'%.GetTime(&startTime);
  if (%'ModuleName'%.%open(&fp, "./bench.txt", FA_CREATE_ALWAYS|FA_WRITE)!=FR_OK) {
    %@Shell@'ModuleName'%.SendStr((const unsigned char*)"*** Failed opening benchmark file!\r\n", io->stdErr);
    return ERR_FAILED;
  }
  for(i=0;i<10000;i++) {
    if (%'ModuleName'%.%write(&fp, "benchmark ", sizeof("benchmark ")-1, &bw)!=FR_OK) {
      %@Shell@'ModuleName'%.SendStr((const unsigned char*)"*** Failed writing file!\r\n", io->stdErr);
      (void)%'ModuleName'%.%close(&fp);
      return ERR_FAILED;
    }
  }
  (void)%'ModuleName'%.%close(&fp);
  (void)%@RTC@'ModuleName'%.GetTime(&time);
  start_mseconds = startTime.Hour*60*60*1000 + startTime.Min*60*1000 + startTime.Sec*1000 + startTime.Sec100*10;
  mseconds = time.Hour*60*60*1000 + time.Min*60*1000 + time.Sec*1000 + time.Sec100*10 - start_mseconds;
  %@Shell@'ModuleName'%.SendNum32s(mseconds, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((const unsigned char*)" ms needed for creating.\r\n", io->stdOut);

  /* read benchmark */
  %@Shell@'ModuleName'%.SendStr((const unsigned char*)"Reading benchmark file...\r\n", io->stdOut);
  (void)%@RTC@'ModuleName'%.GetTime(&startTime);
  if (%'ModuleName'%.%open(&fp, "./bench.txt", FA_READ)!=FR_OK) {
    %@Shell@'ModuleName'%.SendStr((const unsigned char*)"*** Failed opening benchmark file!\r\n", io->stdErr);
    return ERR_FAILED;
  }
  for(i=0;i<10000;i++) {
    if (%'ModuleName'%.%read(&fp, &read_buf[0], sizeof(read_buf), &bw)!=FR_OK) {
      %@Shell@'ModuleName'%.SendStr((const unsigned char*)"*** Failed reading file!\r\n", io->stdErr);
      (void)%'ModuleName'%.%close(&fp);
      return ERR_FAILED;
    }
  }
  (void)%'ModuleName'%.%close(&fp);
  (void)%@RTC@'ModuleName'%.GetTime(&time);
  start_mseconds = startTime.Hour*60*60*1000 + startTime.Min*60*1000 + startTime.Sec*1000 + startTime.Sec100*10;
  mseconds = time.Hour*60*60*1000 + time.Min*60*1000 + time.Sec*1000 + time.Sec100*10 - start_mseconds;
  %@Shell@'ModuleName'%.SendNum32s(mseconds, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((const unsigned char*)" ms needed for reading.\r\n", io->stdOut);

  /* copy benchmark */
  %@Shell@'ModuleName'%.SendStr((const unsigned char*)"Copy file (100'000 bytes)...\r\n", io->stdOut);
  (void)%@RTC@'ModuleName'%.GetTime(&startTime);
  (void)%'ModuleName'%.%CopyFile((const unsigned char*)"./bench.txt", (const unsigned char*)"./copy.txt", io);
  (void)%@RTC@'ModuleName'%.GetTime(&time);
  start_mseconds = startTime.Hour*60*60*1000 + startTime.Min*60*1000 + startTime.Sec*1000 + startTime.Sec100*10;
  mseconds = time.Hour*60*60*1000 + time.Min*60*1000 + time.Sec*1000 + time.Sec100*10 - start_mseconds;
  %@Shell@'ModuleName'%.SendNum32s(mseconds, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((const unsigned char*)" ms needed for copy.\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendStr((const unsigned char*)"done!\r\n", io->stdOut);
  return ERR_OK;
}

%endif %- Benchmark
%-BW_METHOD_END Benchmark
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_METHOD_BEGIN OnIdle
%ifdef OnIdle
%IMPLEMENTATION OnIdle
%include Common\FAT_FileSystemOnIdle.Inc
void %OnIdle(void)
{
  /* Write your code here ... */
}

%endif %- OnIdle
%-BW_METHOD_END OnIdle
%-BW_METHOD_BEGIN OnSchedule
%ifdef OnSchedule
%IMPLEMENTATION OnSchedule
%include Common\FAT_FileSystemOnSchedule.Inc
void %OnSchedule(void)
{
  /* Write your code here ... */
}

%endif %- OnSchedule
%-BW_METHOD_END OnSchedule
%-BW_METHOD_BEGIN OnCreateSyncObject
%ifdef OnCreateSyncObject
%IMPLEMENTATION OnCreateSyncObject
%define! Parsobj
%include Common\FAT_FileSystemOnCreateSyncObject.Inc
void %OnCreateSyncObject(void *sobj)
{
  /* Write your code here ... */
}

%endif %- OnCreateSyncObject
%-BW_METHOD_END OnCreateSyncObject
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This bean is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
