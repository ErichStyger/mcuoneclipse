/* ###################################################################
**     This component module is generated by Processor Expert. Do not modify it.
**     Filename    : McuRTOS.h
**     Project     : FRDM-K64F_Generator
**     Processor   : MK64FN1M0VLL12
**     Component   : FreeRTOS
**     Version     : Component 01.586, Driver 01.00, CPU db: 3.00.000
**     Compiler    : GNU C Compiler
**     Date/Time   : 2024-07-29, 14:57, # CodeGen: 841
**     Abstract    :
**          This component implements the FreeRTOS Realtime Operating System
**     Settings    :
**          Component name                                 : McuRTOS
**          RTOS Version                                   : V11.0.0
**          SDK                                            : McuLib
**          Kinetis SDK                                    : Disabled
**          Custom Port                                    : Custom port settings
**            Compiler                                     : automatic
**            Source Folders                               : Enabled
**              Source Folder                              : FreeRTOS/Source
**              Header Folder                              : FreeRTOS/Source/include
**              Port Folder                                : FreeRTOS/Source/portable/GCC/ARM_CM4F
**              MemMang Folder                             : FreeRTOS/Source/portable/MemMang
**              Common Folder                              : FreeRTOS/Source/portable/Common
**              Config Folder                              : config
**              Manual Clock Values                        : Enabled
**                configCPU_CLOCK_HZ                       : CPU_CORE_CLK_HZ
**                configBUS_CLOCK_HZ                       : CPU_BUS_CLK_HZ
**            Custom portBASE_TYPE                         : Disabled
**          Classic CodeWarrior                            : no
**          Disabled Interrupts in Startup                 : yes
**          configASSERT                                   : yes
**          Application Task Tags                          : no
**          Thread Local Storage Pointers                  : 0
**          Use Trace Facility                             : yes
**          Debug Helpers                                  : 
**            Enable GDB Debug Helper                      : no
**            uxTopUsedPriority                            : yes
**            Heap Indication Constant                     : yes
**          Segger System Viewer Trace                     : Disabled
**          Percepio Trace                                 : Disabled
**          Generate Runtime Statistics                    : Enabled
**            Use Tick Counter                             : yes
**            LDD                                          : Disabled
**            non-LDD                                      : Disabled
**          Scheduler                                      : Settings for the scheduler
**            ColdFire V1                                  : Disabled
**            ColdFire V2                                  : Disabled
**            ARM (Kinetis)                                : Enabled
**              ARM Family                                 : Cortex-M4F
**              Max SysCall Interrupt Priority             : 5
**              RTOS Interrupt Priority                    : 15
**              Lowest Interrupt Priority                  : 15
**              Compiler Optimization Level                : 0
**              MPU                                        : no
**              SysTick                                    : Enabled
**                Core Clock                               : yes
**              Low Power Timer                            : Disabled
**            non-LDD SWI                                  : Disabled
**            Preemptive                                   : yes
**            Optimized Task Selection                     : no
**            Time Slicing                                 : yes
**            Use Co-Routines                              : no
**            Idle should yield                            : yes
**            Task Name Length                             : 12
**            Minimal Stack Size                           : 200
**            Record Stack High Address                    : yes
**            Maximum Priorities                           : 6
**            Maximum Coroutine Priorities                 : 2
**            Stackoverflow checking method                : Method 1
**            Cleanup Resources                            : yes
**            TaskExitError Handler                        : no
**          Ticks                                          : Settings for the periodic tick timer
**            Tickless Idle Mode                           : Disabled
**            Tick Rate (Hz)                               : 1000
**            Use 16bit ticks                              : no
**            non-LDD Tick                                 : Disabled
**            LDD Tick                                     : Disabled
**          Queues                                         : Settings for Queues
**            Queue Registry Size                          : 5
**            Queue Sets                                   : yes
**          Semaphores and Mutexes                         : Settings for Mutex and Semaphore
**            Use Mutexes                                  : yes
**            Use Recursive Mutexes                        : yes
**          Timers                                         : Enabled
**            Priority                                     : (configMAX_PRIORITIES-1U)
**            Queue Length                                 : 10
**            Stack Depth                                  : (configMINIMAL_STACK_SIZE)
**            Use Daemon Task Startup Hook                 : no
**          Memory                                         : Settings for the memory and heap allocation
**            Dynamic Allocation                           : Enabled
**              Heap Size                                  : 8192
**              Application allocated Heap                 : no
**              Memory Allocation Scheme                   : Scheme 4: merge free blocks
**            Static Allocation                            : Disabled
**            User Memory Section                          : Disabled
**          RTOS Adaptor                                   : Configures the RTOS adapter settings
**            Memory allocation                            : Configures how memory is allocated and deallocated.
**              User function for memory allocation        : no
**              User function for memory deallocation      : no
**            Critical section                             : Configures how critical sections are handled.
**              User function for entering critical section : no
**              User function for exiting critical section : no
**          Shell                                          : Enabled
**            Max number of tasks                          : 16
**            Shell                                        : McuShell
**          Utility                                        : McuUtility
**     Contents    :
**         xTaskCreate                          - portBASE_TYPE McuRTOS_xTaskCreate(pdTASK_CODE pvTaskCode, const portCHAR *...
**         xTaskCreateStatic                    - TaskHandle_t McuRTOS_xTaskCreateStatic(pdTASK_CODE pvTaskCode, const portCHAR...
**         vTaskDelete                          - void McuRTOS_vTaskDelete(xTaskHandle pxTask);
**         vTaskStartScheduler                  - void McuRTOS_vTaskStartScheduler(void);
**         vTaskSuspend                         - void McuRTOS_vTaskSuspend(xTaskHandle pxTaskToSuspend);
**         vTaskSuspendAll                      - void McuRTOS_vTaskSuspendAll(void);
**         vTaskResume                          - void McuRTOS_vTaskResume(xTaskHandle pxTaskToResume);
**         xTaskResumeAll                       - portBASE_TYPE McuRTOS_xTaskResumeAll(void);
**         xTaskResumeFromISR                   - portBASE_TYPE McuRTOS_xTaskResumeFromISR(xTaskHandle pxTaskToResume);
**         vTaskStepTick                        - void McuRTOS_vTaskStepTick(portTickType xTicksToJump);
**         xTaskAbortDelay                      - BaseType_t McuRTOS_xTaskAbortDelay(TaskHandle_t xTask);
**         taskYIELD                            - void McuRTOS_taskYIELD(void);
**         taskENTER_CRITICAL                   - void McuRTOS_taskENTER_CRITICAL(void);
**         taskEXIT_CRITICAL                    - void McuRTOS_taskEXIT_CRITICAL(void);
**         taskDISABLE_INTERRUPTS               - void McuRTOS_taskDISABLE_INTERRUPTS(void);
**         taskENABLE_INTERRUPTS                - void McuRTOS_taskENABLE_INTERRUPTS(void);
**         vTaskDelay                           - void McuRTOS_vTaskDelay(portTickType xTicksToDelay);
**         vTaskDelayUntil                      - void McuRTOS_vTaskDelayUntil(portTickType *pxPreviousWakeTime, portTickType...
**         uxTaskPriorityGet                    - unsigned_portBASE_TYPE McuRTOS_uxTaskPriorityGet(xTaskHandle pxTask);
**         xTaskGetTickCount                    - portTickType McuRTOS_xTaskGetTickCount(void);
**         xTaskGetTickCountFromISR             - portTickType McuRTOS_xTaskGetTickCountFromISR(void);
**         vTaskPrioritySet                     - void McuRTOS_vTaskPrioritySet(xTaskHandle pxTask, unsigned_portBASE_TYPE...
**         vSemaphoreCreateBinary               - void McuRTOS_vSemaphoreCreateBinary(xSemaphoreHandle xSemaphore);
**         xSemaphoreCreateBinary               - SemaphoreHandle_t McuRTOS_xSemaphoreCreateBinary(void);
**         xSemaphoreCreateBinaryStatic         - SemaphoreHandle_t McuRTOS_xSemaphoreCreateBinaryStatic(StaticSemaphore_t...
**         xSemaphoreCreateCounting             - xSemaphoreHandle McuRTOS_xSemaphoreCreateCounting(unsigned_portBASE_TYPE...
**         xSemaphoreCreateCountingStatic       - xSemaphoreHandle McuRTOS_xSemaphoreCrea...
**         xSemaphoreGive                       - bool McuRTOS_xSemaphoreGive(xSemaphoreHandle xMutex);
**         xSemaphoreTake                       - bool McuRTOS_xSemaphoreTake(xSemaphoreHandle xMutex, portTickType xBlockTime);
**         uxSemaphoreGetCount                  - UBaseType_t McuRTOS_uxSemaphoreGetCount(SemaphoreHandle_t xSemaphore);
**         xSemaphoreGiveFromISR                - bool McuRTOS_xSemaphoreGiveFromISR(xSemaphoreHandle xSemaphore,...
**         xSemaphoreTakeFromISR                - bool McuRTOS_xSemaphoreTakeFromISR(xSemaphoreHandle xSemaphore,...
**         xSemaphoreGetMutexHolder             - void* McuRTOS_xSemaphoreGetMutexHolder(xSemaphoreHandle xSemaphore);
**         xSemaphoreCreateMutex                - xSemaphoreHandle McuRTOS_xSemaphoreCreateMutex(void);
**         xSemaphoreCreateMutexStatic          - xSemaphoreHandle McuRTOS_xSemaphoreCreateMutexStatic(StaticSemaphore_t...
**         xSemaphoreCreateRecursiveMutex       - xSemaphoreHandle McuRTOS_xSemaphoreCreateRecursiveMutex(void);
**         xSemaphoreCreateRecursiveMutexStatic - xSemaphoreHandle McuRTOS_xSemaphoreCrea...
**         xSemaphoreTakeRecursive              - bool McuRTOS_xSemaphoreTakeRecursive(xSemaphoreHandle xMutex, portTickType...
**         xSemaphoreGiveRecursive              - bool McuRTOS_xSemaphoreGiveRecursive(xSemaphoreHandle xMutex);
**         vSemaphoreDelete                     - void McuRTOS_vSemaphoreDelete(xSemaphoreHandle xSemaphore);
**         pvPortMalloc                         - pVoid McuRTOS_pvPortMalloc(size_t xWantedSize);
**         vPortFree                            - void McuRTOS_vPortFree(void *pv);
**         xPortGetFreeHeapSize                 - Tsize_t McuRTOS_xPortGetFreeHeapSize(void);
**         xTaskGetCurrentTaskHandle            - xTaskHandle McuRTOS_xTaskGetCurrentTaskHandle(void);
**         xTaskGetIdleTaskHandle               - xTaskHandle McuRTOS_xTaskGetIdleTaskHandle(void);
**         xTaskGetHandle                       - TaskHandle_t McuRTOS_xTaskGetHandle(const char *pcNameToQuery );
**         pcTaskGetTaskName                    - signed char McuRTOS_pcTaskGetTaskName(xTaskHandle xTaskToQuery);
**         eTaskGetState                        - eTaskState McuRTOS_eTaskGetState(xTaskHandle xTask);
**         xTaskGetSchedulerState               - portBASE_TYPE McuRTOS_xTaskGetSchedulerState(void);
**         vTaskList                            - void McuRTOS_vTaskList(signed portCHAR *pcWriteBuffer, size_t bufSize);
**         uxTaskGetStackHighWaterMark          - unsigned_portBASE_TYPE McuRTOS_uxTaskGetStackHighWaterMark(xTaskHandle xTask);
**         uxTaskGetNumberOfTasks               - unsigned_portBASE_TYPE McuRTOS_uxTaskGetNumberOfTasks(void);
**         vTaskGetRunTimeStats                 - void McuRTOS_vTaskGetRunTimeStats(portCHAR *pcWriteBuffer, size_t bufSize);
**         uxQueueMessagesWaiting               - unsigned_portBASE_TYPE McuRTOS_uxQueueMessagesWaiting(xQueueHandle xQueue);
**         uxQueueMessagesWaitingfromISR        - unsigned_portBASE_TYPE McuRTOS_uxQueueMessagesWaitingfromISR(xQueueHandle...
**         xQueueCreate                         - xQueueHandle McuRTOS_xQueueCreate(unsigned_portBASE_TYPE uxQueueLength,...
**         xQueueCreateStatic                   - xQueueHandle McuRTOS_xQueueCreateStatic(unsigned_portBASE_TYPE uxQueueLength,...
**         vQueueDelete                         - void McuRTOS_vQueueDelete(xQueueHandle pxQueueToDelete);
**         xQueueReset                          - portBASE_TYPE McuRTOS_xQueueReset(xQueueHandle xQueue);
**         xQueueSendToBack                     - portBASE_TYPE McuRTOS_xQueueSendToBack(xQueueHandle xQueue, const void...
**         xQueueSendToFront                    - portBASE_TYPE McuRTOS_xQueueSendToFront(xQueueHandle xQueue, const void...
**         xQueueReceive                        - portBASE_TYPE McuRTOS_xQueueReceive(xQueueHandle xQueue, void *pvBuffer,...
**         xQueueOverwrite                      - portBASE_TYPE McuRTOS_xQueueOverwrite(xQueueHandle xQueue, const void...
**         xQueueOverwriteFromISR               - portBASE_TYPE McuRTOS_xQueueOverwriteFromISR(xQueueHandle xQueue, const void...
**         xQueuePeek                           - portBASE_TYPE McuRTOS_xQueuePeek(xQueueHandle xQueue, void *pvBuffer,...
**         xQueuePeekFromISR                    - portBASE_TYPE McuRTOS_xQueuePeekFromISR(xQueueHandle xQueue, void *pvBuffer,...
**         xQueueSendToBackFromISR              - portBASE_TYPE McuRTOS_xQueueSendToBackFromISR(xQueueHandle xQueue, const void...
**         xQueueSendToFrontFromISR             - portBASE_TYPE McuRTOS_xQueueSendToFrontFromISR(xQueueHandle xQueue, const...
**         xQueueReceiveFromISR                 - portBASE_TYPE McuRTOS_xQueueReceiveFromISR(xQueueHandle xQueue, void...
**         vQueueAddToRegistry                  - void McuRTOS_vQueueAddToRegistry(xQueueHandle xQueue, char *pcQueueName);
**         vQueueUnregisterQueue                - void McuRTOS_vQueueUnregisterQueue(xQueueHandle xQueue);
**         xQueueIsQueueFullFromISR             - portBASE_TYPE McuRTOS_xQueueIsQueueFullFromISR(xQueueHandle xQueue);
**         xQueueIsQueueEmptyFromISR            - portBASE_TYPE McuRTOS_xQueueIsQueueEmptyFromISR(xQueueHandle xQueue);
**         xQueueCreateSet                      - xQueueSetHandle McuRTOS_xQueueCreateSet(unsigned portBASE_TYPE...
**         xQueueAddToSet                       - portBASE_TYPE McuRTOS_xQueueAddToSet(xQueueSetMemberHandle xQueueOrSemaphore,...
**         xQueueRemoveFromSet                  - portBASE_TYPE McuRTOS_xQueueRemoveFromSet(xQueueSetMemberHandle...
**         xQueueSelectFromSet                  - xQueueSetMemberHandle McuRTOS_xQueueSelectFromSet(xQueueSetHandle xQueueSet,...
**         xQueueSelectFromSetFromISR           - xQueueSetMemberHandle McuRTOS_xQueueSelectFromSetFromISR(xQueueSetHandle...
**         xEventGroupCreate                    - EventGroupHandle_t McuRTOS_xEventGroupCreate(void);
**         xEventGroupCreateStatic              - EventGroupHandle_t McuRTOS_xEventGroupCreateStatic(StaticEventGroup_t...
**         xEventGroupWaitBits                  - byte McuRTOS_xEventGroupWaitBits(const EventGroupHandle_t xEventGroup, const...
**         xEventGroupSetBits                   - EventBits_t McuRTOS_xEventGroupSetBits(EventGroupHandle_t xEventGroup, const...
**         xEventGroupSetBitsFromISR            - EventBits_t McuRTOS_xEventGroupSetBitsFromISR(EventGroupHandle_t xEventGroup,...
**         xEventGroupClearBits                 - EventBits_t McuRTOS_xEventGroupClearBits(EventGroupHandle_t xEventGroup,...
**         xEventGroupClearBitsFromISR          - EventBits_t McuRTOS_xEventGroupClearBitsFromISR(EventGroupHandle_t...
**         xEventGroupGetBits                   - EventBits_t McuRTOS_xEventGroupGetBits(EventGroupHandle_t xEventGroup);
**         xEventGroupGetBitsFromISR            - EventBits_t McuRTOS_xEventGroupGetBitsFromISR(EventGroupHandle_t xEventGroup);
**         xEventGroupSync                      - EventBits_t McuRTOS_xEventGroupSync(EventGroupHandle_t xEventGroup, const...
**         xTimerCreate                         - TimerHandle_t McuRTOS_xTimerCreate(const char * const pcTimerName, const...
**         xTimerCreateStatic                   - TimerHandle_t McuRTOS_xTimerCreateStatic(const char * const pcTimerName,...
**         xTimerIsTimerActive                  - BaseType_t McuRTOS_xTimerIsTimerActive(TimerHandle_t xTimer);
**         xTimerStart                          - BaseType_t McuRTOS_xTimerStart(TimerHandle_t xTimer, TickType_t xBlockTime);
**         xTimerStop                           - BaseType_t McuRTOS_xTimerStop(TimerHandle_t xTimer, TickType_t xBlockTime);
**         xTimerChangePeriod                   - BaseType_t McuRTOS_xTimerChangePeriod(TimerHandle_t xTimer, TickType_t...
**         xTimerDelete                         - BaseType_t McuRTOS_xTimerDelete(TickType_t xTimer, TickType_t xBlockTime);
**         xTimerReset                          - BaseType_t McuRTOS_xTimerReset(TimerHandle_t xTimer, TickType_t xBlockTime);
**         xTimerStartFromISR                   - BaseType_t McuRTOS_xTimerStartFromISR(TimerHandle_t xTimer, BaseType_t...
**         xTimerStopFromISR                    - BaseType_t McuRTOS_xTimerStopFromISR(TimerHandle_t xTimer, BaseType_t...
**         xTimerChangePeriodFromISR            - BaseType_t McuRTOS_xTimerChangePeriodFromISR(TimerHandle_t xTimer, TickType_t...
**         xTimerResetFromISR                   - BaseType_t McuRTOS_xTimerResetFromISR(TimerHandle_t xTimer, BaseType_t...
**         pvTimerGetTimerID                    - void* McuRTOS_pvTimerGetTimerID(TimerHandle_t xTimer);
**         xTimerGetTimerDaemonTaskHandle       - TaskHandle_t McuRTOS_xTimerGetTimerDaemonTaskHandle(void);
**         pcTimerGetTimerName                  - char* McuRTOS_pcTimerGetTimerName(TimerHandle_t xTimer);
**         xTimerPendFunctionCall               - BaseType_t McuRTOS_xTimerPendFunctionCall(PendedFunction_t xFunctionToPend,...
**         xTimerPendFunctionCallFromISR        - BaseType_t McuRTOS_xTimerPendFunctionCallFromISR(PendedFunction_t...
**         xTaskNotifyGive                      - BaseType_t McuRTOS_xTaskNotifyGive(TaskHandle_t xTaskToNotify);
**         vTaskNotifyGiveFromISR               - void McuRTOS_vTaskNotifyGiveFromISR(TaskHandle_t xTaskToNotify, BaseType_t...
**         ulTaskNotifyTake                     - uint32_t McuRTOS_ulTaskNotifyTake(BaseType_t xClearCountOnExit, TickType_t...
**         xTaskNotify                          - BaseType_t McuRTOS_xTaskNotify(TaskHandle_t xTaskToNotify, uint32_t ulValue,...
**         xTaskNotifyFromISR                   - BaseType_t McuRTOS_xTaskNotifyFromISR(TaskHandle_t xTaskToNotify, uint32_t...
**         xTaskNotifyAndQuery                  - BaseType_t McuRTOS_xTaskNotifyAndQuery(TaskHandle_t xTaskToNotify, uint32_t...
**         xTaskNotifyAndQueryFromISR           - BaseType_t McuRTOS_xTaskNotifyAndQueryFromISR(TaskHandle_t xTaskToNotify,...
**         xTaskNotifyWait                      - BaseType_t McuRTOS_xTaskNotifyWait(uint32_t ulBitsToClearOnEntry, uint32_t...
**         xTaskNotifyStateClear                - BaseType_t McuRTOS_xTaskNotifyStateClear(TaskHandle_t xTask);
**         vTaskSetThreadLocalStoragePointer    - void McuRTOS_vTaskSetThreadLocalStoragePointer(TaskHandle_t xTaskToSet,...
**         pvTaskGetThreadLocalStoragePointer   - void* McuRTOS_pvTaskGetThreadLocalStoragePointer(TaskHandle_t xTaskToQuery,...
**         pcTaskGetName                        - char* McuRTOS_pcTaskGetName(TaskHandle_t xTaskToQuery);
**         vTaskGetInfo                         - void McuRTOS_vTaskGetInfo(TaskHandle_t xTask, TaskStatus_t *pxTaskStatus,...
**         ParseCommand                         - uint8_t McuRTOS_ParseCommand(const unsigned char *cmd, bool *handled, const...
**         AppConfigureTimerForRuntimeStats     - void McuRTOS_AppConfigureTimerForRuntimeStats(void);
**         AppGetRuntimeCounterValueFromISR     - uint32_t McuRTOS_AppGetRuntimeCounterValueFromISR(void);
**         Deinit                               - void McuRTOS_Deinit(void);
**         Init                                 - void McuRTOS_Init(void);
**
** * FreeRTOS (c) Copyright 2003-2023 Richard Barry/Amazon, http: www.FreeRTOS.org
**  * See separate FreeRTOS licensing terms.
**  *
**  * FreeRTOS Processor Expert Component: (c) Copyright Erich Styger, 2013-2023
**  * Web:         https://mcuoneclipse.com
**  * SourceForge: https://sourceforge.net/projects/mcuoneclipse
**  * Git:         https://github.com/ErichStyger/McuOnEclipse_PEx
**  * All rights reserved.
**  *
**  * Redistribution and use in source and binary forms, with or without modification,
**  * are permitted provided that the following conditions are met:
**  *
**  * - Redistributions of source code must retain the above copyright notice, this list
**  *   of conditions and the following disclaimer.
**  *
**  * - Redistributions in binary form must reproduce the above copyright notice, this
**  *   list of conditions and the following disclaimer in the documentation and/or
**  *   other materials provided with the distribution.
**  *
**  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
** ###################################################################*/
/*!
** @file McuRTOS.h
** @version 01.00
** @brief
**          This component implements the FreeRTOS Realtime Operating System
*/         
/*!
**  @addtogroup McuRTOS_module McuRTOS module documentation
**  @{
*/         

/* MODULE McuRTOS. */
#include "McuRTOS.h"
#if McuLib_CONFIG_SDK_USE_FREERTOS

#if !McuLib_CONFIG_CPU_IS_ESP32
  #include "portTicks.h"               /* interface to tick counter */
#endif
#if configSYSTICK_USE_LOW_POWER_TIMER && McuLib_CONFIG_NXP_SDK_USED
  #if McuLib_CONFIG_CPU_IS_KINETIS
    #include "fsl_clock.h"
  #elif McuLib_CONFIG_CPU_IS_LPC && McuLib_CONFIG_CPU_VARIANT==McuLib_CONFIG_CPU_VARIANT_NXP_LPC804
    #include "fsl_wkt.h"
  #endif
#endif
#include "McuUtility.h"
#if configHEAP_SCHEME_IDENTIFICATION
  /* special variable identifying the used heap scheme */
  const uint8_t freeRTOSMemoryScheme = configUSE_HEAP_SCHEME;
#endif


#if (configUSE_TOP_USED_PRIORITY || configLTO_HELPER) && !McuLib_CONFIG_CPU_IS_ESP32
  /* This is only really needed for debugging with openOCD:
   * Since at least FreeRTOS V7.5.3 uxTopUsedPriority is no longer
   * present in the kernel, so it has to be supplied by other means for
   * OpenOCD's threads awareness.
   *
   * Add this file to your project, and, if you're using --gc-sections,
   * ``--undefined=uxTopUsedPriority'' (or
   * ``-Wl,--undefined=uxTopUsedPriority'' when using gcc for final
   * linking) to your LDFLAGS; same with all the other symbols you need.
   */
#if 0 /* FreeRTOS V10.5.1 has it re-added to the kernel */
  const int
  #ifdef __GNUC__
  __attribute__((used))
  #endif
  uxTopUsedPriority = configMAX_PRIORITIES-1;
#endif
#endif

#if configUSE_SHELL
static uint8_t PrintTaskList(const McuShell_StdIOType *io) {
#if tskKERNEL_VERSION_MAJOR>=10 && !McuLib_CONFIG_CPU_IS_ESP32
  #define SHELL_MAX_NOF_TASKS 16 /* maximum number of tasks, as specified in the properties */
  UBaseType_t nofTasks, i;
  TaskHandle_t taskHandles[SHELL_MAX_NOF_TASKS];
  StackType_t *stackBeg, *stackEnd, *topOfStack;
  uint8_t staticallyAllocated;
  uint8_t tmpBuf[32];
  uint16_t stackSize;
#endif
#if configUSE_TRACE_FACILITY && !((tskKERNEL_VERSION_MAJOR<10) || McuLib_CONFIG_CPU_IS_ESP32)
  TaskStatus_t taskStatus;
#endif
  uint8_t buf[32];
  uint8_t res;
#if configGENERATE_RUN_TIME_STATS
  uint32_t ulTotalTime;
#endif
#if configUSE_TRACE_FACILITY
  #define PAD_STAT_TASK_TCB             (sizeof("TCB ")-1)
#endif
  #define PAD_STAT_TASK_STATIC          (sizeof("yes(2) ")-1)
  #define PAD_STAT_TASK_HANDLE          (sizeof("0x20000398 ")-1)
  #define PAD_STAT_TASK_NAME            (configMAX_TASK_NAME_LEN+1)
#if configUSE_TRACE_FACILITY
  #define PAD_STAT_TASK_STATE           (sizeof("Suspended")-1)
#endif
#if configUSE_TRACE_FACILITY
  #define PAD_STAT_TASK_PRIO            (sizeof("(10,12) ")-1)
#else
  #define PAD_STAT_TASK_PRIO            (sizeof("Prio ")-1)
#endif
  #define PAD_STAT_TASK_STACK_BEG       (sizeof("0x20000398 ")-1)
  #define PAD_STAT_TASK_STACK_END       (sizeof("0x20000398 ")-1)
  #define PAD_STAT_TASK_STACK_SIZE      (sizeof("12000 B ")-1)
  #define PAD_STAT_TASK_STACK_TOP       (sizeof("0x200006FC (  132 B) ")-1)
#if configUSE_TRACE_FACILITY
  #define PAD_STAT_TASK_STACK_MARK      (sizeof("12345 B ")-1)
#endif
#if configGENERATE_RUN_TIME_STATS
  #define PAD_STAT_TASK_RUNTIME         (sizeof("0x20000398 (100%)")-1)
#endif

  res = ERR_OK;
#if !configUSE_TRACE_FACILITY
  McuShell_SendStr((uint8_t*)"Info: Enable configUSE_TRACE_FACILITY for additional task information.\r\n", io->stdOut);
#endif
#if !configGENERATE_RUN_TIME_STATS
  McuShell_SendStr((uint8_t*)"Info: Enable configGENERATE_RUN_TIME_STATS for runtime statistics.\r\n", io->stdOut);
#endif
  /* header */
#if configUSE_TRACE_FACILITY
  buf[0] = '\0';
  McuUtility_strcatPad(buf, sizeof(buf), (const unsigned char*)"TCB", ' ', PAD_STAT_TASK_TCB);
  McuShell_SendStr(buf, io->stdOut);
#endif
  buf[0] = '\0';
  McuUtility_strcatPad(buf, sizeof(buf), (const unsigned char*)"Static", ' ', PAD_STAT_TASK_STATIC);
  McuShell_SendStr(buf, io->stdOut);

  buf[0] = '\0';
  McuUtility_strcatPad(buf, sizeof(buf), (const unsigned char*)"Handle", ' ', PAD_STAT_TASK_HANDLE);
  McuShell_SendStr(buf, io->stdOut);

  buf[0] = '\0';
  McuUtility_strcatPad(buf, sizeof(buf), (const unsigned char*)"Name", ' ', PAD_STAT_TASK_NAME);
  McuShell_SendStr(buf, io->stdOut);

#if configUSE_TRACE_FACILITY
  buf[0] = '\0';
  McuUtility_strcatPad(buf, sizeof(buf), (const unsigned char*)"State", ' ', PAD_STAT_TASK_STATE);
  McuShell_SendStr(buf, io->stdOut);
#endif
  buf[0] = '\0';
  McuUtility_strcatPad(buf, sizeof(buf), (const unsigned char*)"Prio", ' ', PAD_STAT_TASK_PRIO);
  McuShell_SendStr(buf, io->stdOut);

  buf[0] = '\0';
  McuUtility_strcatPad(buf, sizeof(buf), (const unsigned char*)"Stack Beg", ' ', PAD_STAT_TASK_STACK_BEG);
  McuShell_SendStr(buf, io->stdOut);

  buf[0] = '\0';
  McuUtility_strcatPad(buf, sizeof(buf), (const unsigned char*)"Stack End", ' ', PAD_STAT_TASK_STACK_END);
  McuShell_SendStr(buf, io->stdOut);

  buf[0] = '\0';
  McuUtility_strcatPad(buf, sizeof(buf), (const unsigned char*)"Size", ' ', PAD_STAT_TASK_STACK_SIZE);
  McuShell_SendStr(buf, io->stdOut);

  buf[0] = '\0';
  McuUtility_strcatPad(buf, sizeof(buf), (const unsigned char*)"Stack Top", ' ', PAD_STAT_TASK_STACK_TOP);
  McuShell_SendStr(buf, io->stdOut);
#if configUSE_TRACE_FACILITY
  buf[0] = '\0';
  McuUtility_strcatPad(buf, sizeof(buf), (const unsigned char*)"Unused", ' ', PAD_STAT_TASK_STACK_MARK);
  McuShell_SendStr(buf, io->stdOut);
#endif
#if configGENERATE_RUN_TIME_STATS
  buf[0] = '\0';
  McuUtility_strcatPad(buf, sizeof(buf), (const unsigned char*)"Runtime", ' ', PAD_STAT_TASK_RUNTIME);
  McuShell_SendStr(buf, io->stdOut);
#endif
  McuShell_SendStr((unsigned char*)"\r\n", io->stdOut);

#if configGENERATE_RUN_TIME_STATS
  ulTotalTime = portGET_RUN_TIME_COUNTER_VALUE(); /* get total time passed in system */
  ulTotalTime /= 100UL; /* For percentage calculations. */
#endif

#if (tskKERNEL_VERSION_MAJOR<10) || McuLib_CONFIG_CPU_IS_ESP32 /* otherwise xGetTaskHandles(), vTaskGetStackInfo(), pcTaskGetName() not available */
  McuShell_SendStr((unsigned char*)"FreeRTOS version must be at least 10.0.0 and not for ESP32\r\n", io->stdOut);
#else
  nofTasks = uxTaskGetNumberOfTasks();
  if (nofTasks>SHELL_MAX_NOF_TASKS) {
    McuUtility_strcpy(buf, sizeof(buf), (const unsigned char*)"WARNING: more tasks than Shell maximum number of tasks.\r\n");
    McuShell_SendStr(buf, io->stdErr);
    nofTasks = SHELL_MAX_NOF_TASKS;
  }
  /* get task handles of all tasks. */
  nofTasks = xGetTaskHandles(&taskHandles[0], SHELL_MAX_NOF_TASKS);
  for(i=0;i<nofTasks;i++) {
    if (taskHandles[i]!=NULL) {
    #if configUSE_TRACE_FACILITY
      vTaskGetInfo(taskHandles[i], &taskStatus, pdTRUE, eInvalid);
    #endif
      vTaskGetStackInfo(taskHandles[i], &stackBeg, &stackEnd, &topOfStack, &staticallyAllocated);

#if configUSE_TRACE_FACILITY
      /* TCB */
      tmpBuf[0] = '\0';
      McuUtility_strcatNum32u(tmpBuf, sizeof(tmpBuf), (uint32_t)taskStatus.xTaskNumber);
      buf[0] = '\0';
      McuUtility_strcatPad(buf, sizeof(buf), tmpBuf, ' ', PAD_STAT_TASK_TCB);
      McuShell_SendStr(buf, io->stdOut);
#endif
      /* Static */
      tmpBuf[0] = '\0';
      if (staticallyAllocated==0) {
        McuUtility_strcpy(tmpBuf, sizeof(tmpBuf), (unsigned char*)"no (0)");
      } else {
        McuUtility_strcpy(tmpBuf, sizeof(tmpBuf), (unsigned char*)"yes(");
        McuUtility_strcatNum8u(tmpBuf, sizeof(tmpBuf), staticallyAllocated);
        McuUtility_strcat(tmpBuf, sizeof(tmpBuf), (unsigned char*)")");
      }
      buf[0] = '\0';
      McuUtility_strcatPad(buf, sizeof(buf), tmpBuf, ' ', PAD_STAT_TASK_STATIC);
      McuShell_SendStr(buf, io->stdOut);

      /* task handle */
      McuUtility_strcpy(tmpBuf, sizeof(tmpBuf), (unsigned char*)"0x");
      McuUtility_strcatNum32Hex(tmpBuf, sizeof(tmpBuf), (uint32_t)taskHandles[i]);
      buf[0] = '\0';
      McuUtility_strcatPad(buf, sizeof(buf), tmpBuf, ' ', PAD_STAT_TASK_HANDLE);
      McuShell_SendStr(buf, io->stdOut);

      /* task name */
      buf[0] = '\0';
      McuUtility_strcatPad(buf, sizeof(buf), (unsigned char*)pcTaskGetName(taskHandles[i]), ' ', PAD_STAT_TASK_NAME);
      McuShell_SendStr(buf, io->stdOut);

#if configUSE_TRACE_FACILITY
      /* state */
      switch(taskStatus.eCurrentState) {
        case eRunning:   McuUtility_strcpy(tmpBuf, sizeof(tmpBuf), (unsigned char*)"Running"); break;
        case eReady:     McuUtility_strcpy(tmpBuf, sizeof(tmpBuf), (unsigned char*)"Ready"); break;
        case eSuspended: McuUtility_strcpy(tmpBuf, sizeof(tmpBuf), (unsigned char*)"Suspended"); break;
        case eBlocked:   McuUtility_strcpy(tmpBuf, sizeof(tmpBuf), (unsigned char*)"Blocked"); break;
        case eDeleted:   McuUtility_strcpy(tmpBuf, sizeof(tmpBuf), (unsigned char*)"Deleted"); break;
        case eInvalid:   McuUtility_strcpy(tmpBuf, sizeof(tmpBuf), (unsigned char*)"Invalid"); break;
        default:         McuUtility_strcpy(tmpBuf, sizeof(tmpBuf), (unsigned char*)"UNKNOWN!"); break;
      }
      buf[0] = '\0';
      McuUtility_strcatPad(buf, sizeof(buf), tmpBuf, ' ', PAD_STAT_TASK_STATE);
      McuShell_SendStr(buf, io->stdOut);
#endif
#if configUSE_TRACE_FACILITY
      /* (baseprio,currprio) */
      tmpBuf[0] = '\0';
      McuUtility_chcat(tmpBuf, sizeof(tmpBuf), '(');
      McuUtility_strcatNum32u(tmpBuf, sizeof(tmpBuf), taskStatus.uxBasePriority);
      McuUtility_chcat(tmpBuf, sizeof(tmpBuf), ',');
      McuUtility_strcatNum32u(tmpBuf, sizeof(tmpBuf), taskStatus.uxCurrentPriority);
      McuUtility_chcat(tmpBuf, sizeof(tmpBuf), ')');
      buf[0] = '\0';
      McuUtility_strcatPad(buf, sizeof(buf), tmpBuf, ' ', PAD_STAT_TASK_PRIO);
      McuShell_SendStr(buf, io->stdOut);
#else
      /* prio */
      tmpBuf[0] = '\0';
      McuUtility_strcatNum32s(tmpBuf, sizeof(tmpBuf), uxTaskPriorityGet(taskHandles[i]));
      buf[0] = '\0';
      McuUtility_strcatPad(buf, sizeof(buf), tmpBuf, ' ', PAD_STAT_TASK_PRIO);
      McuShell_SendStr(buf, io->stdOut);
#endif
      /* stack begin */
      McuUtility_strcpy(tmpBuf, sizeof(tmpBuf), (unsigned char*)"0x");
      McuUtility_strcatNum32Hex(tmpBuf, sizeof(tmpBuf), (uint32_t)stackBeg);
      buf[0] = '\0';
      McuUtility_strcatPad(buf, sizeof(buf), tmpBuf, ' ', PAD_STAT_TASK_STACK_BEG);
      McuShell_SendStr(buf, io->stdOut);

      /* stack end */
      McuUtility_strcpy(tmpBuf, sizeof(tmpBuf), (unsigned char*)"0x");
      McuUtility_strcatNum32Hex(tmpBuf, sizeof(tmpBuf), (uint32_t)stackEnd);
      buf[0] = '\0';
      McuUtility_strcatPad(buf, sizeof(buf), tmpBuf, ' ', PAD_STAT_TASK_STACK_END);
      McuShell_SendStr(buf, io->stdOut);

      /* stack size */
#if (portSTACK_GROWTH>0)
      stackSize = (uint16_t)(((uint32_t)stackEnd - (uint32_t)stackBeg)+sizeof(StackType_t));
#else
      stackSize = (uint16_t)(((uint32_t)stackBeg - (uint32_t)stackEnd)+ 2*sizeof(StackType_t));
#endif
      tmpBuf[0] = '\0';
      McuUtility_strcatNum16uFormatted(tmpBuf, sizeof(tmpBuf), stackSize, ' ', 5);
      McuUtility_strcat(tmpBuf, sizeof(tmpBuf), (unsigned char*)" B");
      buf[0] = '\0';
      McuUtility_strcatPad(buf, sizeof(buf), tmpBuf, ' ', PAD_STAT_TASK_STACK_SIZE);
      McuShell_SendStr(buf, io->stdOut);

      /* stack top */
      McuUtility_strcpy(tmpBuf, sizeof(tmpBuf), (unsigned char*)"0x");
      McuUtility_strcatNum32Hex(tmpBuf, sizeof(tmpBuf), (uint32_t)topOfStack);
      McuUtility_strcat(tmpBuf, sizeof(tmpBuf), (unsigned char*)" (");
#if (portSTACK_GROWTH>0)
      McuUtility_strcatNum16uFormatted(tmpBuf, sizeof(tmpBuf), (uint16_t)(((uint32_t)topOfStack - (uint32_t)stackBeg))+sizeof(StackType_t), ' ', 5);
#else
      McuUtility_strcatNum16uFormatted(tmpBuf, sizeof(tmpBuf), (uint16_t)(((uint32_t)stackBeg - (uint32_t)topOfStack))+sizeof(StackType_t), ' ', 5);
#endif
      McuUtility_strcat(tmpBuf, sizeof(tmpBuf), (unsigned char*)" B)");
      buf[0] = '\0';
      McuUtility_strcatPad(buf, sizeof(buf), tmpBuf, ' ', PAD_STAT_TASK_STACK_TOP);
      McuShell_SendStr(buf, io->stdOut);

#if configUSE_TRACE_FACILITY
      /* stack high water mark (the lower the number, the less stack available */
      tmpBuf[0] = '\0';
      McuUtility_strcatNum16uFormatted(tmpBuf, sizeof(tmpBuf), taskStatus.usStackHighWaterMark*sizeof(portSTACK_TYPE), ' ', 5);
      McuUtility_strcat(tmpBuf, sizeof(tmpBuf), (unsigned char*)" B");
      buf[0] = '\0';
      McuUtility_strcatPad(buf, sizeof(buf), tmpBuf, ' ', PAD_STAT_TASK_STACK_MARK);
      McuShell_SendStr(buf, io->stdOut);
#endif
#if configGENERATE_RUN_TIME_STATS && configUSE_TRACE_FACILITY
      /* runtime */
      McuUtility_strcpy(tmpBuf, sizeof(tmpBuf), (unsigned char*)"0x");
      McuUtility_strcatNum32Hex(tmpBuf, sizeof(tmpBuf), taskStatus.ulRunTimeCounter);
      if (ulTotalTime>0) { /* to avoid division by zero */
        uint32_t ulStatsAsPercentage;

        /* What percentage of the total run time has the task used?
           This will always be rounded down to the nearest integer.
           ulTotalRunTime has already been divided by 100. */
        ulStatsAsPercentage = taskStatus.ulRunTimeCounter/ulTotalTime;
        if (ulStatsAsPercentage>0) {
          McuUtility_strcat(tmpBuf, sizeof(tmpBuf), (unsigned char*)" (");
          McuUtility_strcatNum16uFormatted(tmpBuf, sizeof(tmpBuf), ulStatsAsPercentage, ' ', 3);
          McuUtility_strcat(tmpBuf, sizeof(tmpBuf), (unsigned char*)"%)");
        } else {
          /* If the percentage is zero here then the task has consumed less than 1% of the total run time. */
          McuUtility_strcat(tmpBuf, sizeof(tmpBuf), (unsigned char*)" ( <1%)");
        }
      }
      buf[0] = '\0';
      McuUtility_strcatPad(buf, sizeof(buf), tmpBuf, ' ', PAD_STAT_TASK_RUNTIME);
      McuShell_SendStr(buf, io->stdOut);
#endif
      McuShell_SendStr((unsigned char*)"\r\n", io->stdOut);
    } /* if */
  } /* for */
#endif /* tskKERNEL_VERSION_MAJOR */
  return res;
}
#endif

#if configUSE_SHELL
static uint8_t PrintStatus(const McuShell_StdIOType *io) {
  uint8_t buf[16];

  McuShell_SendStatusStr((unsigned char*)"McuRTOS", (unsigned char*)"FreeRTOS status information\r\n", io->stdOut);
  McuShell_SendStatusStr((unsigned char*)"  Version", (const unsigned char*)tskKERNEL_VERSION_NUMBER, io->stdOut);
  McuShell_SendStr((unsigned char*)"\r\n", io->stdOut);
  McuShell_SendStatusStr((unsigned char*)"  RTOS ticks", (const unsigned char*)"", io->stdOut);
  McuUtility_Num16sToStr(buf, sizeof(buf), configTICK_RATE_HZ);
  McuShell_SendStr(buf, io->stdOut);
  McuShell_SendStr((unsigned char*)" Hz, ", io->stdOut);
  McuUtility_Num16sToStr(buf, sizeof(buf), 1000/configTICK_RATE_HZ);
  McuShell_SendStr(buf, io->stdOut);
  McuShell_SendStr((unsigned char*)" ms\r\n", io->stdOut);
#if configSUPPORT_DYNAMIC_ALLOCATION && configUSE_HEAP_SCHEME!=3 /* wrapper to malloc() does not have xPortGetFreeHeapSize() */
  McuShell_SendStatusStr((unsigned char*)"  Free heap", (const unsigned char*)"", io->stdOut);
  McuUtility_Num32uToStr(buf, sizeof(buf), McuRTOS_xPortGetFreeHeapSize());
  McuShell_SendStr(buf, io->stdOut);
  McuShell_SendStr((unsigned char*)" bytes\r\n", io->stdOut);
#endif
  return ERR_OK;
}
#endif

#if configUSE_SHELL
static uint8_t PrintHelp(const McuShell_StdIOType *io) {
  McuShell_SendHelpStr((unsigned char*)"McuRTOS", (unsigned char*)"Group of McuRTOS commands\r\n", io->stdOut);
  McuShell_SendHelpStr((unsigned char*)"  help|status", (unsigned char*)"Print help or status information\r\n", io->stdOut);
  McuShell_SendHelpStr((unsigned char*)"  tasklist", (unsigned char*)"Print tasklist\r\n", io->stdOut);
  return ERR_OK;
}
#endif

/*
** ===================================================================
**     Method      :  xTaskCreate (component FreeRTOS)
**
**     Description :
**         Create a new task and add it to the list of tasks that are
**         ready to run.
**     Parameters  :
**         NAME            - DESCRIPTION
**         pvTaskCode      - Pointer to the task entry
**                           function. Tasks must be implemented to
**                           never return (i.e. continuous loop).
**         pcName          - A descriptive name for the task.
**                           This is mainly used to facilitate debugging.
**                           Max length defined by
**                           configMAX_TASK_NAME_LEN.
**         usStackDepth    - The size of the task
**                           stack specified as the number of variables
**                           the stack can hold - not the number of
**                           bytes. For example, if the stack is 16 bits
**                           wide and usStackDepth is defined as 100,
**                           200 bytes will be allocated for stack
**                           storage. The stack depth multiplied by the
**                           stack width must not exceed the maximum
**                           value that can be contained in a variable
**                           of type size_t.
**         pvParameters    - Pointer that will be
**                           used as the parameter for the task being
**                           created.
**         uxPriority      - The priority at which the
**                           task should run.
**         pvCreatedTask   - Used to pass back a
**                           handle by which the created task can be
**                           referenced.
**     Returns     :
**         ---             - pdPASS if the task was successfully
**                           created and added to a ready list,
**                           otherwise an error code defined in the file
**                           projdefs.h
** ===================================================================
*/
/*
portBASE_TYPE McuRTOS_xTaskCreate(pdTASK_CODE pvTaskCode, const portCHAR * const pcName, unsigned portSHORT usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pvCreatedTask)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  vTaskDelete (component FreeRTOS)
**
**     Description :
**         Remove a task from the RTOS real time kernels management.
**         The task being deleted will be removed from all ready,
**         blocked, suspended and event lists.
**         NOTE: The idle task is responsible for freeing the kernel
**         allocated memory from tasks that have been deleted. It is
**         therefore important that the idle task is not starved of
**         microcontroller processing time if your application makes
**         any calls to vTaskDelete (). Memory allocated by the task
**         code is not automatically freed, and should be freed before
**         the task is deleted.
**     Parameters  :
**         NAME            - DESCRIPTION
**         pxTask          - The handle of the task to be deleted.
**                           Passing NULL will cause the calling task to
**                           be deleted.
**     Returns     : Nothing
** ===================================================================
*/
/*
void McuRTOS_vTaskDelete(xTaskHandle pxTask)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  vTaskStartScheduler (component FreeRTOS)
**
**     Description :
**         Starts the real time kernel tick processing. After calling
**         the kernel has control over which tasks are executed and
**         when.
**         The idle task is created automatically when
**         vTaskStartScheduler() is called.
**         If vTaskStartScheduler() is successful the function will not
**         return until an executing task calls vTaskEndScheduler().
**         The function might fail and return immediately if there is
**         insufficient RAM available for the idle task to be created.
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
/*
void McuRTOS_vTaskStartScheduler(void)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  taskYIELD (component FreeRTOS)
**
**     Description :
**         Macro for forcing a context switch.
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
/*
void McuRTOS_taskYIELD(void)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  taskENTER_CRITICAL (component FreeRTOS)
**
**     Description :
**         Macro to mark the start of a critical code region.
**         Preemptive context switches cannot occur when in a critical
**         region.
**         NOTE: This may alter the stack (depending on the portable
**         implementation) so must be used with care!
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
/*
void McuRTOS_taskENTER_CRITICAL(void)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  taskEXIT_CRITICAL (component FreeRTOS)
**
**     Description :
**         Macro to mark the end of a critical code region. Preemptive
**         context switches cannot occur when in a critical region.
**         NOTE: This may alter the stack (depending on the portable
**         implementation) so must be used with care!
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
/*
void McuRTOS_taskEXIT_CRITICAL(void)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  taskDISABLE_INTERRUPTS (component FreeRTOS)
**
**     Description :
**         Macro to disable all maskable interrupts.
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
/*
void McuRTOS_taskDISABLE_INTERRUPTS(void)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  taskENABLE_INTERRUPTS (component FreeRTOS)
**
**     Description :
**         Macro to enable microcontroller interrupts.
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
/*
void McuRTOS_taskENABLE_INTERRUPTS(void)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  vTaskSuspendAll (component FreeRTOS)
**
**     Description :
**         Suspends all real time kernel activity while keeping
**         interrupts (including the kernel tick) enabled.
**         After calling vTaskSuspendAll () the calling task will
**         continue to execute without risk of being swapped out until
**         a call to xTaskResumeAll () has been made.
**         API functions that have the potential to cause a context
**         switch (for example, vTaskDelayUntil(), xQueueSend(), etc.)
**         must not be called while the scheduler is suspended.
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
/*
void McuRTOS_vTaskSuspendAll(void)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xTaskResumeAll (component FreeRTOS)
**
**     Description :
**         Resumes real time kernel activity following a call to
**         vTaskSuspendAll (). After a call to xTaskSuspendAll () the
**         kernel will take control of which task is executing at any
**         time.
**     Parameters  : None
**     Returns     :
**         ---             - If resuming the scheduler caused a context
**                           switch then pdTRUE is returned, otherwise
**                           pdFALSE is returned.
** ===================================================================
*/
/*
portBASE_TYPE McuRTOS_xTaskResumeAll(void)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xTaskResumeFromISR (component FreeRTOS)
**
**     Description :
**         An implementation of vTaskResume() that can be called from
**         within an ISR. A task that has been suspended by one of more
**         calls to vTaskSuspend() will be made available for running
**         again by a single call to xTaskResumeFromISR().
**     Parameters  :
**         NAME            - DESCRIPTION
**         pxTaskToResume  - Handle to the task
**                           being readied.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
/*
portBASE_TYPE McuRTOS_xTaskResumeFromISR(xTaskHandle pxTaskToResume)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  vTaskDelay (component FreeRTOS)
**
**     Description :
**         Delay a task for a given number of ticks. The actual time
**         that the task remains blocked depends on the tick rate. The
**         macro pdMS_TO_TICKS() can be used to calculate real time
**         from the tick rate - with the resolution of one tick period.
**         vTaskDelay() specifies a time at which the task wishes to
**         unblock relative to the time at which vTaskDelay() is called.
**         For example, specifying a block period of 100 ticks will
**         cause the task to unblock 100 ticks after vTaskDelay() is
**         called. vTaskDelay() does not therefore provide a good
**         method of controlling the frequency of a cyclical task as
**         the path taken through the code, as well as other task and
**         interrupt activity, will effect the frequency at which
**         vTaskDelay() gets called and therefore the time at which the
**         task next executes. See vTaskDelayUntil() for an alternative
**         API function designed to facilitate fixed frequency
**         execution. It does this by specifying an absolute time
**         (rather than a relative time) at which the calling task
**         should unblock. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xTicksToDelay   - The amount of time, in
**                           tick periods, that the calling task should
**                           block.
**     Returns     : Nothing
** ===================================================================
*/
/*
void McuRTOS_vTaskDelay(portTickType xTicksToDelay)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  vTaskDelayUntil (component FreeRTOS)
**
**     Description :
**         Delay a task until a specified time. This function can be
**         used by cyclical tasks to ensure a constant execution
**         frequency.
**         This function differs from vTaskDelay() in one important
**         aspect: vTaskDelay() specifies a time at which the task
**         wishes to unblock relative to the time at which vTaskDelay()
**         is called, whereas vTaskDelayUntil() specifies an absolute
**         time at which the task wishes to unblock.
**         vTaskDelay() will cause a task to block for the specified
**         number of ticks from the time vTaskDelay() is called. It is
**         therefore difficult to use vTaskDelay() by itself to
**         generate a fixed execution frequency as the time between a
**         task unblocking following a call to vTaskDelay() and that
**         task next calling vTaskDelay() may not be fixed [the task
**         may take a different path though the code between calls, or
**         may get interrupted or preempted a different number of times
**         each time it executes].
**         Whereas vTaskDelay() specifies a wake time relative to the
**         time at which the function is called, vTaskDelayUntil()
**         specifies the absolute (exact) time at which it wishes to
**         unblock.
**         It should be noted that vTaskDelayUntil() will return
**         immediately (without blocking) if it is used to specify a
**         wake time that is already in the past. Therefore a task
**         using vTaskDelayUntil() to execute periodically will have to
**         re-calculate its required wake time if the periodic
**         execution is halted for any reason (for example, the task is
**         temporarily placed into the Suspended state) causing the
**         task to miss one or more periodic executions. This can be
**         detected by checking the variable passed by reference as the
**         pxPreviousWakeTime parameter against the current tick count.
**         This is however not necessary under most usage scenarios.
**         The constant portTICK_RATE_MS can be used to calculate real
**         time from the tick rate - with the resolution of one tick
**         period.
**         This function must not be called while the scheduler has
**         been suspended by a call to vTaskSuspendAll(). 
**     Parameters  :
**         NAME            - DESCRIPTION
**         pxPreviousWakeTime - Pointer to a
**                           variable that holds the time at which the
**                           task was last unblocked. The variable must
**                           be initialised with the current time prior
**                           to its first use (see the example below).
**                           Following this the variable is
**                           automatically updated within
**                           vTaskDelayUntil(). 
**         xTimeIncrement  - The cycle time
**                           period. The task will be unblocked at time
**                           (*pxPreviousWakeTime + xTimeIncrement).
**                           Calling vTaskDelayUntil with the same
**                           xTimeIncrement parameter value will cause
**                           the task to execute with a fixed interval
**                           period. 
**     Returns     : Nothing
** ===================================================================
*/
/*
void McuRTOS_vTaskDelayUntil(portTickType *pxPreviousWakeTime, portTickType xTimeIncrement)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  uxTaskPriorityGet (component FreeRTOS)
**
**     Description :
**         Obtain the priority of any task.
**     Parameters  :
**         NAME            - DESCRIPTION
**         pxTask          - Handle of the task to be queried.
**                           Passing a NULL handle results in the
**                           priority of the calling task being returned.
**     Returns     :
**         ---             - The priority of pxTask.
** ===================================================================
*/
/*
unsigned_portBASE_TYPE McuRTOS_uxTaskPriorityGet(xTaskHandle pxTask)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  vTaskPrioritySet (component FreeRTOS)
**
**     Description :
**         Set the priority of any task.
**     Parameters  :
**         NAME            - DESCRIPTION
**         pxTask          - Handle to the task for which the
**                           priority is being set. Passing a NULL
**                           handle results in the priority of the
**                           calling task being set.
**         uxNewPriority   - The priority to which
**                           the task will be set.
**     Returns     : Nothing
** ===================================================================
*/
/*
void McuRTOS_vTaskPrioritySet(xTaskHandle pxTask, unsigned_portBASE_TYPE uxNewPriority)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xSemaphoreTakeRecursive (component FreeRTOS)
**
**     Description :
**         Macro to recursively obtain, or 'take', a mutex type
**         semaphore. The mutex must have previously been created using
**         a call to xSemaphoreCreateRecursiveMutex();
**         This macro must not be used on mutexes created using
**         xSemaphoreCreateMutex(). A mutex used recursively can be
**         'taken' repeatedly by the owner. The mutex doesn't become
**         available again until the owner has called
**         xSemaphoreGiveRecursive() for each successful 'take' request.
**         For example, if a task successfully 'takes' the same mutex 5
**         times then the mutex will not be available to any other task
**         until it has also  'given' the mutex back exactly five times.
**     Parameters  :
**         NAME            - DESCRIPTION
**         xMutex          - A handle to the mutex being obtained.
**                           This is the handle returned by
**                           xSemaphoreCreateRecursiveMutex();
**         xBlockTime      - The time in ticks to wait
**                           for the semaphore to become available.  The
**                           macro portTICK_RATE_MS can be used to
**                           convert this to a real time.  A block time
**                           of zero can be used to poll the semaphore.
**                           If the task already owns the semaphore then
**                           xSemaphoreTakeRecursive() will return
**                           immediately no matter what the value of
**                           xBlockTime.
**     Returns     :
**         ---             - Returns pdTRUE if the semaphore was
**                           obtained.  pdFALSE if xBlockTime expired
**                           without the semaphore becoming available.
** ===================================================================
*/
/*
bool McuRTOS_xSemaphoreTakeRecursive(xSemaphoreHandle xMutex, portTickType xBlockTime)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xSemaphoreGiveRecursive (component FreeRTOS)
**
**     Description :
**         Macro to recursively release, or 'give', a mutex type
**         semaphore. The mutex must have previously been created using
**         a call to xSemaphoreCreateRecursiveMutex();
**         This macro must not be used on mutexes created using
**         xSemaphoreCreateMutex(). A mutex used recursively can be
**         'taken' repeatedly by the owner. The mutex doesn't become
**         available again until the owner has called
**         xSemaphoreGiveRecursive() for each successful 'take' request.
**         For example, if a task successfully 'takes' the same mutex 5
**         times then the mutex will not be available to any other task
**         until it has also  'given' the mutex back exactly five times.
**     Parameters  :
**         NAME            - DESCRIPTION
**         xMutex          - A handle to the mutex being released,
**                           or 'given'.  This is the handle returned by
**                           xSemaphoreCreateMutex();
**     Returns     :
**         ---             - Returns pdTRUE if the semaphore was given.
** ===================================================================
*/
/*
bool McuRTOS_xSemaphoreGiveRecursive(xSemaphoreHandle xMutex)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xSemaphoreCreateRecursiveMutex (component FreeRTOS)
**
**     Description :
**         Macro that implements a recursive mutex by using the
**         existing queue mechanism.
**         Mutexes created using this macro can be accessed using the
**         xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive()
**         macros.  The  xSemaphoreTake() and xSemaphoreGive() macros
**         should not be used.
**         A mutex used recursively can be 'taken' repeatedly by the
**         owner. The mutex doesn't become available again until the
**         owner has called xSemaphoreGiveRecursive() for each
**         successful 'take' request.  For example, if a task
**         successfully 'takes' the same mutex 5 times then the mutex
**         will not be available to any other task until it has also
**         'given' the mutex back exactly five times.
**         This type of semaphore uses a priority inheritance mechanism
**         so a task 'taking' a semaphore MUST ALWAYS 'give' the
**         semaphore back once the semaphore it is no longer required.
**         Mutex type semaphores cannot be used from within interrupt
**         service routines.
**         See vSemaphoreCreateBinary() for an alternative
**         implementation that can be used for pure synchronisation
**         (where one task or interrupt always 'gives' the semaphore
**         and another always 'takes' the semaphore) and from within
**         interrupt service routines.
**     Parameters  : None
**     Returns     :
**         ---             - Handle to the created mutex semaphore.
**                           Should be of type  xSemaphoreHandle.
** ===================================================================
*/
/*
xSemaphoreHandle McuRTOS_xSemaphoreCreateRecursiveMutex(void)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  vSemaphoreDelete (component FreeRTOS)
**
**     Description :
**         Delete a semaphore.  This function must be used with care.
**         For example, do not delete a mutex type semaphore if the
**         mutex is held by a task.
**     Parameters  :
**         NAME            - DESCRIPTION
**         xSemaphore      - A handle to the semaphore to
**                           be deleted.
**     Returns     : Nothing
** ===================================================================
*/
/*
void McuRTOS_vSemaphoreDelete(xSemaphoreHandle xSemaphore)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  vTaskSuspend (component FreeRTOS)
**
**     Description :
**         Suspend any task. When suspended a task will never get any
**         microcontroller processing time, no matter what its priority.
**         Calls to vTaskSuspend are not accumulative - i.e. calling
**         vTaskSuspend() twice on the same task still only requires
**         one call to vTaskResume() to ready the suspended task.
**     Parameters  :
**         NAME            - DESCRIPTION
**         pxTaskToSuspend - Handle to the task
**                           being suspended. Passing a NULL handle will
**                           cause the calling task to be suspended.
**     Returns     : Nothing
** ===================================================================
*/
/*
void McuRTOS_vTaskSuspend(xTaskHandle pxTaskToSuspend)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  vTaskResume (component FreeRTOS)
**
**     Description :
**         Resumes a suspended task. A task that has been suspended by
**         one of more calls to vTaskSuspend() will be made available
**         for running again by a single call to vTaskResume().
**     Parameters  :
**         NAME            - DESCRIPTION
**         pxTaskToResume  - Handle to the task
**                           being readied.
**     Returns     : Nothing
** ===================================================================
*/
/*
void McuRTOS_vTaskResume(xTaskHandle pxTaskToResume)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xSemaphoreCreateMutex (component FreeRTOS)
**
**     Description :
**         Macro that creates a mutex semaphore by using the existing
**         queue mechanism.
**         Mutexes created using this macro can be accessed using the
**         xSemaphoreTake() and xSemaphoreGive() macros. The
**         xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive()
**         macros should not be used.
**         Mutexes and binary semaphores are very similar but have some
**         subtle differences: Mutexes include a priority inheritance
**         mechanism, binary semaphores do not. This makes binary
**         semaphores the better choice for implementing
**         synchronisation (between tasks or between tasks and an
**         interrupt), and mutexes the better choice for implementing
**         simple mutual exclusion.
**         The priority of a task that 'takes' a mutex can potentially
**         be raised if another task of higher priority attempts to
**         obtain the same mutex. The task that owns the mutex
**         'inherits' the priority of the task attempting to 'take' the
**         same mutex. This means the mutex must always be 'given' back
**         - otherwise the higher priority task will never be able to
**         obtain the mutex, and the lower priority task will never
**         'disinherit' the priority. An example of a mutex being used
**         to implement mutual exclusion is provided on the
**         xSemaphoreTake() documentation page.
**         A binary semaphore need not be given back once obtained, so
**         task synchronisation can be implemented by one
**         task/interrupt continuously 'giving' the semaphore while
**         another continuously 'takes' the semaphore. This is
**         demonstrated by the sample code on the
**         xSemaphoreGiveFromISR() documentation page.
**         Both mutex and binary semaphores are assigned to variables
**         of type xSemaphoreHandle and can be used in any API function
**         that takes a parameter of this type. 
**     Parameters  : None
**     Returns     :
**         ---             - Handle to the created mutex semaphore.
**                           Should be of type  xSemaphoreHandle.
** ===================================================================
*/
/*
xSemaphoreHandle McuRTOS_xSemaphoreCreateMutex(void)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xSemaphoreTake (component FreeRTOS)
**
**     Description :
**         Macro to obtain a semaphore. The semaphore must have
**         previously been created with a call to
**         vSemaphoreCreateBinary(), xSemaphoreCreateMutex() or
**         xSemaphoreCreateCounting().
**         This macro must not be called from an ISR.
**         xQueueReceiveFromISR() can be used to take a semaphore from
**         within an interrupt if required, although this would not be
**         a normal operation. Semaphores use queues as their
**         underlying mechanism, so functions are to some extent
**         interoperable.
**         xSemaphoreTake() is part of the fully featured intertask
**         communications API. xSemaphoreAltTake() is the alternative
**         API equivalent. Both versions require the same parameters
**         and return the same values.
**     Parameters  :
**         NAME            - DESCRIPTION
**         xMutex          - A handle to the mutex being obtained.
**                           This is the handle returned by
**                           xSemaphoreCreateMutex();
**         xBlockTime      - The time in ticks to wait
**                           for the semaphore to become available.  The
**                           macro portTICK_RATE_MS can be used to
**                           convert this to a real time.  A block time
**                           of zero can be used to poll the semaphore.
**                           If the task already owns the semaphore then
**                           xSemaphoreTakeRecursive() will return
**                           immediately no matter what the value of
**                           xBlockTime. Specifying the block time as
**                           portMAX_DELAY will cause the task to block
**                           indefinitely (without a timeout).
**     Returns     :
**         ---             - Returns pdTRUE if the semaphore was
**                           obtained.  pdFALSE if xBlockTime expired
**                           without the semaphore becoming available.
** ===================================================================
*/
/*
bool McuRTOS_xSemaphoreTake(xSemaphoreHandle xMutex, portTickType xBlockTime)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xSemaphoreGive (component FreeRTOS)
**
**     Description :
**         Macro to release a semaphore. The semaphore must have
**         previously been created with a call to
**         vSemaphoreCreateBinary(), xSemaphoreCreateMutex() or
**         xSemaphoreCreateCounting(), and obtained using
**         sSemaphoreTake().
**         This must not be used from an ISR. See
**         xSemaphoreGiveFromISR() for an alternative which can be used
**         from an ISR.
**         This macro must also not be used on semaphores created using
**         xSemaphoreCreateRecursiveMutex().
**         xSemaphoreGive() is part of the fully featured intertask
**         communications API. xSemaphoreAltGive() is the alternative
**         API equivalent. Both versions require the same parameters
**         and return the same values. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xMutex          - A handle to the mutex being released,
**                           or 'given'.  This is the handle returned by
**                           xSemaphoreCreateMutex();
**     Returns     :
**         ---             - Returns pdTRUE if the semaphore was given.
** ===================================================================
*/
/*
bool McuRTOS_xSemaphoreGive(xSemaphoreHandle xMutex)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  vSemaphoreCreateBinary (component FreeRTOS)
**
**     Description :
**         Macro that creates a semaphore by using the existing queue
**         mechanism. The queue length is 1 as this is a binary
**         semaphore. The data size is 0 as we don't want to actually
**         store any data - we just want to know if the queue is empty
**         or full.
**         Binary semaphores and mutexes are very similar but have some
**         subtle differences: Mutexes include a priority inheritance
**         mechanism, binary semaphores do not. This makes binary
**         semaphores the better choice for implementing
**         synchronisation (between tasks or between tasks and an
**         interrupt), and mutexes the better choice for implementing
**         simple mutual exclusion.
**         This old vSemaphoreCreateBinary() macro is now deprecated in
**         favour of the xSemaphoreCreateBinary() function.  Note that
**         binary semaphores created using the vSemaphoreCreateBinary()
**         macro are created in a state such that the first call to
**         'take' the semaphore would pass, whereas binary semaphores
**         created using xSemaphoreCreateBinary() are created in a
**         state such that the the semaphore must first be 'given'
**         before it can be 'taken'.
**         A binary semaphore need not be given back once obtained, so
**         task synchronisation can be implemented by one
**         task/interrupt continuously 'giving' the semaphore while
**         another continuously 'takes' the semaphore. This is
**         demonstrated by the sample code on the
**         xSemaphoreGiveFromISR() documentation page.
**         The priority of a task that 'takes' a mutex can potentially
**         be raised if another task of higher priority attempts to
**         obtain the same mutex. The task that owns the mutex
**         'inherits' the priority of the task attempting to 'take' the
**         same mutex. This means the mutex must always be 'given' back
**         - otherwise the higher priority task will never be able to
**         obtain the mutex, and the lower priority task will never
**         'disinherit' the priority. An example of a mutex being used
**         to implement mutual exclusion is provided on the
**         xSemaphoreTake() documentation page.
**         Both mutex and binary semaphores are assigned to variables
**         of type xSemaphoreHandle and can be used in any API function
**         that takes a parameter of this type. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xSemaphore      - Handle to the created
**                           semaphore. Should be of type
**                           xSemaphoreHandle.
**     Returns     : Nothing
** ===================================================================
*/
/*
void McuRTOS_vSemaphoreCreateBinary(xSemaphoreHandle xSemaphore)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xSemaphoreCreateCounting (component FreeRTOS)
**
**     Description :
**         Macro that creates a counting semaphore by using the
**         existing queue mechanism.
**         Counting semaphores are typically used for two things:
**         1. Counting events.
**         In this usage scenario an event handler will 'give' a
**         semaphore each time an event occurs (incrementing the
**         semaphore count value), and a handler task will 'take' a
**         semaphore each time it processes an event (decrementing the
**         semaphore count value). The count value is therefore the
**         difference between the number of events that have occurred
**         and the number that have been processed. In this case it is
**         desirable for the initial count value to be zero.
**         2. Resource management.
**         In this usage scenario the count value indicates the number
**         of resources available. To obtain control of a resource a
**         task must first obtain a semaphore - decrementing the
**         semaphore count value. When the count value reaches zero
**         there are no free resources. When a task finishes with the
**         resource it 'gives' the semaphore back - incrementing the
**         semaphore count value. In this case it is desirable for the
**         initial count value to be equal to the maximum count value,
**         indicating that all resources are free.
**     Parameters  :
**         NAME            - DESCRIPTION
**         uxMaxCount      - The maximum count value that
**                           can be reached. When the semaphore reaches
**                           this value it can no longer be 'given'.
**         uxInitialCount  - The count value
**                           assigned to the semaphore when it is
**                           created.
**     Returns     :
**         ---             - xSemaphoreHandle handle
** ===================================================================
*/
/*
xSemaphoreHandle McuRTOS_xSemaphoreCreateCounting(unsigned_portBASE_TYPE uxMaxCount, unsigned_portBASE_TYPE uxInitialCount)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xSemaphoreGiveFromISR (component FreeRTOS)
**
**     Description :
**         Macro to release a semaphore. The semaphore must have
**         previously been created with a call to
**         vSemaphoreCreateBinary() or xSemaphoreCreateCounting().
**         Mutex type semaphores (those created using a call to
**         xSemaphoreCreateMutex()) must not be used with this macro.
**         This macro can be used from an ISR.
**     Parameters  :
**         NAME            - DESCRIPTION
**         xSemaphore      - A handle to the semaphore
**                           being released. This is the handle returned
**                           when the semaphore was created.
**       * pxHigherPriorityTaskWoken 
**                           - xSemaphoreGiveFromISR() will set
**                           *pxHigherPriorityTaskWoken to pdTRUE if
**                           giving the semaphoree caused a task to
**                           unblock, and the unblocked task has a
**                           priority higher than the currently running
**                           task. If xSemaphoreGiveFromISR() sets this
**                           value to pdTRUE then a context switch
**                           should be requested before the interrupt is
**                           exited.
**     Returns     :
**         ---             - Returns pdTRUE if the semaphore was given.
** ===================================================================
*/
/*
bool McuRTOS_xSemaphoreGiveFromISR(xSemaphoreHandle xSemaphore, signed_portBASE_TYPE *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  vTaskList (component FreeRTOS)
**
**     Description :
**         configUSE_TRACE_FACILITY, INCLUDE_vTaskDelete and
**         INCLUDE_vTaskSuspend must all be defined as 1 for this
**         function to be available. See the configuration section for
**         more information.
**         NOTE: This function will disable interrupts for its duration.
**         It is not intended for normal application runtime use but as
**         a debug aid. Lists all the current tasks, along with their
**         current state and stack usage high water mark.
**         Tasks are reported as blocked ('B'), ready ('R'), deleted
**         ('D') or suspended ('S').
**     Parameters  :
**         NAME            - DESCRIPTION
**       * pcWriteBuffer   - Pointer to buffer. A
**                           buffer into which the above mentioned
**                           details will be written, in ascii form.
**                           This buffer is assumed to be large enough
**                           to contain the generated report.
**                           Approximately 40 bytes per task should be
**                           sufficient.
**         bufSize         - size of buffer
**     Returns     : Nothing
** ===================================================================
*/
/*
void McuRTOS_vTaskList(signed portCHAR *pcWriteBuffer, size_t bufSize)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  pvPortMalloc (component FreeRTOS)
**
**     Description :
**         Allocates a memory block using the port pvPortMalloc()
**         function
**     Parameters  :
**         NAME            - DESCRIPTION
**         xWantedSize     - size of memory block
**                           requested
**     Returns     :
**         ---             - memory block or NULL if failed
** ===================================================================
*/
/*
pVoid McuRTOS_pvPortMalloc(size_t xWantedSize)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  vPortFree (component FreeRTOS)
**
**     Description :
**         Frees a memory block previously allocated with pvPortMalloc()
**     Parameters  :
**         NAME            - DESCRIPTION
**       * pv              - Pointer to data
**     Returns     : Nothing
** ===================================================================
*/
/*
void McuRTOS_vPortFree(void *pv)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xTaskGetTickCount (component FreeRTOS)
**
**     Description :
**         Return the count of ticks since vTaskStartScheduler was
**         called.
**     Parameters  : None
**     Returns     :
**         ---             - tick count
** ===================================================================
*/
/*
portTickType McuRTOS_xTaskGetTickCount(void)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xTaskGetSchedulerState (component FreeRTOS)
**
**     Description :
**         Returns the state of the scheduler
**     Parameters  : None
**     Returns     :
**         ---             - One of the following constants (defined
**                           within task.h): taskSCHEDULER_NOT_STARTED,
**                           taskSCHEDULER_RUNNING,
**                           taskSCHEDULER_SUSPENDED.
** ===================================================================
*/
/*
portBASE_TYPE McuRTOS_xTaskGetSchedulerState(void)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  uxTaskGetStackHighWaterMark (component FreeRTOS)
**
**     Description :
**         The stack used by a task will grow and shrink as the task
**         executes and interrupts are processed.
**         uxTaskGetStackHighWaterMark() returns the minimum amount of
**         remaining stack space that was available to the task since
**         the task started executing - that is the amount of stack
**         that remained unused when the task stack was at its greatest
**         (deepest) value. This is what is referred to as the stack
**         'high water mark'.
**     Parameters  :
**         NAME            - DESCRIPTION
**         xTask           - The handle of the task being queried.
**                           A task may query its own high water mark by
**                           passing NULL as the xTask parameter.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
/*
unsigned_portBASE_TYPE McuRTOS_uxTaskGetStackHighWaterMark(xTaskHandle xTask)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  uxTaskGetNumberOfTasks (component FreeRTOS)
**
**     Description :
**         Returns the number of tasks
**     Parameters  : None
**     Returns     :
**         ---             - number of tasks
** ===================================================================
*/
/*
unsigned_portBASE_TYPE McuRTOS_uxTaskGetNumberOfTasks(void)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  vTaskGetRunTimeStats (component FreeRTOS)
**
**     Description :
**         configGENERATE_RUN_TIME_STATS must be defined as 1 for this
**         function to be available. The application must also then
**         provide definitions for
**         portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and
**         portGET_RUN_TIME_COUNTER_VALUE to configure a peripheral
**         timer/counter and return the timers current count value
**         respectively. The counter should be at least 10 times the
**         frequency of the tick count.
**         NOTE: This function will disable interrupts for its duration.
**         It is not intended for normal application runtime use but as
**         a debug aid.
**         Setting configGENERATE_RUN_TIME_STATS to 1 will result in a
**         total accumulated execution time being stored for each task.
**         The resolution of the accumulated time value depends on the
**         frequency of the timer configured by the
**         portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro. Calling
**         vTaskGetRunTimeStats() writes the total execution time of
**         each task into a buffer, both as an absolute count value and
**         as a percentage of the total system execution time. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         pcWriteBuffer   - A buffer into which
**                           the execution times will be written, in
**                           ascii form. This buffer is assumed to be
**                           large enough to contain the generated
**                           report. Approximately 40 bytes per task
**                           should be sufficient. 
**         bufSize         - size of buffer
**     Returns     : Nothing
** ===================================================================
*/
/*
void McuRTOS_vTaskGetRunTimeStats(portCHAR *pcWriteBuffer, size_t bufSize)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xPortGetFreeHeapSize (component FreeRTOS)
**
**     Description :
**         Returns the actual free size of the heap
**     Parameters  : None
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
/*
Tsize_t McuRTOS_xPortGetFreeHeapSize(void)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xQueueCreate (component FreeRTOS)
**
**     Description :
**         Creates a queue.
**     Parameters  :
**         NAME            - DESCRIPTION
**         uxQueueLength   - The maximum number of
**                           items the queue can hold at any time.
**         uxItemSize      - The size in bytes of each
**                           item the queue will hold.
**     Returns     :
**         ---             - A handle to the created queue is returned
**                           provided the queue was created successfully.
**                           NULL is returned if the queue cannot be
**                           created because there is too little heap
**                           RAM available.
** ===================================================================
*/
/*
xQueueHandle McuRTOS_xQueueCreate(unsigned_portBASE_TYPE uxQueueLength, unsigned_portBASE_TYPE uxItemSize)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xQueueSendToFront (component FreeRTOS)
**
**     Description :
**         Sends an item to the front of a queue.
**     Parameters  :
**         NAME            - DESCRIPTION
**         xQueue          - The handle of the queue to which the
**                           data is to be sent.
**         pvItemToQueue   - A pointer to the data
**                           to be sent to the queue. The size of the
**                           data that can be sent to a queue was
**                           defined when the queue was created.
**         xTicksToWait    - The number of ticks for
**                           which the calling task should be held in
**                           the Blocked state to wait for space to
**                           become available on the queue should the
**                           queue already be full.
**                           A value of zero will prevent the calling
**                           task from entering the Blocked state.
**                           If INCLUDE_vTaskSuspend is set to 1 then a
**                           value of portMAX_DELAY will hold the task
**                           in the Blocked state indefinitely to wait
**                           for space to become available on the queue.
**     Returns     :
**         ---             - pdPASS: Data was successfully sent to the
**                           queue. If a block time was specified then
**                           the calling task may have been temporarily
**                           placed into the Blocked state to wait for
**                           space to become available and space did
**                           become available before the block time
**                           expired.
**                           errQUEUE_FULL: The queue is already full so
**                           no data could be sent to the queue. If a
**                           block time was specified then the calling
**                           task may have been temporarily placed into
**                           the Blocked state to wait for space to
**                           become available, but no space became
**                           available before the block time expired.
** ===================================================================
*/
/*
portBASE_TYPE McuRTOS_xQueueSendToFront(xQueueHandle xQueue, const void *pvItemToQueue, portTickType xTicksToWait)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xQueueSendToBack (component FreeRTOS)
**
**     Description :
**         Sends an item to the back of a queue.
**     Parameters  :
**         NAME            - DESCRIPTION
**         xQueue          - The handle of the queue to which the
**                           data is to be sent.
**         pvItemToQueue   - A pointer to the data
**                           to be sent to the queue. The size of the
**                           data that can be sent to a queue was
**                           defined when the queue was created.
**         xTicksToWait    - The number of ticks for
**                           which the calling task should be held in
**                           the Blocked state to wait for space to
**                           become available on the queue should the
**                           queue already be full.
**                           A value of zero will prevent the calling
**                           task from entering the Blocked state.
**                           If INCLUDE_vTaskSuspend is set to 1 then a
**                           value of portMAX_DELAY will hold the task
**                           in the Blocked state indefinitely to wait
**                           for space to become available on the queue.
**     Returns     :
**         ---             - pdPASS: Data was successfully sent to the
**                           queue. If a block time was specified then
**                           the calling task may have been temporarily
**                           placed into the Blocked state to wait for
**                           space to become available and space did
**                           become available before the block time
**                           expired.
**                           errQUEUE_FULL: The queue is already full so
**                           no data could be sent to the queue. If a
**                           block time was specified then the calling
**                           task may have been temporarily placed into
**                           the Blocked state to wait for space to
**                           become available, but no space became
**                           available before the block time expired.
** ===================================================================
*/
/*
portBASE_TYPE McuRTOS_xQueueSendToBack(xQueueHandle xQueue, const void *pvItemToQueue, portTickType xTicksToWait)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xQueueReceive (component FreeRTOS)
**
**     Description :
**         Receives an item from a queue.
**     Parameters  :
**         NAME            - DESCRIPTION
**         xQueue          - The handle of the queue from which
**                           the data is to be received.
**         pvBuffer        - A pointer to the memory into
**                           which the data received from the queue will
**                           be copied.
**                           The length of the buffer must be at least
**                           equal to the queue item size (set when the
**                           queue was created).
**         xTicksToWait    - The number of ticks for
**                           which the calling task should be held in
**                           the Blocked state to wait for data to
**                           become available from the queue should the
**                           queue already be empty.
**                           A value of zero will prevent the calling
**                           task from entering the Blocked state.
**                           If INCLUDE_vTaskSuspend is set to 1 then a
**                           value of portMAX_DELAY will hold the task
**                           in the Blocked state indefinitely to wait
**                           for data.
**     Returns     :
**         ---             - pdPASS: Data was successfully read from
**                           the queue. If a block time was specified
**                           then the calling task may have been
**                           temporarily placed into the Blocked state
**                           to wait for data to become available and
**                           data did become available before the block
**                           time expired.
**                           errQUEUE_EMPTY: The queue was empty so no
**                           date could be read form the queue. If a
**                           block time was specified then the calling
**                           task may have been temporarily placed into
**                           the Blocked state to wait for data to
**                           become available, but no data became
**                           available before the block time expired.
** ===================================================================
*/
/*
portBASE_TYPE McuRTOS_xQueueReceive(xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWait)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xQueuePeek (component FreeRTOS)
**
**     Description :
**         Reads an item from a queue, but does not remove the item
**         from the queue. Therefore the same item would be returned
**         the next time xQueueReceive() or xQueuePeek() was called on
**         the same queue.
**     Parameters  :
**         NAME            - DESCRIPTION
**         xQueue          - The handle of the queue from which
**                           the data is to be read.
**         pvBuffer        - A pointer to the memory into
**                           which the data read from the queue will be
**                           copied. The length of the buffer must be at
**                           least equal to the queue item size (set
**                           when the queue was created).
**         xTicksToWait    - The number of ticks for
**                           which the calling task should be held in
**                           the Blocked state to wait for data to
**                           become available from the queue should the
**                           queue already be empty.
**                           A value of zero will prevent the calling
**                           task from entering the Blocked state.
**                           If INCLUDE_vTaskSuspend is set to 1 then a
**                           value of portMAX_DELAY will hold the task
**                           in the Blocked state indefinitely to wait
**                           for data.
**     Returns     :
**         ---             - pdPASS: Data was successfully read from
**                           the queue. If a block time was specified
**                           then the calling task may have been
**                           temporarily placed into the Blocked state
**                           to wait for data to become available and
**                           data did become available before the block
**                           time expired.
**                           errQUEUE_EMPTY: The queue was empty so no
**                           date could be read form the queue. If a
**                           block time was specified then the calling
**                           task may have been temporarily placed into
**                           the Blocked state to wait for data to
**                           become available, but no data became
**                           available before the block time expired.
** ===================================================================
*/
/*
portBASE_TYPE McuRTOS_xQueuePeek(xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWait)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  vQueueDelete (component FreeRTOS)
**
**     Description :
**         Deletes a queue that was previously created using a call to
**         xQueueCreate(). vQueueDelete() can also be used to delete a
**         semaphore.
**     Parameters  :
**         NAME            - DESCRIPTION
**         pxQueueToDelete - The handle of the
**                           queue being deleted. Semaphore handles can
**                           also be used. Queues are used to pass data
**                           between tasks and between tasks and
**                           interrupts. A queue/semaphore must not be
**                           deleted if there are any tasks that are
**                           blocked on the queue/semaphore waiting for
**                           events (sends or receives).
**     Returns     : Nothing
** ===================================================================
*/
/*
void McuRTOS_vQueueDelete(xQueueHandle pxQueueToDelete)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  uxQueueMessagesWaiting (component FreeRTOS)
**
**     Description :
**         Queries the number of items that are currently held within a
**         queue.
**     Parameters  :
**         NAME            - DESCRIPTION
**         xQueue          - The handle of the queue being
**                           queried.
**     Returns     :
**         ---             - The number of items that are held within
**                           the queue being queried.
** ===================================================================
*/
/*
unsigned_portBASE_TYPE McuRTOS_uxQueueMessagesWaiting(xQueueHandle xQueue)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  uxQueueMessagesWaitingfromISR (component FreeRTOS)
**
**     Description :
**         A version of uxQueueMessagesWaiting() that can be used from
**         inside an interrupt service routine.
**     Parameters  :
**         NAME            - DESCRIPTION
**         xQueue          - The handle of the queue being
**                           queried.
**     Returns     :
**         ---             - The number of items that are held within
**                           the queue being queried.
** ===================================================================
*/
/*
unsigned_portBASE_TYPE McuRTOS_uxQueueMessagesWaitingfromISR(xQueueHandle xQueue)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xQueueReceiveFromISR (component FreeRTOS)
**
**     Description :
**         A version of xQueueReceive() that can be called from an ISR.
**         Unlike xQueueReceive(), xQueueReceiveFromISR() does not
**         permit a block time to be specified.
**     Parameters  :
**         NAME            - DESCRIPTION
**         xQueue          - The handle of the queue from which
**                           the data is to be received.
**         pvBuffer        - A pointer to the memory into
**                           which the data received from the queue will
**                           be copied.The length of the buffer must be
**                           at least equal to the queue item size (set
**                           when the queue was created).
**       * pxHigherPriorityTaskWoken 
**                           - Pointer to A task may be blocked waiting
**                           for space to become available on the queue.
**                           If xQueueReceiveFromISR() causes such a
**                           task to unblock then
**                           *pxHigherPriorityTaskWoken will get set to
**                           pdTRUE, otherwise
**                           *pxHigherPriorityTaskWoken will remain
**                           unchanged.
**     Returns     :
**         ---             - pdPASS: Data was successfully read from
**                           the queue. If a block time was specified
**                           then the calling task may have been
**                           temporarily placed into the Blocked state
**                           to wait for data to become available and
**                           data did become available before the block
**                           time expired.
**                           errQUEUE_EMPTY: The queue was empty so no
**                           date could be read form the queue. If a
**                           block time was specified then the calling
**                           task may have been temporarily placed into
**                           the Blocked state to wait for data to
**                           become available, but no data became
**                           available before the block time expired.
** ===================================================================
*/
/*
portBASE_TYPE McuRTOS_xQueueReceiveFromISR(xQueueHandle xQueue, void *pvBuffer, portBASE_TYPE *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xQueueSendToFrontFromISR (component FreeRTOS)
**
**     Description :
**         Versions of xQueueSendToFront() API functions that can be
**         called from an ISR. Unlike xQueueSendToFront() these
**         functions do not permit a block time to be specified.
**     Parameters  :
**         NAME            - DESCRIPTION
**         xQueue          - The handle of the queue to which the
**                           data is to be sent.
**         pvItemToQueue   - A pointer to the data
**                           to be sent to the queue. The size of the
**                           data that can be sent to a queue was
**                           defined when the queue was created.
**       * pxHigherPriorityTaskWoken 
**                           - xQueueSendFromISR() will set
**                           *pxHigherPriorityTaskWoken to pdTRUE if
**                           sending to the queue caused a task to
**                           unblock, and the unblocked task has a
**                           priority higher than the currently running
**                           task. If xQueueSendFromISR() sets this
**                           value to pdTRUE then a context switch
**                           should be performed before the interrupt is
**                           exited.
**     Returns     :
**         ---             - pdTRUE Data was successfully sent to the
**                           queue.
**                           errQUEUE_FULL Data could not be sent to the
**                           queue because the queue was already full.
** ===================================================================
*/
/*
portBASE_TYPE McuRTOS_xQueueSendToFrontFromISR(xQueueHandle xQueue, const void *pvItemToQueue, portBASE_TYPE *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xQueueSendToBackFromISR (component FreeRTOS)
**
**     Description :
**         Versions of xQueueSendToBack() API functions that can be
**         called from an ISR. Unlike xQueueSendToBack() these
**         functions do not permit a block time to be specified.
**     Parameters  :
**         NAME            - DESCRIPTION
**         xQueue          - The handle of the queue to which the
**                           data is to be sent.
**         pvItemToQueue   - A pointer to the data
**                           to be sent to the queue. The size of the
**                           data that can be sent to a queue was
**                           defined when the queue was created.
**       * pxHigherPriorityTaskWoken 
**                           - xQueueSendFromISR() will set
**                           *pxHigherPriorityTaskWoken to pdTRUE if
**                           sending to the queue caused a task to
**                           unblock, and the unblocked task has a
**                           priority higher than the currently running
**                           task. If xQueueSendFromISR() sets this
**                           value to pdTRUE then a context switch
**                           should be performed before the interrupt is
**                           exited.
**     Returns     :
**         ---             - pdTRUE Data was successfully sent to the
**                           queue.
**                           errQUEUE_FULL Data could not be sent to the
**                           queue because the queue was already full.
** ===================================================================
*/
/*
portBASE_TYPE McuRTOS_xQueueSendToBackFromISR(xQueueHandle xQueue, const void *pvItemToQueue, portBASE_TYPE *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/
/*
** ===================================================================
**     Method      :  xQueueReset (component FreeRTOS)
**
**     Description :
**         Reset a queue back to its original empty state.  pdPASS is
**         returned if the queue is successfully reset.  pdFAIL is
**         returned if the queue could not be reset because there are
**         tasks blocked on the queue waiting to either receive from
**         the queue or send to the queue.
**     Parameters  :
**         NAME            - DESCRIPTION
**         xQueue          - The handle of the queue to reset.
**     Returns     :
**         ---             - pdPASS is returned if the queue is
**                           successfully reset. pdFAIL is returned if
**                           the queue could not be reset because there
**                           are tasks blocked on the queue waiting to
**                           either receive from the queue or send to
**                           the queue.
** ===================================================================
*/
/*
portBASE_TYPE McuRTOS_xQueueReset(xQueueHandle xQueue)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xSemaphoreGetMutexHolder (component FreeRTOS)
**
**     Description :
**         Returns the holder of a mutex or semaphore. If xMutex is
**         indeed a mutex type semaphore, return the current mutex
**         holder. If xMutex is not a mutex type semaphore, or the
**         mutex is available (not held by a task), return NULL. Note:
**         This Is is a good way of determining if the calling task is
**         the mutex holder, but not a good way of determining the
**         identity of the mutex holder as the holder may change
**         between the function exiting and the returned value being
**         tested.
**     Parameters  :
**         NAME            - DESCRIPTION
**         xSemaphore      - A handle to the semaphore.
**     Returns     :
**         ---             - Not NULL if the calling task is the holder
**                           of the mutex, NULL otherwise.
** ===================================================================
*/
/*
void* McuRTOS_xSemaphoreGetMutexHolder(xSemaphoreHandle xSemaphore)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xSemaphoreTakeFromISR (component FreeRTOS)
**
**     Description :
**         Macro to take a semaphore from an ISR. The semaphore must
**         have previously been created with a call to
**         vSemaphoreCreateBinary() or xSemaphoreCreateCounting().
**         Mutex type semaphores (those created using a call to
**         xSemaphoreCreateMutex()) must not be used with this macro.
**         This macro can be used from an ISR, however taking a
**         semaphore from an ISR is not a common operation.  It is
**         likely to only be useful when taking a counting semaphore
**         when an interrupt is obtaining an object from a resource
**         pool (when the semaphore count indicates the number of
**         resources available).
**     Parameters  :
**         NAME            - DESCRIPTION
**         xSemaphore      - A handle to the semaphore
**                           being taken. This is the handle returned
**                           when the semaphore was created.
**       * pxHigherPriorityTaskWoken 
**                           - xSemaphoreTakeFromISR() will set
**                           *pxHigherPriorityTaskWoken to pdTRUE if
**                           taking the semaphore caused a task to
**                           unblock, and the unblocked task has a
**                           priority higher than the currently running
**                           task.  If xSemaphoreTakeFromISR() sets this
**                           value to pdTRUE then a context switch
**                           should be requested before the interrupt is
**                           exited.
**     Returns     :
**         ---             - Returns pdTRUE if the semaphore was given.
** ===================================================================
*/
/*
bool McuRTOS_xSemaphoreTakeFromISR(xSemaphoreHandle xSemaphore, signed_portBASE_TYPE *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  ParseCommand (component FreeRTOS)
**
**     Description :
**         Shell Command Line Parser
**     Parameters  :
**         NAME            - DESCRIPTION
**       * cmd             - Pointer to command string
**       * handled         - Pointer to variable which tells if
**                           the command has been handled or not
**       * io              - Pointer to I/O structure
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
#if configUSE_SHELL
uint8_t McuRTOS_ParseCommand(const unsigned char *cmd, bool *handled, const McuShell_StdIOType *io)
{
  if (McuUtility_strcmp((char*)cmd, McuShell_CMD_HELP)==0 || McuUtility_strcmp((char*)cmd, "McuRTOS help")==0) {
    *handled = TRUE;
    return PrintHelp(io);
  } else if ((McuUtility_strcmp((char*)cmd, McuShell_CMD_STATUS)==0) || (McuUtility_strcmp((char*)cmd, "McuRTOS status")==0)) {
    *handled = TRUE;
    return PrintStatus(io);
  } else if (McuUtility_strcmp((char*)cmd, "McuRTOS tasklist")==0) {
    *handled = TRUE;
    return PrintTaskList(io);
  }
  return ERR_OK;
}
#endif

/*
** ===================================================================
**     Method      :  Init (component FreeRTOS)
**
**     Description :
**         Low level initialization routine called from startup code.
**         This method ensures that the tick timer is  not enabled.
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void McuRTOS_Init(void)
{
#if !McuLib_CONFIG_CPU_IS_ESP32
  portDISABLE_ALL_INTERRUPTS(); /* disable all interrupts, they get enabled in vStartScheduler() */
#endif
#if configSYSTICK_USE_LOW_POWER_TIMER && McuLib_CONFIG_CPU_IS_KINETIS
  /* enable clocking for low power timer, otherwise vPortStopTickTimer() will crash.
    Additionally, Percepio trace needs access to the timer early on. */
  #if McuLib_CONFIG_NXP_SDK_USED
  CLOCK_EnableClock(kCLOCK_Lptmr0);
  #else /* Processor Expert */
  SIM_PDD_SetClockGate(SIM_BASE_PTR, SIM_PDD_CLOCK_GATE_LPTMR0, PDD_ENABLE);
  #endif
#endif
#if !McuLib_CONFIG_CPU_IS_ESP32
  vPortStopTickTimer(); /* tick timer shall not run until the RTOS scheduler is started */
#endif
#if configUSE_PERCEPIO_TRACE_HOOKS
  McuPercepio_Startup(); /* Startup Percepio Trace. Need to do this before calling any RTOS functions. */
#endif
}

/*
** ===================================================================
**     Method      :  xTaskGetCurrentTaskHandle (component FreeRTOS)
**
**     Description :
**         The handle of the currently running (calling) task.
**     Parameters  : None
**     Returns     :
**         ---             - The handle of the currently running
**                           (calling) task.
** ===================================================================
*/
/*
xTaskHandle McuRTOS_xTaskGetCurrentTaskHandle(void)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xTaskGetIdleTaskHandle (component FreeRTOS)
**
**     Description :
**         The task handle associated with the Idle task. The Idle task
**         is created automatically when the RTOS scheduler is started.
**     Parameters  : None
**     Returns     :
**         ---             - The task handle associated with the Idle
**                           task. The Idle task is created
**                           automatically when the RTOS scheduler is
**                           started.
** ===================================================================
*/
/*
xTaskHandle McuRTOS_xTaskGetIdleTaskHandle(void)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  eTaskGetState (component FreeRTOS)
**
**     Description :
**         Returns as an enumerated type the state in which a task
**         existed at the time eTaskGetState() was executed. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xTask           - The handle of the subject task (the
**                           task being queried).
**     Returns     :
**         ---             - task state (eReady, eRunning, eBlocked,
**                           eSuspended, eDeleted)
** ===================================================================
*/
/*
eTaskState McuRTOS_eTaskGetState(xTaskHandle xTask)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  pcTaskGetTaskName (component FreeRTOS)
**
**     Description :
**         Returns the name of the task.
**     Parameters  :
**         NAME            - DESCRIPTION
**         xTaskToQuery    - The handle of the task
**                           being queried. xTaskToQuery can be set to
**                           NULL to query the name of the calling task.
**     Returns     :
**         ---             - A pointer to the subject tasks name, which
**                           is a standard NULL terminated C string
** ===================================================================
*/
/*
signed char McuRTOS_pcTaskGetTaskName(xTaskHandle xTaskToQuery)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xTaskGetTickCountFromISR (component FreeRTOS)
**
**     Description :
**         A version of xTaskGetTickCount() that can be called from an
**         ISR. 
**     Parameters  : None
**     Returns     :
**         ---             - The count of ticks since
**                           vTaskStartScheduler was called. 
** ===================================================================
*/
/*
portTickType McuRTOS_xTaskGetTickCountFromISR(void)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  vTaskStepTick (component FreeRTOS)
**
**     Description :
**          If the RTOS is configured to use tickless idle
**         functionality then the tick interrupt will be stopped, and
**         the microcontroller placed into a low power state, whenever
**         the Idle task is the only task able to execute. Upon exiting
**         the low power state the tick count value must be corrected
**         to account for the time that passed while it was stopped.
**         If a FreeRTOS port includes a default
**         portSUPPRESS_TICKS_AND_SLEEP() implementation, then
**         vTaskStepTick() is used internally to ensure the correct
**         tick count value is maintained. vTaskStepTick() is a public
**         API function to allow the default
**         portSUPPRESS_TICKS_AND_SLEEP() implementation to be
**         overridden, and for a portSUPPRESS_TICKS_AND_SLEEP() to be
**         provided if the port being used does not provide a default. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xTicksToJump    - The number of RTOS ticks
**                           that have passed since the tick interrupt
**                           was stopped. For correct operation the
**                           parameter must be less than or equal to the
**                           portSUPPRESS_TICKS_AND_SLEEP() parameter. 
**     Returns     : Nothing
** ===================================================================
*/
/*
void McuRTOS_vTaskStepTick(portTickType xTicksToJump)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xQueuePeekFromISR (component FreeRTOS)
**
**     Description :
**         A version of xQueuePeek() that can be used from an interrupt
**         service routine (ISR). Reads an item from a queue, but does
**         not remove the item from the queue. Therefore the same item
**         would be returned the next time xQueueReceive() or
**         xQueuePeek() was called on the same queue.
**     Parameters  :
**         NAME            - DESCRIPTION
**         xQueue          - The handle of the queue from which
**                           the data is to be read.
**         pvBuffer        - A pointer to the memory into
**                           which the data read from the queue will be
**                           copied. The length of the buffer must be at
**                           least equal to the queue item size (set
**                           when the queue was created).
**         xTicksToWait    - The number of ticks for
**                           which the calling task should be held in
**                           the Blocked state to wait for data to
**                           become available from the queue should the
**                           queue already be empty.
**                           A value of zero will prevent the calling
**                           task from entering the Blocked state.
**                           If INCLUDE_vTaskSuspend is set to 1 then a
**                           value of portMAX_DELAY will hold the task
**                           in the Blocked state indefinitely to wait
**                           for data.
**     Returns     :
**         ---             - pdPASS: Data was successfully read from
**                           the queue. If a block time was specified
**                           then the calling task may have been
**                           temporarily placed into the Blocked state
**                           to wait for data to become available and
**                           data did become available before the block
**                           time expired.
**                           errQUEUE_EMPTY: The queue was empty so no
**                           date could be read form the queue. If a
**                           block time was specified then the calling
**                           task may have been temporarily placed into
**                           the Blocked state to wait for data to
**                           become available, but no data became
**                           available before the block time expired.
** ===================================================================
*/
/*
portBASE_TYPE McuRTOS_xQueuePeekFromISR(xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWait)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xQueueOverwrite (component FreeRTOS)
**
**     Description :
**         This is a macro that calls the xQueueGenericSend() function.
**         A version of xQueueSendToBack() that will write to the queue
**         even if the queue is full, overwriting data that is already
**         held in the queue. xQueueOverwrite() is intended for use
**         with queues that have a length of one, meaning the queue is
**         either empty or full. This function must not be called from
**         an interrupt service routine (ISR). See
**         xQueueOverwriteFromISR() for an alternative which may be
**         used in an ISR. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xQueue          - The handle of the queue to which the
**                           data is to be sent.
**         pvItemToQueue   - A pointer to the data
**                           to be sent to the queue. The size of the
**                           data that can be sent to a queue was
**                           defined when the queue was created.
**     Returns     :
**         ---             - pdPASS: Data was successfully sent to the
**                           queue. If a block time was specified then
**                           the calling task may have been temporarily
**                           placed into the Blocked state to wait for
**                           space to become available and space did
**                           become available before the block time
**                           expired.
**                           errQUEUE_FULL: The queue is already full so
**                           no data could be sent to the queue. If a
**                           block time was specified then the calling
**                           task may have been temporarily placed into
**                           the Blocked state to wait for space to
**                           become available, but no space became
**                           available before the block time expired.
** ===================================================================
*/
/*
portBASE_TYPE McuRTOS_xQueueOverwrite(xQueueHandle xQueue, const void *pvItemToQueue)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xQueueOverwriteFromISR (component FreeRTOS)
**
**     Description :
**         This is a macro that calls the xQueueGenericSendFromISR()
**         function. A version of xQueueOverwrite() that can be used in
**         an ISR. xQueueOverwriteFromISR() is similar to
**         xQueueSendToBackFromISR(), but will write to the queue even
**         if the queue is full, overwriting data that is already held
**         in the queue. xQueueOverwriteFromISR() is intended for use
**         with queues that have a length of one, meaning the queue is
**         either empty or full. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xQueue          - The handle of the queue to which the
**                           data is to be sent.
**         pvItemToQueue   - A pointer to the data
**                           to be sent to the queue. The size of the
**                           data that can be sent to a queue was
**                           defined when the queue was created.
**       * pxHigherPriorityTaskWoken 
**                           - xQueueSendFromISR() will set
**                           *pxHigherPriorityTaskWoken to pdTRUE if
**                           sending to the queue caused a task to
**                           unblock, and the unblocked task has a
**                           priority higher than the currently running
**                           task. If xQueueSendFromISR() sets this
**                           value to pdTRUE then a context switch
**                           should be performed before the interrupt is
**                           exited.
**     Returns     :
**         ---             - pdTRUE Data was successfully sent to the
**                           queue.
**                           errQUEUE_FULL Data could not be sent to the
**                           queue because the queue was already full.
** ===================================================================
*/
/*
portBASE_TYPE McuRTOS_xQueueOverwriteFromISR(xQueueHandle xQueue, const void *pvItemToQueue, portBASE_TYPE *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  vQueueAddToRegistry (component FreeRTOS)
**
**     Description :
**         Assigns a name to a queue and adds the queue to the registry.
**     Parameters  :
**         NAME            - DESCRIPTION
**         xQueue          - The handle of the queue being added
**                           to the registry.
**       * pcQueueName     - Pointer to the name to be
**                           assigned to the queue. This is just a text
**                           string used to facilitate debugging.
**     Returns     : Nothing
** ===================================================================
*/
/*
void McuRTOS_vQueueAddToRegistry(xQueueHandle xQueue, char *pcQueueName)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  vQueueUnregisterQueue (component FreeRTOS)
**
**     Description :
**         Removes a queue from the queue registry. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xQueue          - The handle of the queue being
**                           removed from the registry.
**     Returns     : Nothing
** ===================================================================
*/
/*
void McuRTOS_vQueueUnregisterQueue(xQueueHandle xQueue)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xQueueIsQueueFullFromISR (component FreeRTOS)
**
**     Description :
**         Queries a queue to determine if the queue is full. This
**         function should only be used in an ISR. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xQueue          - The handle of the queue being
**                           queried.
**     Returns     :
**         ---             - pdFALSE if the queue is not full, or any
**                           other value if the queue is full. 
** ===================================================================
*/
/*
portBASE_TYPE McuRTOS_xQueueIsQueueFullFromISR(xQueueHandle xQueue)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xQueueIsQueueEmptyFromISR (component FreeRTOS)
**
**     Description :
**         Queries a queue to determine if the queue is empty. This
**         function should only be used in an ISR. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xQueue          - The handle of the queue being
**                           queried.
**     Returns     :
**         ---             - pdFALSE if the queue is not empty, or any
**                           other value if the queue is empty. 
** ===================================================================
*/
/*
portBASE_TYPE McuRTOS_xQueueIsQueueEmptyFromISR(xQueueHandle xQueue)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xQueueAddToSet (component FreeRTOS)
**
**     Description :
**          Adds an RTOS queue or semaphore to a queue set that was
**         previously created by a call to xQueueCreateSet().
**     Parameters  :
**         NAME            - DESCRIPTION
**         xQueueOrSemaphore - The handle of
**                           the queue or semaphore being added to the
**                           queue set (cast to an xQueueSetMemberHandle
**                           type). 
**         xQueueSet       - The handle of the queue set to
**                           which the queue or semaphore is being added.
**     Returns     :
**         ---             - If the queue or semaphore was successfully
**                           added to the queue set then pdPASS is
**                           returned. If the queue could not be
**                           successfully added to the queue set because
**                           it is already a member of a different queue
**                           set then pdFAIL is returned. 
** ===================================================================
*/
/*
portBASE_TYPE McuRTOS_xQueueAddToSet(xQueueSetMemberHandle xQueueOrSemaphore, xQueueSetHandle xQueueSet)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xQueueCreateSet (component FreeRTOS)
**
**     Description :
**         Queue sets provide a mechanism to allow an RTOS task to
**         block (pend) on a read operation from multiple RTOS queues
**         or semaphores simultaneously. Note that there are simpler
**         alternatives to using queue sets. See the Blocking on
**         Multiple Objects page for more information.
**     Parameters  :
**         NAME            - DESCRIPTION
**         uxEventQueueLength - 
**     Returns     :
**         ---             - If the queue set is created successfully
**                           then a handle to the created queue set is
**                           returned. Otherwise NULL is returned. 
** ===================================================================
*/
/*
xQueueSetHandle McuRTOS_xQueueCreateSet(unsigned portBASE_TYPE uxEventQueueLength)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xQueueRemoveFromSet (component FreeRTOS)
**
**     Description :
**         Remove an RTOS queue or semaphore from a queue set. An RTOS
**         queue or semaphore can only be removed from a queue set if
**         the queue or semaphore is empty. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xQueueOrSemaphore - The handle of
**                           the queue or semaphore being removed from
**                           the queue set (cast to an
**                           xQueueSetMemberHandle type). 
**         xQueueSet       - The handle of the queue set in
**                           which the queue or semaphore is included.
**     Returns     :
**         ---             - If the queue or semaphore was successfully
**                           added to the queue set then pdPASS is
**                           returned. If the queue could not be
**                           successfully added to the queue set because
**                           it is already a member of a different queue
**                           set then pdFAIL is returned. 
** ===================================================================
*/
/*
portBASE_TYPE McuRTOS_xQueueRemoveFromSet(xQueueSetMemberHandle xQueueOrSemaphore, xQueueSetHandle xQueueSet)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xQueueSelectFromSet (component FreeRTOS)
**
**     Description :
**         xQueueSelectFromSet() selects from the members of a queue
**         set a queue or semaphore that either contains data (in the
**         case of a queue) or is available to take (in the case of a
**         semaphore). xQueueSelectFromSet() effectively allows a task
**         to block (pend) on a read operation on all the queues and
**         semaphores in a queue set simultaneously. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xQueueSet       - The queue set on which the
**                           task will (potentially) block. 
**         xBlockTimeTicks - The maximum time,
**                           in ticks, that the calling task will remain
**                           in the Blocked state (with other tasks
**                           executing) to wait for a member of the
**                           queue set to be ready for a successful
**                           queue read or semaphore take operation. 
**     Returns     :
**         ---             - xQueueSelectFromSet() will return the
**                           handle of a queue (cast to a
**                           xQueueSetMemberHandle type) contained in
**                           the queue set that contains data, or the
**                           handle of a semaphore (cast to a
**                           xQueueSetMemberHandle type) contained in
**                           the queue set that is available, or NULL if
**                           no such queue or semaphore exists before
**                           before the specified block time expires. 
** ===================================================================
*/
/*
xQueueSetMemberHandle McuRTOS_xQueueSelectFromSet(xQueueSetHandle xQueueSet, portTickType xBlockTimeTicks)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xQueueSelectFromSetFromISR (component FreeRTOS)
**
**     Description :
**         A version of xQueueSelectFromSet() that can be used from an
**         interrupt service routine (ISR). 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xQueueSet       - The queue set being queried.
**                           It is not possible to block on a read as
**                           this function is designed to be used from
**                           an interrupt. 
**     Returns     :
**         ---             - xQueueSelectFromSet() will return the
**                           handle of a queue (cast to a
**                           xQueueSetMemberHandle type) contained in
**                           the queue set that contains data, or the
**                           handle of a semaphore (cast to a
**                           xQueueSetMemberHandle type) contained in
**                           the queue set that is available, or NULL if
**                           no such queue or semaphore exists before
**                           before the specified block time expires. 
** ===================================================================
*/
/*
xQueueSetMemberHandle McuRTOS_xQueueSelectFromSetFromISR(xQueueSetHandle xQueueSet)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xEventGroupCreate (component FreeRTOS)
**
**     Description :
**          Create a new RTOS event group. This function cannot be
**         called from an interrupt.
**         Event groups are stored in variables of type
**         EventGroupHandle_t. The number of bits (or flags)
**         implemented within an event group is 8 if
**         configUSE_16_BIT_TICKS is set to 1, or 24 if
**         configUSE_16_BIT_TICKS is set to 0. The dependency on
**         configUSE_16_BIT_TICKS results from the data type used for
**         thread local storage in the internal implementation of RTOS
**         tasks. 
**     Parameters  : None
**     Returns     :
**         ---             - Event Group Handle. If the event group was
**                           created then a handle to the event group is
**                           returned. If there was insufficient
**                           FreeRTOS heap available to create the event
**                           group then NULL is returned. 
** ===================================================================
*/
/*
EventGroupHandle_t McuRTOS_xEventGroupCreate(void)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xEventGroupWaitBits (component FreeRTOS)
**
**     Description :
**          Read bits within an RTOS event group, optionally entering
**         the Blocked state (with a timeout) to wait for a bit or
**         group of bits to become set. This function cannot be called
**         from an interrupt. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xEventGroup     - The event group in which
**                           the bits are being tested. The event group
**                           must have previously been created using a
**                           call to xEventGroupCreate(). 
**         uxBitsToWaitFor - A bitwise value
**                           that indicates the bit or bits to test
**                           inside the event group. For example, to
**                           wait for bit 0 and/or bit 2 set
**                           uxBitsToWaitFor to 0x05. To wait for bits 0
**                           and/or bit 1 and/or bit 2 set
**                           uxBitsToWaitFor to 0x07. Etc.
**                           uxBitsToWaitFor must not be set to 0. 
**         xClearOnExit    - If xClearOnExit is set
**                           to pdTRUE then any bits set in the value
**                           passed as the uxBitsToWaitFor parameter
**                           will be cleared in the event group before
**                           xEventGroupWaitBits() returns if
**                           xEventGroupWaitBits() returns for any
**                           reason other than a timeout. The timeout
**                           value is set by the xTicksToWait parameter.
**                           If xClearOnExit is set to pdFALSE then the
**                           bits set in the event group are not altered
**                           when the call to xEventGroupWaitBits()
**                           returns. 
**         xWaitForAllBits - xWaitForAllBits is
**                           used to create either a logical AND test
**                           (where all bits must be set) or a logical
**                           OR test (where one or more bits must be set)
**                           as follows:
**                           If xWaitForAllBits is set to pdTRUE then
**                           xEventGroupWaitBits() will return when
**                           either all the bits set in the value passed
**                           as the uxBitsToWaitFor parameter are set in
**                           the event group or the specified block time
**                           expires.
**                           If xWaitForAllBits is set to pdFALSE then
**                           xEventGroupWaitBits() will return when any
**                           of the bits set in the value passed as the
**                           uxBitsToWaitFor parameter are set in the
**                           event group or the specified block time
**                           expires. 
**         xTicksToWait    - The maximum amount of
**                           time (specified in 'ticks') to wait for
**                           one/all (depending on the xWaitForAllBits
**                           value) of the bits specified by
**                           uxBitsToWaitFor to become set. 
**     Returns     :
**         ---             - EventBits_t: The value of the event group
**                           at the time either the event bits being
**                           waited for became set, or the block time
**                           expired. The current value of the event
**                           bits in an event group will be different to
**                           the returned value if a higher priority
**                           task or interrupt changed the value of an
**                           event bit between the calling task leaving
**                           the Blocked state and exiting the
**                           xEventGroupWaitBits() function.
**                           Test the return value to know which bits
**                           were set. If xEventGroupWaitBits() returned
**                           because its timeout expired then not all
**                           the bits being waited for will be set. If
**                           xEventGroupWaitBits() returned because the
**                           bits it was waiting for were set then the
**                           returned value is the event group value
**                           before any bits were automatically cleared
**                           because the xClearOnExit parameter was set
**                           to pdTRUE. 
** ===================================================================
*/
/*
byte McuRTOS_xEventGroupWaitBits(const EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xEventGroupSetBits (component FreeRTOS)
**
**     Description :
**          Set bits (flags) within an RTOS event group. This function
**         cannot be called from an interrupt.
**         xEventGroupSetBitsFromISR() is a version that can be called
**         from an interrupt.
**         Setting bits in an event group will automatically unblock
**         tasks that are blocked waiting for the bits. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xEventGroup     - The event group in which
**                           the bits are to be set. The event group
**                           must have previously been created using a
**                           call to xEventGroupCreate(). 
**         uxBitsToSet     - A bitwise value that
**                           indicates the bit or bits to set in the
**                           event group. For example, set uxBitsToSet
**                           to 0x08 to set only bit 3. Set uxBitsToSet
**                           to 0x09 to set bit 3 and bit 0. 
**     Returns     :
**         ---             - The value of the event group at the time
**                           the call to xEventGroupSetBits() returns.
**                           There are two reasons why the returned
**                           value might have the bits specified by the
**                           uxBitsToSet parameter cleared:
**                           If setting a bit results in a task that was
**                           waiting for the bit leaving the blocked
**                           state then it is possible the bit will have
**                           been cleared automatically (see the
**                           xClearBitOnExit parameter of
**                           xEventGroupWaitBits()).
**                           Any unblocked (or otherwise Ready state)
**                           task that has a priority above that of the
**                           task that called xEventGroupSetBits() will
**                           execute and may change the event group
**                           value before the call to
**                           xEventGroupSetBits() returns.
** ===================================================================
*/
/*
EventBits_t McuRTOS_xEventGroupSetBits(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xEventGroupSetBitsFromISR (component FreeRTOS)
**
**     Description :
**          Set bits (flags) within an RTOS event group. A version of
**         xEventGroupSetBits() that can be called from an interrupt
**         service routine (ISR).
**         Setting bits in an event group will automatically unblock
**         tasks that are blocked waiting for the bits.
**         Setting bits in an event group is not a deterministic
**         operation because there are an unknown number of tasks that
**         may be waiting for the bit or bits being set. FreeRTOS does
**         not allow non-deterministic operations to be performed in
**         interrupts or from critical sections. Therefore
**         xEventGroupSetBitFromISR() sends a message to the RTOS
**         daemon task to have the set operation performed in the
**         context of the daemon task - where a scheduler lock is used
**         in place of a critical section.
**         INCLUDE_xEventGroupSetBitFromISR, configUSE_TIMERS and
**         INCLUDE_xTimerPendFunctionCall must all be set to 1 in
**         FreeRTOSConfig.h for the xEventGroupSetBitsFromISR()
**         function to be available. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xEventGroup     - The event group in which
**                           the bits are to be set. The event group
**                           must have previously been created using a
**                           call to xEventGroupCreate(). 
**         uxBitsToSet     - A bitwise value that
**                           indicates the bit or bits to set in the
**                           event group. For example, set uxBitsToSet
**                           to 0x08 to set only bit 3. Set uxBitsToSet
**                           to 0x09 to set bit 3 and bit 0. 
**         pxHigherPriorityTaskWoken 
**                           - Calling this function will result in a
**                           message being sent to the RTOS daemon task.
**                           If the priority of the daemon task is
**                           higher than the priority of the currently
**                           running task (the task the interrupt
**                           interrupted) then
**                           *pxHigherPriorityTaskWoken will be set to
**                           pdTRUE by xEventGroupSetBitsFromISR(),
**                           indicating that a context switch should be
**                           requested before the interrupt exits. For
**                           that reason *pxHigherPriorityTaskWoken must
**                           be initialised to pdFALSE. See the example
**                           code below. 
**     Returns     :
**         ---             - The value of the event group at the time
**                           the call to xEventGroupSetBits() returns.
**                           There are two reasons why the returned
**                           value might have the bits specified by the
**                           uxBitsToSet parameter cleared:
**                           If setting a bit results in a task that was
**                           waiting for the bit leaving the blocked
**                           state then it is possible the bit will have
**                           been cleared automatically (see the
**                           xClearBitOnExit parameter of
**                           xEventGroupWaitBits()).
**                           Any unblocked (or otherwise Ready state)
**                           task that has a priority above that of the
**                           task that called xEventGroupSetBits() will
**                           execute and may change the event group
**                           value before the call to
**                           xEventGroupSetBits() returns.
** ===================================================================
*/
/*
EventBits_t McuRTOS_xEventGroupSetBitsFromISR(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet , BaseType_t *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xEventGroupClearBits (component FreeRTOS)
**
**     Description :
**         Clear bits (flags) within an RTOS event group. This function
**         cannot be called from an interrupt. See
**         xEventGroupClearBitsFromISR() for a version that can be
**         called from an interrupt. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xEventGroup     - The event group in which
**                           the bits are to be cleared. The event group
**                           must have previously been created using a
**                           call to xEventGroupCreate(). 
**         uxBitsToSet     - A bitwise value that
**                           indicates the bit or bits to clear in the
**                           event group. For example set uxBitsToClear
**                           to 0x08 to clear just bit 3. Set
**                           uxBitsToClear to 0x09 to clear bit 3 and
**                           bit 0. 
**     Returns     :
**         ---             - The value of the event group at the time
**                           the call to xEventGroupSetBits() returns.
**                           There are two reasons why the returned
**                           value might have the bits specified by the
**                           uxBitsToSet parameter cleared:
**                           If setting a bit results in a task that was
**                           waiting for the bit leaving the blocked
**                           state then it is possible the bit will have
**                           been cleared automatically (see the
**                           xClearBitOnExit parameter of
**                           xEventGroupWaitBits()).
**                           Any unblocked (or otherwise Ready state)
**                           task that has a priority above that of the
**                           task that called xEventGroupSetBits() will
**                           execute and may change the event group
**                           value before the call to
**                           xEventGroupSetBits() returns.
** ===================================================================
*/
/*
EventBits_t McuRTOS_xEventGroupClearBits(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xEventGroupClearBitsFromISR (component FreeRTOS)
**
**     Description :
**          A version of xEventGroupClearBits() that can be called from
**         an interrupt. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xEventGroup     - The event group in which
**                           the bits are to be set. The event group
**                           must have previously been created using a
**                           call to xEventGroupCreate(). 
**         uxBitsToSet     - A bitwise value that
**                           indicates the bit or bits to set in the
**                           event group. For example, set uxBitsToSet
**                           to 0x08 to set only bit 3. Set uxBitsToSet
**                           to 0x09 to set bit 3 and bit 0. 
**     Returns     :
**         ---             - The value of the event group at the time
**                           the call to xEventGroupSetBits() returns.
**                           There are two reasons why the returned
**                           value might have the bits specified by the
**                           uxBitsToSet parameter cleared:
**                           If setting a bit results in a task that was
**                           waiting for the bit leaving the blocked
**                           state then it is possible the bit will have
**                           been cleared automatically (see the
**                           xClearBitOnExit parameter of
**                           xEventGroupWaitBits()).
**                           Any unblocked (or otherwise Ready state)
**                           task that has a priority above that of the
**                           task that called xEventGroupSetBits() will
**                           execute and may change the event group
**                           value before the call to
**                           xEventGroupSetBits() returns.
** ===================================================================
*/
/*
EventBits_t McuRTOS_xEventGroupClearBitsFromISR(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xEventGroupGetBits (component FreeRTOS)
**
**     Description :
**         Returns the current value of the event bits (event flags) in
**         an RTOS event group. This function cannot be used from an
**         interrupt. See xEventGroupsGetBitsFromISR() for a version
**         that can be used in an interrupt. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xEventGroup     - The event group being
**                           queried. The event group must have
**                           previously been created using a call to
**                           xEventGroupCreate().
**     Returns     :
**         ---             - The value of the event bits in the event
**                           group at the time xEventGroupGetBits() was
**                           called. 
** ===================================================================
*/
/*
EventBits_t McuRTOS_xEventGroupGetBits(EventGroupHandle_t xEventGroup)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xEventGroupGetBitsFromISR (component FreeRTOS)
**
**     Description :
**         A version of xEventGroupGetBits() that can be called from an
**         interrupt. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xEventGroup     - The event group being
**                           queried. The event group must have
**                           previously been created using a call to
**                           xEventGroupCreate().
**     Returns     :
**         ---             - The value of the event bits in the event
**                           group at the time xEventGroupGetBits() was
**                           called. 
** ===================================================================
*/
/*
EventBits_t McuRTOS_xEventGroupGetBitsFromISR(EventGroupHandle_t xEventGroup)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xEventGroupSync (component FreeRTOS)
**
**     Description :
**          Atomically set bits (flags) within an RTOS event group,
**         then wait for a combination of bits to be set within the
**         same event group. This functionality is typically used to
**         synchronise multiple tasks (often called a task rendezvous),
**         where each task has to wait for the other tasks to reach a
**         synchronisation point before proceeding.
**         This function cannot be used from an interrupt.
**         The function will return before its block time expires if
**         the bits specified by the uxBitsToWait parameter are set, or
**         become set within that time. In this case all the bits
**         specified by uxBitsToWait will be automatically cleared
**         before the function returns. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xEventGroup     - The event group in which
**                           the bits are being set and tested. The
**                           event group must have previously been
**                           created using a call to xEventGroupCreate().
**         uxBitsToSet     - The bit or bits to set in
**                           the event group before determining if (and
**                           possibly waiting for), all the bits
**                           specified by the uxBitsToWait parameter are
**                           set. For example, set uxBitsToSet to 0x04
**                           to set bit 2 within the event group. 
**         uxBitsToWaitFor - A bitwise value
**                           that indicates the bit or bits to test
**                           inside the event group. For example, set
**                           uxBitsToWaitFor to 0x05 to wait for bits 0
**                           and bit 2. Set uxBitsToWaitFor to 0x07 to
**                           wait for bit 0 and bit 1 and bit 2. Etc. 
**         xTicksToWait    - The maximum amount of
**                           time (specified in 'ticks') to wait for all
**                           the bits specified by the uxBitsToWaitFor
**                           parameter value to become set. 
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
/*
EventBits_t McuRTOS_xEventGroupSync(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xTimerCreate (component FreeRTOS)
**
**     Description :
**          Creates a new software timer instance. This allocates the
**         storage required by the new timer, initialises the new
**         timers internal state, and returns a handle by which the new
**         timer can be referenced.
**     Parameters  :
**         NAME            - DESCRIPTION
**         pcTimerName     -
**                           Atextnamethatisassignedtothetimer_Thisisdone
**                           purelytoassistdebugging_TheRTOSkernelitselfo
**                           nlyeverreferencesatimerbyitshandle_andneverb
**                           yitsname_
**         xTimerPeriod    - The timer period. The
**                           time is defined in tick periods so the
**                           constant portTICK_PERIOD_MS can be used to
**                           convert a time that has been specified in
**                           milliseconds. For example, if the timer
**                           must expire after 100 ticks, then
**                           xTimerPeriod should be set to 100.
**                           Alternatively, if the timer must expire
**                           after 500ms, then xPeriod can be set to (
**                           500 / portTICK_PERIOD_MS ) provided
**                           configTICK_RATE_HZ is less than or equal to
**                           1000. 
**         uxAutoReload    - If uxAutoReload is set
**                           to pdTRUE, then the timer will expire
**                           repeatedly with a frequency set by the
**                           xTimerPeriod parameter. If uxAutoReload is
**                           set to pdFALSE, then the timer will be a
**                           one-shot and enter the dormant state after
**                           it expires. 
**         pvTimerID       - An identifier that is assigned
**                           to the timer being created. Typically this
**                           would be used in the timer callback
**                           function to identify which timer expired
**                           when the same callback function is assigned
**                           to more than one timer. 
**         pxCallbackFunction - The function
**                           to call when the timer expires. Callback
**                           functions must have the prototype defined
**                           by TimerCallbackFunction_t, which is "void
**                           vCallbackFunction( TimerHandle_t xTimer );".
**     Returns     :
**         ---             - Timer handle. If the timer is successfully
**                           created then a handle to the newly created
**                           timer is returned. If the timer cannot be
**                           created (because either there is
**                           insufficient FreeRTOS heap remaining to
**                           allocate the timer structures, or the timer
**                           period was set to 0) then NULL is returned. 
** ===================================================================
*/
/*
TimerHandle_t McuRTOS_xTimerCreate(const char * const pcTimerName, const TickType_t xTimerPeriod, const UBaseType_t uxAutoReload, void *const pvTimerID, TimerCallbackFunction_t pxCallbackFunction)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xTimerIsTimerActive (component FreeRTOS)
**
**     Description :
**         Queries a timer to see if it is active or dormant.
**         A timer will be dormant if:
**         It has been created but not started, or
**         It is an expired one-shot timer that has not been restarted.
**         Timers are created in the dormant state. The xTimerStart(),
**         xTimerReset(), xTimerStartFromISR(), xTimerResetFromISR(),
**         xTimerChangePeriod() and xTimerChangePeriodFromISR() API
**         functions can all be used to transition a timer into the
**         active state. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xTimer          - The timer being queried. 
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
/*
BaseType_t McuRTOS_xTimerIsTimerActive(TimerHandle_t xTimer)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xTimerStart (component FreeRTOS)
**
**     Description :
**          Timer functionality is provided by a timer service/daemon
**         task. Many of the public FreeRTOS timer API functions send
**         commands to the timer service task through a queue called
**         the timer command queue. The timer command queue is private
**         to the RTOS kernel itself and is not directly accessible to
**         application code. The length of the timer command queue is
**         set by the configTIMER_QUEUE_LENGTH configuration constant.
**         xTimerStart() starts a timer that was previously created
**         using the xTimerCreate() API function. If the timer had
**         already been started and was already in the active state,
**         then xTimerStart() has equivalent functionality to the
**         xTimerReset() API function.
**         Starting a timer ensures the timer is in the active state.
**         If the timer is not stopped, deleted, or reset in the mean
**         time, the callback function associated with the timer will
**         get called 'n 'ticks after xTimerStart() was called, where
**         'n' is the timers defined period.
**         It is valid to call xTimerStart() before the RTOS scheduler
**         has been started, but when this is done the timer will not
**         actually start until the RTOS scheduler is started, and the
**         timers expiry time will be relative to when the RTOS
**         scheduler is started, not relative to when xTimerStart() was
**         called.
**         The configUSE_TIMERS configuration constant must be set to 1
**         for xTimerStart() to be available. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xTimer          - The handle of the timer being
**                           started/restarted. 
**         xBlockTime      - Specifies the time, in ticks,
**                           that the calling task should be held in the
**                           Blocked state to wait for the start command
**                           to be successfully sent to the timer
**                           command queue, should the queue already be
**                           full when xTimerStart() was called.
**                           xBlockTime is ignored if xTimerStart() is
**                           called before the RTOS scheduler is started.
**     Returns     :
**         ---             - pdFAIL will be returned if the start
**                           command could not be sent to the timer
**                           command queue even after xBlockTime ticks
**                           had passed. pdPASS will be returned if the
**                           command was successfully sent to the timer
**                           command queue. When the command is actually
**                           processed will depend on the priority of
**                           the timer service/daemon task relative to
**                           other tasks in the system, although the
**                           timers expiry time is relative to when
**                           xTimerStart() is actually called. The timer
**                           service/daemon task priority is set by the
**                           configTIMER_TASK_PRIORITY configuration
**                           constant.
** ===================================================================
*/
/*
BaseType_t McuRTOS_xTimerStart(TimerHandle_t xTimer, TickType_t xBlockTime)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xTimerStop (component FreeRTOS)
**
**     Description :
**          Timer functionality is provided by a timer service/daemon
**         task. Many of the public FreeRTOS timer API functions send
**         commands to the timer service task through a queue called
**         the timer command queue. The timer command queue is private
**         to the RTOS kernel itself and is not directly accessible to
**         application code. The length of the timer command queue is
**         set by the configTIMER_QUEUE_LENGTH configuration constant.
**         xTimerStop() stops a timer that was previously started using
**         either of the xTimerStart(), xTimerReset(),
**         xTimerStartFromISR(), xTimerResetFromISR(),
**         xTimerChangePeriod() and xTimerChangePeriodFromISR() API
**         functions.
**         Stopping a timer ensures the timer is not in the active
**         state.
**         The configUSE_TIMERS configuration constant must be set to 1
**         for xTimerStop() to be available. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xTimer          - The handle of the timer being
**                           stopped. 
**         xBlockTime      - Specifies the time, in ticks,
**                           that the calling task should be held in the
**                           Blocked state to wait for the stop command
**                           to be successfully sent to the timer
**                           command queue, should the queue already be
**                           full when xTimerStop() was called.
**                           xBlockTime is ignored if xTimerStop() is
**                           called before the RTOS scheduler is started.
**     Returns     :
**         ---             - pdFAIL will be returned if the stop
**                           command could not be sent to the timer
**                           command queue even after xBlockTime ticks
**                           had passed. pdPASS will be returned if the
**                           command was successfully sent to the timer
**                           command queue. When the command is actually
**                           processed will depend on the priority of
**                           the timer service/daemon task relative to
**                           other tasks in the system. The timer
**                           service/daemon task priority is set by the
**                           configTIMER_TASK_PRIORITY configuration
**                           constant. 
** ===================================================================
*/
/*
BaseType_t McuRTOS_xTimerStop(TimerHandle_t xTimer, TickType_t xBlockTime)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xTimerChangePeriod (component FreeRTOS)
**
**     Description :
**          Timer functionality is provided by a timer service/daemon
**         task. Many of the public FreeRTOS timer API functions send
**         commands to the timer service task through a queue called
**         the timer command queue. The timer command queue is private
**         to the RTOS kernel itself and is not directly accessible to
**         application code. The length of the timer command queue is
**         set by the configTIMER_QUEUE_LENGTH configuration constant.
**         xTimerChangePeriod() changes the period of a timer that was
**         previously created using the xTimerCreate() API function.
**         xTimerChangePeriod() can be called to change the period of
**         an active or dormant state timer.
**         The configUSE_TIMERS configuration constant must be set to 1
**         for xTimerChangePeriod() to be available. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xTimer          - The handle of the timer that is
**                           having its period changed. 
**         xNewPeriod      - The new period for xTimer.
**                           Timer periods are specified in tick periods,
**                           so the constant portTICK_PERIOD_MS can be
**                           used to convert a time that has been
**                           specified in milliseconds. For example, if
**                           the timer must expire after 100 ticks, then
**                           xNewPeriod should be set to 100.
**                           Alternatively, if the timer must expire
**                           after 500ms, then xNewPeriod can be set to
**                           ( 500 / portTICK_PERIOD_MS ) provided
**                           configTICK_RATE_HZ is less than or equal to
**                           1000. 
**         xBlockTime      - Specifies the time, in ticks,
**                           that the calling task should be held in the
**                           Blocked state to wait for the change period
**                           command to be successfully sent to the
**                           timer command queue, should the queue
**                           already be full when xTimerChangePeriod()
**                           was called. xBlockTime is ignored if
**                           xTimerChangePeriod() is called before the
**                           RTOS scheduler is started. 
**     Returns     :
**         ---             - pdFAIL will be returned if the change
**                           period command could not be sent to the
**                           timer command queue even after xBlockTime
**                           ticks had passed. pdPASS will be returned
**                           if the command was successfully sent to the
**                           timer command queue. When the command is
**                           actually processed will depend on the
**                           priority of the timer service/daemon task
**                           relative to other tasks in the system. The
**                           timer service/daemon task priority is set
**                           by the configTIMER_TASK_PRIORITY
**                           configuration constant. 
** ===================================================================
*/
/*
BaseType_t McuRTOS_xTimerChangePeriod(TimerHandle_t xTimer, TickType_t xNewPeriod, TickType_t xBlockTime)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xTimerDelete (component FreeRTOS)
**
**     Description :
**          Timer functionality is provided by a timer service/daemon
**         task. Many of the public FreeRTOS timer API functions send
**         commands to the timer service task through a queue called
**         the timer command queue. The timer command queue is private
**         to the RTOS kernel itself and is not directly accessible to
**         application code. The length of the timer command queue is
**         set by the configTIMER_QUEUE_LENGTH configuration constant.
**         xTimerDelete() deletes a timer that was previously created
**         using the xTimerCreate() API function.
**         The configUSE_TIMERS configuration constant must be set to 1
**         for xTimerDelete() to be available. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xTimer          - The handle of the timer being
**                           deleted. 
**         xBlockTime      - Specifies the time, in ticks,
**                           that the calling task should be held in the
**                           Blocked state to wait for the delete
**                           command to be successfully sent to the
**                           timer command queue, should the queue
**                           already be full when xTimerDelete() was
**                           called. xBlockTime is ignored if
**                           xTimerDelete() is called before the RTOS
**                           scheduler is started. 
**     Returns     :
**         ---             - pdFAIL will be returned if the delete
**                           command could not be sent to the timer
**                           command queue even after xBlockTime ticks
**                           had passed. pdPASS will be returned if the
**                           command was successfully sent to the timer
**                           command queue. When the command is actually
**                           processed will depend on the priority of
**                           the timer service/daemon task relative to
**                           other tasks in the system. The timer
**                           service/daemon task priority is set by the
**                           configTIMER_TASK_PRIORITY configuration
**                           constant. 
** ===================================================================
*/
/*
BaseType_t McuRTOS_xTimerDelete(TickType_t xTimer, TickType_t xBlockTime)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xTimerReset (component FreeRTOS)
**
**     Description :
**          Timer functionality is provided by a timer service/daemon
**         task. Many of the public FreeRTOS timer API functions send
**         commands to the timer service task through a queue called
**         the timer command queue. The timer command queue is private
**         to the RTOS kernel itself and is not directly accessible to
**         application code. The length of the timer command queue is
**         set by the configTIMER_QUEUE_LENGTH configuration constant.
**         xTimerReset() re-starts a timer that was previously created
**         using the xTimerCreate() API function. If the timer had
**         already been started and was already in the active state,
**         then xTimerReset() will cause the timer to re-evaluate its
**         expiry time so that it is relative to when xTimerReset() was
**         called. If the timer was in the dormant state then
**         xTimerReset() has equivalent functionality to the
**         xTimerStart() API function.
**         Resetting a timer ensures the timer is in the active state.
**         If the timer is not stopped, deleted, or reset in the mean
**         time, the callback function associated with the timer will
**         get called 'n' ticks after xTimerReset() was called, where
**         'n' is the timers defined period.
**         It is valid to call xTimerReset() before the RTOS scheduler
**         has been started, but when this is done the timer will not
**         actually start until the RTOS scheduler is started, and the
**         timers expiry time will be relative to when the RTOS
**         scheduler is started, not relative to when xTimerReset() was
**         called.
**         The configUSE_TIMERS configuration constant must be set to 1
**         for xTimerReset() to be available. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xTimer          - The handle of the timer being
**                           reset/started/restarted. 
**         xBlockTime      - Specifies the time, in ticks,
**                           that the calling task should be held in the
**                           Blocked state to wait for the reset command
**                           to be successfully sent to the timer
**                           command queue, should the queue already be
**                           full when xTimerReset() was called.
**                           xBlockTime is ignored if xTimerReset() is
**                           called before the RTOS scheduler is started.
**     Returns     :
**         ---             - pdFAIL will be returned if the reset
**                           command could not be sent to the timer
**                           command queue even after xBlockTime ticks
**                           had passed. pdPASS will be returned if the
**                           command was successfully sent to the timer
**                           command queue. When the command is actually
**                           processed will depend on the priority of
**                           the timer service/daemon task relative to
**                           other tasks in the system, although the
**                           timers expiry time is relative to when
**                           xTimerReset() is actually called. The timer
**                           service/daemon task priority is set by the
**                           configTIMER_TASK_PRIORITY configuration
**                           constant. 
** ===================================================================
*/
/*
BaseType_t McuRTOS_xTimerReset(TimerHandle_t xTimer, TickType_t xBlockTime)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xTimerStartFromISR (component FreeRTOS)
**
**     Description :
**         A version of xTimerStart() that can be called from an
**         interrupt service routine. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xTimer          - The handle of the timer being
**                           started/restarted. 
**       * pxHigherPriorityTaskWoken 
**                           - The timer service/daemon task spends most
**                           of its time in the Blocked state, waiting
**                           for messages to arrive on the timer command
**                           queue. Calling xTimerStartFromISR() writes
**                           a message to the timer command queue, so
**                           has the potential to transition the timer
**                           service/daemon task out of the Blocked
**                           state. If calling xTimerStartFromISR()
**                           causes the timer service/daemon task to
**                           leave the Blocked state, and the timer
**                           service/ daemon task has a priority equal
**                           to or greater than the currently executing
**                           task (the task that was interrupted), then
**                           *pxHigherPriorityTaskWoken will get set to
**                           pdTRUE internally within the
**                           xTimerStartFromISR() function. If
**                           xTimerStartFromISR() sets this value to
**                           pdTRUE, then a context switch should be
**                           performed before the interrupt exits. 
**     Returns     :
**         ---             - pdFAIL will be returned if the start
**                           command could not be sent to the timer
**                           command queue. pdPASS will be returned if
**                           the command was successfully sent to the
**                           timer command queue. When the command is
**                           actually processed will depend on the
**                           priority of the timer service/daemon task
**                           relative to other tasks in the system,
**                           although the timers expiry time is relative
**                           to when xTimerStartFromISR() is actually
**                           called. The timer service/daemon task
**                           priority is set by the
**                           configTIMER_TASK_PRIORITY configuration
**                           constant. 
** ===================================================================
*/
/*
BaseType_t McuRTOS_xTimerStartFromISR(TimerHandle_t xTimer, BaseType_t *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xTimerStopFromISR (component FreeRTOS)
**
**     Description :
**         A version of xTimerStop() that can be called from an
**         interrupt service routine.
**     Parameters  :
**         NAME            - DESCRIPTION
**         xTimer          - The handle of the timer being
**                           stopped. 
**       * pxHigherPriorityTaskWoken 
**                           - The timer service/daemon task spends most
**                           of its time in the Blocked state, waiting
**                           for messages to arrive on the timer command
**                           queue. Calling xTimerStopFromISR() writes a
**                           message to the timer command queue, so has
**                           the potential to transition the timer
**                           service/daemon task out of the Blocked
**                           state. If calling xTimerStopFromISR()
**                           causes the timer service/daemon task to
**                           leave the Blocked state, and the timer
**                           service/ daemon task has a priority equal
**                           to or greater than the currently executing
**                           task (the task that was interrupted), then
**                           *pxHigherPriorityTaskWoken will get set to
**                           pdTRUE internally within the
**                           xTimerStopFromISR() function. If
**                           xTimerStopFromISR() sets this value to
**                           pdTRUE, then a context switch should be
**                           performed before the interrupt exits. 
**     Returns     :
**         ---             - pdFAIL will be returned if the stop
**                           command could not be sent to the timer
**                           command queue. pdPASS will be returned if
**                           the command was successfully sent to the
**                           timer command queue. When the command is
**                           actually processed will depend on the
**                           priority of the timer service/daemon task
**                           relative to other tasks in the system. The
**                           timer service/daemon task priority is set
**                           by the configTIMER_TASK_PRIORITY
**                           configuration constant. 
** ===================================================================
*/
/*
BaseType_t McuRTOS_xTimerStopFromISR(TimerHandle_t xTimer, BaseType_t *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xTimerChangePeriodFromISR (component FreeRTOS)
**
**     Description :
**         A version of xTimerChangePeriod() that can be called from an
**         interrupt service routine. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xTimer          - The handle of the timer that is
**                           having its period changed. 
**         xNewPeriod      - The new period for xTimer.
**                           Timer periods are specified in tick periods,
**                           so the constant portTICK_PERIOD_MS can be
**                           used to convert a time that has been
**                           specified in milliseconds. For example, if
**                           the timer must expire after 100 ticks, then
**                           xNewPeriod should be set to 100.
**                           Alternatively, if the timer must expire
**                           after 500ms, then xNewPeriod can be set to
**                           ( 500 / portTICK_PERIOD_MS ) provided
**                           configTICK_RATE_HZ is less than or equal to
**                           1000. 
**       * pxHigherPriorityTaskWoken 
**                           - The timer service/daemon task spends most
**                           of its time in the Blocked state, waiting
**                           for messages to arrive on the timer command
**                           queue. Calling xTimerChangePeriodFromISR()
**                           writes a message to the timer command queue,
**                           so has the potential to transition the
**                           timer service/ daemon task out of the
**                           Blocked state. If calling
**                           xTimerChangePeriodFromISR() causes the
**                           timer service/daemon task to leave the
**                           Blocked state, and the timer service/daemon
**                           task has a priority equal to or greater
**                           than the currently executing task (the task
**                           that was interrupted), then
**                           *pxHigherPriorityTaskWoken will get set to
**                           pdTRUE internally within the
**                           xTimerChangePeriodFromISR() function. If
**                           xTimerChangePeriodFromISR() sets this value
**                           to pdTRUE, then a context switch should be
**                           performed before the interrupt exits. 
**     Returns     :
**         ---             - pdFAIL will be returned if the command to
**                           change the timers period could not be sent
**                           to the timer command queue. pdPASS will be
**                           returned if the command was successfully
**                           sent to the timer command queue. When the
**                           command is actually processed will depend
**                           on the priority of the timer service/daemon
**                           task relative to other tasks in the system.
**                           The timer service/daemon task priority is
**                           set by the configTIMER_TASK_PRIORITY
**                           configuration constant. 
** ===================================================================
*/
/*
BaseType_t McuRTOS_xTimerChangePeriodFromISR(TimerHandle_t xTimer, TickType_t xNewPeriod, BaseType_t *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xTimerResetFromISR (component FreeRTOS)
**
**     Description :
**         A version of xTimerReset() that can be called from an
**         interrupt service routine.
**     Parameters  :
**         NAME            - DESCRIPTION
**         xTimer          - The handle of the timer that is to
**                           be started, reset, or restarted. 
**       * pxHigherPriorityTaskWoken 
**                           - The timer service/daemon task spends most
**                           of its time in the Blocked state, waiting
**                           for messages to arrive on the timer command
**                           queue. Calling xTimerResetFromISR() writes
**                           a message to the timer command queue, so
**                           has the potential to transition the timer
**                           service/daemon task out of the Blocked
**                           state. If calling xTimerResetFromISR()
**                           causes the timer service/daemon task to
**                           leave the Blocked state, and the timer
**                           service/ daemon task has a priority equal
**                           to or greater than the currently executing
**                           task (the task that was interrupted), then
**                           *pxHigherPriorityTaskWoken will get set to
**                           pdTRUE internally within the
**                           xTimerResetFromISR() function. If
**                           xTimerResetFromISR() sets this value to
**                           pdTRUE then a context switch should be
**                           performed before the interrupt exits. 
**     Returns     :
**         ---             - pdFAIL will be returned if the reset
**                           command could not be sent to the timer
**                           command queue. pdPASS will be returned if
**                           the command was successfully sent to the
**                           timer command queue. When the command is
**                           actually processed will depend on the
**                           priority of the timer service/daemon task
**                           relative to other tasks in the system,
**                           although the timers expiry time is relative
**                           to when xTimerResetFromISR() is actually
**                           called. The timer service/daemon task
**                           priority is set by the
**                           configTIMER_TASK_PRIORITY configuration
**                           constant. 
** ===================================================================
*/
/*
BaseType_t McuRTOS_xTimerResetFromISR(TimerHandle_t xTimer, BaseType_t *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  pvTimerGetTimerID (component FreeRTOS)
**
**     Description :
**          Returns the ID assigned to the timer.
**         IDs are assigned to timers using the pvTimerID parameter of
**         the call to xTimerCreate() that was used to create the timer.
**         If the same callback function is assigned to multiple timers
**         then the timer ID can be used within the callback function
**         to identify which timer actually expired. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xTimer          - The timer being queried. 
**     Returns     :
**         ---             - The ID assigned to the timer being queried.
** ===================================================================
*/
/*
void* McuRTOS_pvTimerGetTimerID(TimerHandle_t xTimer)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xTimerGetTimerDaemonTaskHandle (component FreeRTOS)
**
**     Description :
**         INCLUDE_xTimerGetTimerDaemonTaskHandle and configUSE_TIMERS
**         must both be set to 1 in FreeRTOSConfig.h for
**         xTimerGetTimerDaemonTaskHandle() to be available. 
**     Parameters  : None
**     Returns     :
**         ---             - Returns the task handle associated with
**                           the software timer daemon (or service) task.
**                           If configUSE_TIMERS is set to 1 in
**                           FreeRTOSConfig.h, then the timer daemon
**                           task is created automatically when the RTOS
**                           scheduler is started. 
** ===================================================================
*/
/*
TaskHandle_t McuRTOS_xTimerGetTimerDaemonTaskHandle(void)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  pcTimerGetTimerName (component FreeRTOS)
**
**     Description :
**         
**     Parameters  :
**         NAME            - DESCRIPTION
**         xTimer          - The handle of the timer being
**                           queried. 
**     Returns     :
**         ---             - A pointer to the timer's name, which is a
**                           standard NULL terminated C string. 
** ===================================================================
*/
/*
char* McuRTOS_pcTimerGetTimerName(TimerHandle_t xTimer)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xTimerPendFunctionCall (component FreeRTOS)
**
**     Description :
**          Used to pend the execution of a function to the RTOS daemon
**         task (the timer service task, hence this function is
**         pre-fixed with 'Timer').
**         Functions that can be deferred to the RTOS daemon task must
**         have the following prototype:
**         void vPendableFunction( void * pvParameter1, uint32_t
**         ulParameter2 );
**         The pvParameter1 and ulParameter2 are provided for use by
**         the application code.
**         INCLUDE_xTimerPendFunctionCall() and configUSE_TIMERS must
**         both be set to 1 for xTimerPendFunctionCall() to be
**         available. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xFunctionToPend - The function to
**                           execute from the timer service/ daemon task.
**                           The function must conform to the
**                           PendedFunction_t prototype as shown above. 
**       * pvParameter1    - The value of the
**                           callback function's first parameter. The
**                           parameter has a void * type to allow it to
**                           be used to pass any type. For example,
**                           integer types can be cast to a void *, or
**                           the void * can be used to point to a
**                           structure. 
**         ulParameter2    - The value of the
**                           callback function's second parameter. 
**         xTicksToWait    -  	Calling this function
**                           will result in a message being sent to the
**                           timer daemon task on a queue. xTicksToWait
**                           is the amount of time the calling task
**                           should remain in the Blocked state (so not
**                           using any processing time) for space to
**                           become available on the timer queue if the
**                           queue is found to be full. The length of
**                           the queue is set by the value of
**                           configTIMER_QUEUE_LENGTH in FreeRTOSConfig.
**                           h. 
**     Returns     :
**         ---             - pdPASS is returned if the message was
**                           successfully sent to the RTOS timer daemon
**                           task, otherwise pdFALSE is returned. 
** ===================================================================
*/
/*
BaseType_t McuRTOS_xTimerPendFunctionCall(PendedFunction_t xFunctionToPend, void* pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xTimerPendFunctionCallFromISR (component FreeRTOS)
**
**     Description :
**          Used from application interrupt service routines to defer
**         the execution of a function to the RTOS daemon task (the
**         timer service task, hence this function is implemented in
**         timers.c and is prefixed with 'Timer').
**         Ideally an interrupt service routine (ISR) is kept as short
**         as possible, but sometimes an ISR either has a lot of
**         processing to do, or needs to perform processing that is not
**         deterministic. In these cases xTimerPendFunctionCallFromISR()
**         can be used to defer processing of a function to the RTOS
**         daemon task.
**         A mechanism is provided that allows the interrupt to return
**         directly to the task that will subsequently execute the
**         pended function. This allows the callback function to
**         execute contiguously in time with the interrupt - just as if
**         the callback had executed in the interrupt itself.
**         Functions that can be deferred to the RTOS daemon task must
**         have the following prototype:
**         void vPendableFunction( void * pvParameter1, uint32_t
**         ulParameter2 );
**         The pvParameter1 and ulParameter2 are provided for use by
**         the application code.
**         INCLUDE_xTimerPendFunctionCall() and configUSE_TIMERS must
**         both be set to 1 for xTimerPendFunctionCallFromISR() to be
**         available. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xFunctionToPend - The function to
**                           execute from the timer service/ daemon task.
**                           The function must conform to the
**                           PendedFunction_t prototype as shown above. 
**       * pvParameter1    -  	The value of the
**                           callback function's first parameter. The
**                           parameter has a void * type to allow it to
**                           be used to pass any type. For example,
**                           integer types can be cast to a void *, or
**                           the void * can be used to point to a
**                           structure. 
**         ulParameter2    - The value of the
**                           callback function's second parameter. 
**       * pxHigherPriorityTaskWoken 
**                           - As mentioned above, calling
**                           xTimerPendFunctionCallFromISR() will result
**                           in a message being sent to the RTOS timer
**                           daemon task. If the priority of the daemon
**                           task (which is set using
**                           configTIMER_TASK_PRIORITY in FreeRTOSConfig.
**                           h) is higher than the priority of the
**                           currently running task (the task the
**                           interrupt interrupted) then
**                           *pxHigherPriorityTaskWoken will be set to
**                           pdTRUE within
**                           xTimerPendFunctionCallFromISR(), indicating
**                           that a context switch should be requested
**                           before the interrupt exits. For that reason
**                           *pxHigherPriorityTaskWoken must be
**                           initialised to pdFALSE. See the example
**                           code below. 
**     Returns     :
**         ---             - pdPASS is returned if the message was
**                           successfully sent to the RTOS timer daemon
**                           task, otherwise pdFALSE is returned. 
** ===================================================================
*/
/*
BaseType_t McuRTOS_xTimerPendFunctionCallFromISR(PendedFunction_t xFunctionToPend, void* pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xTaskNotifyGive (component FreeRTOS)
**
**     Description :
**          Each RTOS task has a 32-bit notification value which is
**         initialised to zero when the RTOS task is created. An RTOS
**         task notification is an event sent directly to a task that
**         can unblock the receiving task, and optionally update the
**         receiving task's notification value.
**         xTaskNotifyGive() is a macro intended for use when an RTOS
**         task notification value is being used as a light weight and
**         faster binary or counting semaphore alternative. FreeRTOS
**         semaphores are given using the xSemaphoreGive() API function,
**         xTaskNotifyGive() is the equivalent that instead uses the
**         receiving RTOS task's notification value.
**         When a task notification value is being used as a binary or
**         counting semaphore equivalent then the task being notified
**         should wait for the notification using the ulTaskNotifyTake()
**         API function rather than the xTaskNotifyWait() API function.
**         xTaskNotifyGive() must not be called from an interrupt
**         service routine. Use vTaskNotifyGiveFromISR() instead. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xTaskToNotify   - The handle of the RTOS
**                           task being notified, and having its
**                           notification value incremented.
**                           RTOS task handles are obtained using the
**                           pvCreatedTask parameter of the xTaskCreate()
**                           call used to create the task.
**                           The handle of the currently executing RTOS
**                           task is returned by the
**                           xTaskGetCurrentTaskHandle() API function. 
**     Returns     :
**         ---             - xTaskNotifyGive() is a macro that calls
**                           xTaskNotify() with the eAction parameter
**                           set to eIncrement resulting in all calls
**                           returning pdPASS. 
** ===================================================================
*/
/*
BaseType_t McuRTOS_xTaskNotifyGive(TaskHandle_t xTaskToNotify)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  ulTaskNotifyTake (component FreeRTOS)
**
**     Description :
**          Each RTOS task has a 32-bit notification value which is
**         initialised to zero when the RTOS task is created. An RTOS
**         task notification is an event sent directly to a task that
**         can unblock the receiving task, and optionally update the
**         receiving task's notification value.
**         ulTaskNotifyTake() is intended for use when a task
**         notification is used as a faster and lighter weight binary
**         or counting semaphore alternative. FreeRTOS semaphores are
**         taken using the xSemaphoreTake() API function,
**         ulTaskNotifyTake() is the equivalent that instead uses a
**         task notification.
**         When a task is using its notification value as a binary or
**         counting semaphore other tasks and interrupts should send
**         notifications to it using either the xTaskNotifyGive() macro,
**         or the xTaskNotify() function with the function's eAction
**         parameter set to eIncrement (the two are equivalent).
**         ulTaskNotifyTake() can either clear the task's notification
**         value to zero on exit, in which case the notification value
**         acts like a binary semaphore, or decrement the task's
**         notification value on exit, in which case the notification
**         value acts more like a counting semaphore.
**         An RTOS task can use ulTaskNotifyTake() to [optionally]
**         block to wait for a the task's notification value to be
**         non-zero. The task does not consume any CPU time while it is
**         in the Blocked state.
**         Where as xTaskNotifyWait() will return when a notification
**         is pending, ulTaskNotifyTake() will return when the task's
**         notification value is not zero, decrementing the task's
**         notification value before it returns. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xClearCountOnExit - If an RTOS
**                           task notification is received and
**                           xClearCountOnExit is set to pdFALSE then
**                           the RTOS task's notification value is
**                           decremented before ulTaskNotifyTake() exits.
**                           This is equivalent to the value of a
**                           counting semaphore being decremented by a
**                           successful call to xSemaphoreTake().
**                           If an RTOS task notification is received
**                           and xClearCountOnExit is set to pdTRUE then
**                           the RTOS task's notification value is reset
**                           to 0 before ulTaskNotifyTake() exits. This
**                           is equivalent to the value of a binary
**                           semaphore being left at zero (or empty, or
**                           'not available') after a successful call to
**                           xSemaphoreTake(). 
**         xTicksToWait    - The maximum time to wait
**                           in the Blocked state for a notification to
**                           be received if a notification is not
**                           already pending when ulTaskNotifyTake() is
**                           called.
**                           The RTOS task does not consume any CPU time
**                           when it is in the Blocked state.
**                           The time is specified in RTOS tick periods.
**                           The pdMS_TO_TICKS() macro can be used to
**                           convert a time specified in milliseconds
**                           into a time specified in ticks. 
**     Returns     :
**         ---             - The value of the task's notification value
**                           before it is decremented or cleared (see
**                           the description of xClearCountOnExit). 
** ===================================================================
*/
/*
uint32_t McuRTOS_ulTaskNotifyTake(BaseType_t xClearCountOnExit, TickType_t xTicksToWait)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  vTaskNotifyGiveFromISR (component FreeRTOS)
**
**     Description :
**          A version of xTaskNotifyGive() that can be called from an
**         interrupt service routine (ISR).
**         Each RTOS task has a 32-bit notification value which is
**         initialised to zero when the RTOS task is created. An RTOS
**         task notification is an event sent directly to a task that
**         can unblock the receiving task, and optionally update the
**         receiving task's notification value.
**         vTaskNotifyGiveFromISR() is a function intended for use when
**         an RTOS task notification value is being used as a light
**         weight and faster binary or counting semaphore alternative.
**         FreeRTOS semaphores are given from an interrupt using the
**         xSemaphoreGiveFromISR() API function,
**         vTaskNotifyGiveFromISR() is the equivalent that instead uses
**         the receiving RTOS task's notification value.
**         When a task notification value is being used as a binary or
**         counting semaphore equivalent then the task being notified
**         should wait for the notification using the ulTaskNotifyTake()
**         API function rather than the xTaskNotifyWait() API function. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xTaskToNotify   - The handle of the RTOS
**                           task being notified, and having its
**                           notification value incremented.
**                           RTOS task handles are obtained using the
**                           pvCreatedTask parameter of the xTaskCreate()
**                           call used to create the task.
**                           The handle of the currently executing RTOS
**                           task is returned by the
**                           xTaskGetCurrentTaskHandle() API function. 
**       * pxHigherPriorityTaskWoken 
**                           - *pxHigherPriorityTaskWoken must be
**                           initialised to 0.
**                           vTaskNotifyGiveFromISR() will set
**                           *pxHigherPriorityTaskWoken to pdTRUE if
**                           sending the notification caused a task to
**                           unblock, and the unblocked task has a
**                           priority higher than the currently running
**                           task.
**                           If vTaskNotifyGiveFromISR() sets this value
**                           to pdTRUE then a context switch should be
**                           requested before the interrupt is exited.
**                           See the example below.
**                           pxHigherPriorityTaskWoken is an optional
**                           parameter and can be set to NULL. 
**     Returns     : Nothing
** ===================================================================
*/
/*
void McuRTOS_vTaskNotifyGiveFromISR(TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xTaskNotify (component FreeRTOS)
**
**     Description :
**          [If you are using RTOS task notifications to implement
**         binary or counting semaphore type behaviour then use the
**         simpler xTaskNotifyGive() API function instead of
**         xTaskNotify()]
**         Each RTOS task has a 32-bit notification value which is
**         initialised to zero when the RTOS task is created.
**         xTaskNotify() is used to send an event directly to and
**         potentially unblock an RTOS task, and optionally update the
**         receiving task's notification value in one of the following
**         ways:
**         - Write a 32-bit number to the notification value
**         - Add one (increment) the notification value
**         - Set one or more bits in the notification value
**         - Leave the notification value unchanged
**         This function must not be called from an interrupt service
**         routine (ISR). Use xTaskNotifyFromISR() instead. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xTaskToNotify   - The handle of the RTOS
**                           task being notified. This is the subject
**                           task.
**                           RTOS task handles are obtained using the
**                           pvCreatedTask parameter of the xTaskCreate()
**                           call used to create the task.
**                           The handle of the currently executing RTOS
**                           task is returned by the
**                           xTaskGetCurrentTaskHandle() API function. 
**         ulValue         - Used to update the notification
**                           value of the subject task. See the
**                           description of the eAction parameter below. 
**         eAction         - An enumerated type that can take
**                           one of the values documented in the table
**                           below in order to perform the associated
**                           action. 
**                           - eNoAction: 	The subject task receives the
**                           event, but its notification value is not
**                           updated. In this case ulValue is not used.
**                           - eSetBits: 	The notification value of the
**                           subject task will be bitwise ORed with
**                           ulValue. For example, if ulValue is set to
**                           0x01, then bit 0 will get set within the
**                           subject task's notification value. Likewise
**                           if ulValue is 0x04 then bit 2 will get set
**                           in the subject task's notification value.
**                           In this way the RTOS task notification
**                           mechanism can be used as a light weight
**                           alternative to an event group.
**                           - eIncrement: 	The notification value of
**                           the subject task will be incremented by one,
**                           making the call to xTaskNotify() equivalent
**                           to a call to xTaskNotifyGive(). In this
**                           case ulValue is not used.
**                           - eSetValueWithOverwrite: 	The notification
**                           value of the subject task is
**                           unconditionally set to ulValue. In this way
**                           the RTOS task notification mechanism is
**                           being used as a light weight alternative to
**                           xQueueOverwrite().
**                           - eSetValueWithoutOverwrite: 	If the
**                           subject task does not already have a
**                           notification pending then its notification
**                           value will be set to ulValue. If the
**                           subject task already has a notification
**                           pending then its notification value is not
**                           updated as to do so would overwrite the
**                           previous value before it was used. In this
**                           case the call to xTaskNotify() fails and
**                           pdFALSE is returned. In this way the RTOS
**                           task notification mechanism is being used
**                           as a light weight alternative to
**                           xQueueSend() on a queue of length 1. 
**     Returns     :
**         ---             - pdPASS is returned in all cases other than
**                           when eAction is set to
**                           eSetValueWithoutOverwrite and the subject
**                           task's notification value cannot be updated
**                           because the subject task already had a
**                           notification pending. 
** ===================================================================
*/
/*
BaseType_t McuRTOS_xTaskNotify(TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xTaskNotifyFromISR (component FreeRTOS)
**
**     Description :
**          [If you are using RTOS task notifications to implement
**         binary or counting semaphore type behaviour then use the
**         simpler xTaskNotifyGive() API function instead of
**         xTaskNotify()]
**         A version of xTaskNotify() that can be called from an ISR. 
**         Each RTOS task has a 32-bit notification value which is
**         initialised to zero when the RTOS task is created.
**         xTaskNotify() is used to send an event directly to and
**         potentially unblock an RTOS task, and optionally update the
**         receiving task's notification value in one of the following
**         ways:
**         - Write a 32-bit number to the notification value
**         - Add one (increment) the notification value
**         - Set one or more bits in the notification value
**         - Leave the notification value unchanged
**         This function must not be called from an interrupt service
**         routine (ISR). Use xTaskNotifyFromISR() instead. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xTaskToNotify   - The handle of the RTOS
**                           task being notified. This is the subject
**                           task.
**                           RTOS task handles are obtained using the
**                           pvCreatedTask parameter of the xTaskCreate()
**                           call used to create the task.
**                           The handle of the currently executing RTOS
**                           task is returned by the
**                           xTaskGetCurrentTaskHandle() API function. 
**         ulValue         - Used to update the notification
**                           value of the subject task. See the
**                           description of the eAction parameter below. 
**         eAction         - An enumerated type that can take
**                           one of the values documented in the table
**                           below in order to perform the associated
**                           action. 
**                           - eNoAction: 	The subject task receives the
**                           event, but its notification value is not
**                           updated. In this case ulValue is not used.
**                           - eSetBits: 	The notification value of the
**                           subject task will be bitwise ORed with
**                           ulValue. For example, if ulValue is set to
**                           0x01, then bit 0 will get set within the
**                           subject task's notification value. Likewise
**                           if ulValue is 0x04 then bit 2 will get set
**                           in the subject task's notification value.
**                           In this way the RTOS task notification
**                           mechanism can be used as a light weight
**                           alternative to an event group.
**                           - eIncrement: 	The notification value of
**                           the subject task will be incremented by one,
**                           making the call to xTaskNotify() equivalent
**                           to a call to xTaskNotifyGive(). In this
**                           case ulValue is not used.
**                           - eSetValueWithOverwrite: 	The notification
**                           value of the subject task is
**                           unconditionally set to ulValue. In this way
**                           the RTOS task notification mechanism is
**                           being used as a light weight alternative to
**                           xQueueOverwrite().
**                           - eSetValueWithoutOverwrite: 	If the
**                           subject task does not already have a
**                           notification pending then its notification
**                           value will be set to ulValue. If the
**                           subject task already has a notification
**                           pending then its notification value is not
**                           updated as to do so would overwrite the
**                           previous value before it was used. In this
**                           case the call to xTaskNotify() fails and
**                           pdFALSE is returned. In this way the RTOS
**                           task notification mechanism is being used
**                           as a light weight alternative to
**                           xQueueSend() on a queue of length 1. 
**       * pxHigherPriorityTaskWoken 
**                           - *pxHigherPriorityTaskWoken must be
**                           initialised to 0.
**                           xTaskNotifyFromISR() will set
**                           *pxHigherPriorityTaskWoken to pdTRUE if
**                           sending the notification caused a task to
**                           unblock, and the unblocked task has a
**                           priority higher than the currently running
**                           task.
**                           If xTaskNotifyFromISR() sets this value to
**                           pdTRUE then a context switch should be
**                           requested before the interrupt is exited.
**                           See the example below.
**                           pxHigherPriorityTaskWoken is an optional
**                           parameter and can be set to NULL. 
**     Returns     :
**         ---             - pdPASS is returned in all cases other than
**                           when eAction is set to
**                           eSetValueWithoutOverwrite and the subject
**                           task's notification value cannot be updated
**                           because the subject task already had a
**                           notification pending. 
** ===================================================================
*/
/*
BaseType_t McuRTOS_xTaskNotifyFromISR(TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xTaskNotifyWait (component FreeRTOS)
**
**     Description :
**          [If you are using RTOS task notifications to implement
**         binary or counting semaphore type behaviour then use the
**         simpler ulTaskNotifyTake() API function instead of
**         xTaskNotifyWait()]
**         Each RTOS task has a 32-bit notification value which is
**         initialised to zero when the RTOS task is created. An RTOS
**         task notification is an event sent directly to a task that
**         can unblock the receiving task, and optionally update the
**         receiving task's notification value in a number of different
**         ways. For example, a notification may overwrite the
**         receiving task's notification value, or just set one or more
**         bits in the receiving task's notification value. See the
**         RTOS task notifications use case documentation for examples.
**         xTaskNotifyWait() waits, with an optional timeout, for the
**         calling task to receive a notification.
**         If the receiving RTOS task was already Blocked waiting for a
**         notification when one arrives the receiving RTOS task will
**         be removed from the Blocked state and the notification
**         cleared. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         ulBitsToClearOnEntry - Any bits
**                           set in ulBitsToClearOnEntry will be cleared
**                           in the calling RTOS task's notification
**                           value on entry to the xTaskNotifyWait()
**                           function (before the task waits for a new
**                           notification) provided a notification is
**                           not already pending when xTaskNotifyWait()
**                           is called.
**                           For example, if ulBitsToClearOnEntry is
**                           0x01, then bit 0 of the task's notification
**                           value will be cleared on entry to the
**                           function.
**                           Setting ulBitsToClearOnEntry to 0xffffffff
**                           (ULONG_MAX) will clear all the bits in the
**                           task's notification value, effectively
**                           clearing the value to 0. 
**         ulBitsToClearOnExit - Any bits
**                           set in ulBitsToClearOnExit will be cleared
**                           in the calling RTOS task's notification
**                           value before xTaskNotifyWait() function
**                           exits if a notification was received.
**                           The bits are cleared after the RTOS task's
**                           notification value has been saved in
**                           *pulNotificationValue (see the description
**                           of pulNotificationValue below).
**                           For example, if ulBitsToClearOnExit is 0x03,
**                           then bit 0 and bit 1 of the task's
**                           notification value will be cleared before
**                           the function exits.
**                           Setting ulBitsToClearOnExit to 0xffffffff
**                           (ULONG_MAX) will clear all the bits in the
**                           task's notification value, effectively
**                           clearing the value to 0. 
**       * pulNotificationValue - Used to
**                           pass out the RTOS task's notification value.
**                           The value copied to *pulNotificationValue
**                           is the RTOS task's notification value as it
**                           was before any bits were cleared due to the
**                           ulBitsToClearOnExit setting.
**                           If the notification value is not required
**                           then set pulNotificationValue to NULL. 
**         xTicksToWait    - The maximum time to wait
**                           in the Blocked state for a notification to
**                           be received if a notification is not
**                           already pending when xTaskNotifyWait() is
**                           called.
**                           The RTOS task does not consume any CPU time
**                           when it is in the Blocked state.
**                           The time is specified in RTOS tick periods.
**                           The pdMS_TO_TICKS() macro can be used to
**                           convert a time specified in milliseconds
**                           into a time specified in ticks. 
**     Returns     :
**         ---             - pdTRUE if a notification was received, or
**                           a notification was already pending when
**                           xTaskNotifyWait() was called.
**                           pdFALSE if the call to xTaskNotifyWait()
**                           timed out before a notification was
**                           received. 
** ===================================================================
*/
/*
BaseType_t McuRTOS_xTaskNotifyWait(uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  vTaskSetThreadLocalStoragePointer (component FreeRTOS)
**
**     Description :
**         Only enabled if configNUM_THREAD_LOCAL_STORAGE_POINTERS is >
**         0.
**     Parameters  :
**         NAME            - DESCRIPTION
**         xTaskToSet      - Task handle
**         xIndex          - Index of thread local storage item
**         pvValue         - 
**     Returns     : Nothing
** ===================================================================
*/
/*
void McuRTOS_vTaskSetThreadLocalStoragePointer(TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  pvTaskGetThreadLocalStoragePointer (component FreeRTOS)
**
**     Description :
**         Sets the thread local storage. Only enabled if
**         configNUM_THREAD_LOCAL_STORAGE_POINTERS is >0
**     Parameters  :
**         NAME            - DESCRIPTION
**         xTaskToQuery    - Task handle from which
**                           to get the local thread storage.
**         xIndex          - Index of thread storage
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
/*
void* McuRTOS_pvTaskGetThreadLocalStoragePointer(TaskHandle_t xTaskToQuery, BaseType_t xIndex)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xSemaphoreCreateBinary (component FreeRTOS)
**
**     Description :
**         The old vSemaphoreCreateBinary() macro is now deprecated in
**         favour of this xSemaphoreCreateBinary() function.  Note that
**         binary semaphores created using the vSemaphoreCreateBinary()
**         macro are created in a state such that the first call to
**         'take' the semaphore would pass, whereas binary semaphores
**         created using xSemaphoreCreateBinary() are created in a
**         state such that the the semaphore must first be 'given'
**         before it can be 'taken'.
**         Function that creates a semaphore by using the existing
**         queue mechanism. The queue length is 1 as this is a binary
**         semaphore.  The data size is 0 as nothing is actually stored
**         - all that is important is whether the queue is empty or
**         full (the binary semaphore is available or not).
**         This type of semaphore can be used for pure synchronisation
**         between tasks or between an interrupt and a task.  The
**         semaphore need not be given back once obtained, so one
**         task/interrupt can continuously 'give' the semaphore while
**         another continuously 'takes' the semaphore.  For this reason
**         this type of semaphore does not use a priority inheritance
**         mechanism.  For an alternative that does use priority
**         inheritance see xSemaphoreCreateMutex().
**     Parameters  : None
**     Returns     :
**         ---             - Handle to the created semaphore.
** ===================================================================
*/
/*
SemaphoreHandle_t McuRTOS_xSemaphoreCreateBinary(void)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xTaskNotifyAndQuery (component FreeRTOS)
**
**     Description :
**          [If you are using RTOS task notifications to implement
**         binary or counting semaphore type behaviour then use the
**         simpler xTaskNotifyGive() API function instead of
**         xTaskNotify()]
**         Each RTOS task has a 32-bit notification value which is
**         initialised to zero when the RTOS task is created.
**         xTaskNotify() is used to send an event directly to and
**         potentially unblock an RTOS task, and optionally update the
**         receiving task's notification value in one of the following
**         ways:
**         - Write a 32-bit number to the notification value
**         - Add one (increment) the notification value
**         - Set one or more bits in the notification value
**         - Leave the notification value unchanged
**         This function must not be called from an interrupt service
**         routine (ISR). Use xTaskNotifyFromISR() instead. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xTaskToNotify   - The handle of the RTOS
**                           task being notified. This is the subject
**                           task.
**                           RTOS task handles are obtained using the
**                           pvCreatedTask parameter of the xTaskCreate()
**                           call used to create the task.
**                           The handle of the currently executing RTOS
**                           task is returned by the
**                           xTaskGetCurrentTaskHandle() API function. 
**         ulValue         - Used to update the notification
**                           value of the subject task. See the
**                           description of the eAction parameter below. 
**         eAction         - An enumerated type that can take
**                           one of the values documented in the table
**                           below in order to perform the associated
**                           action. 
**       * pulPreviousNotifyValue - Can
**                           be used to pass out the subject task's
**                           notification value before any bits are
**                           modified by the action of
**                           xTaskNotifyAndQuery().
**                           pulPreviousNotifyValue is an optional
**                           parameter, and can be set to NULL if it is
**                           not required. If pulPreviousNotifyValue is
**                           not used then consider using xTaskNotify()
**                           in place of xTaskNotifyAndQuery(). 
**     Returns     :
**         ---             - pdPASS is returned in all cases other than
**                           when eAction is set to
**                           eSetValueWithoutOverwrite and the subject
**                           task's notification value cannot be updated
**                           because the subject task already had a
**                           notification pending. 
** ===================================================================
*/
/*
BaseType_t McuRTOS_xTaskNotifyAndQuery(TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotifyValue)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xTaskNotifyAndQueryFromISR (component FreeRTOS)
**
**     Description :
**          [If you are using RTOS task notifications to implement
**         binary or counting semaphore type behaviour then use the
**         simpler xTaskNotifyGive() API function instead of
**         xTaskNotify()]
**         Each RTOS task has a 32-bit notification value which is
**         initialised to zero when the RTOS task is created.
**         xTaskNotify() is used to send an event directly to and
**         potentially unblock an RTOS task, and optionally update the
**         receiving task's notification value in one of the following
**         ways:
**         - Write a 32-bit number to the notification value
**         - Add one (increment) the notification value
**         - Set one or more bits in the notification value
**         - Leave the notification value unchanged
**         This function must not be called from an interrupt service
**         routine (ISR). Use xTaskNotifyFromISR() instead. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xTaskToNotify   - The handle of the RTOS
**                           task being notified. This is the subject
**                           task.
**                           RTOS task handles are obtained using the
**                           pvCreatedTask parameter of the xTaskCreate()
**                           call used to create the task.
**                           The handle of the currently executing RTOS
**                           task is returned by the
**                           xTaskGetCurrentTaskHandle() API function. 
**         ulValue         - Used to update the notification
**                           value of the subject task. See the
**                           description of the eAction parameter below. 
**         eAction         - An enumerated type that can take
**                           one of the values documented in the table
**                           below in order to perform the associated
**                           action. 
**       * pulPreviousNotifyValue - Can
**                           be used to pass out the subject task's
**                           notification value before any bits are
**                           modified by the action of
**                           xTaskNotifyAndQuery().
**                           pulPreviousNotifyValue is an optional
**                           parameter, and can be set to NULL if it is
**                           not required. If pulPreviousNotifyValue is
**                           not used then consider using xTaskNotify()
**                           in place of xTaskNotifyAndQuery(). 
**       * pxHigherPriorityTaskWoken 
**                           - *pxHigherPriorityTaskWoken must be
**                           initialised to 0.
**                           xTaskNotifyFromISR() will set
**                           *pxHigherPriorityTaskWoken to pdTRUE if
**                           sending the notification caused a task to
**                           unblock, and the unblocked task has a
**                           priority higher than the currently running
**                           task.
**                           If xTaskNotifyFromISR() sets this value to
**                           pdTRUE then a context switch should be
**                           requested before the interrupt is exited.
**                           See the example below.
**                           pxHigherPriorityTaskWoken is an optional
**                           parameter and can be set to NULL. 
**     Returns     :
**         ---             - pdPASS is returned in all cases other than
**                           when eAction is set to
**                           eSetValueWithoutOverwrite and the subject
**                           task's notification value cannot be updated
**                           because the subject task already had a
**                           notification pending. 
** ===================================================================
*/
/*
BaseType_t McuRTOS_xTaskNotifyAndQueryFromISR(TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotifyValue, BaseType_t *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xTaskNotifyStateClear (component FreeRTOS)
**
**     Description :
**          [If you are using RTOS task notifications to implement
**         binary or counting semaphore type behaviour then use the
**         simpler xTaskNotifyGive() API function instead of
**         xTaskNotify()]
**         If the notification state of the task referenced by the
**         handle xTask is eNotified, then set the task's notification
**         state to eNotWaitingNotification. The task's notification
**         value is not altered.  Set xTask to NULL to clear the
**         notification state of the calling task.
**     Parameters  :
**         NAME            - DESCRIPTION
**         xTask           - The handle of the RTOS task. Use NULL
**                           for using the calling task.
**     Returns     :
**         ---             - pdPASS is returned in all cases other than
**                           when eAction is set to
**                           eSetValueWithoutOverwrite and the subject
**                           task's notification value cannot be updated
**                           because the subject task already had a
**                           notification pending. 
** ===================================================================
*/
/*
BaseType_t McuRTOS_xTaskNotifyStateClear(TaskHandle_t xTask)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  Deinit (component FreeRTOS)
**
**     Description :
**         Module deinitialization method
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void McuRTOS_Deinit(void)
{
  /* nothing needed */
}

/*
** ===================================================================
**     Method      :  xTaskGetHandle (component FreeRTOS)
**
**     Description :
**         Looks up the handle of a task from the task's name. 
**     Parameters  :
**         NAME            - DESCRIPTION
**       * pcNameToQuery   - The text name (as a
**                           standard C NULL terminated string) of the
**                           task for which the handle will be returned.
**     Returns     :
**         ---             - If a task that has the name passed in
**                           pcNameToQuery can be located then the
**                           handle of the task is returned, otherwise
**                           NULL is returned. 
** ===================================================================
*/
/*
TaskHandle_t McuRTOS_xTaskGetHandle(const char *pcNameToQuery )
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  pcTaskGetName (component FreeRTOS)
**
**     Description :
**         Looks up the name of a task from the task's handle. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xTaskToQuery    - The handle of the task
**                           being queried. xTaskToQuery can be set to
**                           NULL to query the name of the calling task.
**     Returns     :
**         ---             - A pointer to the subject task's name,
**                           which is a standard NULL terminated C
**                           string.
** ===================================================================
*/
/*
char* McuRTOS_pcTaskGetName(TaskHandle_t xTaskToQuery)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xTaskCreateStatic (component FreeRTOS)
**
**     Description :
**         Create a new task and add it to the list of tasks that are
**         ready to run.
**     Parameters  :
**         NAME            - DESCRIPTION
**         pvTaskCode      - Pointer to the task entry
**                           function. Tasks must be implemented to
**                           never return (i.e. continuous loop).
**         pcName          - A descriptive name for the task.
**                           This is mainly used to facilitate debugging.
**                           Max length defined by
**                           configMAX_TASK_NAME_LEN.
**         usStackDepth    - The size of the task
**                           stack specified as the number of variables
**                           the stack can hold - not the number of
**                           bytes. For example, if the stack is 16 bits
**                           wide and usStackDepth is defined as 100,
**                           200 bytes will be allocated for stack
**                           storage. The stack depth multiplied by the
**                           stack width must not exceed the maximum
**                           value that can be contained in a variable
**                           of type size_t.
**         pvParameters    - Pointer that will be
**                           used as the parameter for the task being
**                           created.
**         uxPriority      - The priority at which the
**                           task should run.
**         puxStackBuffer  - Must point to a
**                           StackType_t array that has at least
**                           ulStackDepth indexes (see the ulStackDepth
**                           parameter above) - the array will be used
**                           as the task's stack, so must be persistent
**                           (not declared on the stack of a function)
**         pxTaskBuffer    - Must point to a variable
**                           of type StaticTask_t. The variable will be
**                           used to hold the new task's data structures
**                           (TCB), so it must be persistent (not
**                           declared on the stack of a function). 
**     Returns     :
**         ---             - Task handle if the task was successfully
**                           created and added to a ready list,
**                           otherwise Null.
** ===================================================================
*/
/*
TaskHandle_t McuRTOS_xTaskCreateStatic(pdTASK_CODE pvTaskCode, const portCHAR * const pcName, unsigned portSHORT usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, StackType_t * const puxStackBuffer, StaticTask_t * const pxTaskBuffer)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xQueueCreateStatic (component FreeRTOS)
**
**     Description :
**         Creates a queue.
**     Parameters  :
**         NAME            - DESCRIPTION
**         uxQueueLength   - The maximum number of
**                           items the queue can hold at any time.
**         uxItemSize      - The size in bytes of each
**                           item the queue will hold.
**         pucQueueStorageBuffer - If
**                           uxItemSize is not zero then
**                           pucQueueStorageBuffer must point to a
**                           uint8_t array that is at least large enough
**                           to hold the maximum number of items that
**                           can be in the queue at any one time - which
**                           is ( uxQueueLength * uxItemSize ) bytes. If
**                           uxItemSize is zero then
**                           pucQueueStorageBuffer can be NULL. 
**         pxQueueBuffer   - Must point to a
**                           variable of type StaticQueue_t, which will
**                           be used to hold the queue's data structure.
**     Returns     :
**         ---             - A handle to the created queue is returned
**                           provided the queue was created successfully.
**                           NULL is returned if the queue cannot be
**                           created because there is too little heap
**                           RAM available.
** ===================================================================
*/
/*
xQueueHandle McuRTOS_xQueueCreateStatic(unsigned_portBASE_TYPE uxQueueLength, unsigned_portBASE_TYPE uxItemSize, uint8_t *pucQueueStorageBuffer, StaticQueue_t *pxQueueBuffer)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xEventGroupCreateStatic (component FreeRTOS)
**
**     Description :
**          Create a new RTOS event group. This function cannot be
**         called from an interrupt.
**         Event groups are stored in variables of type
**         EventGroupHandle_t. The number of bits (or flags)
**         implemented within an event group is 8 if
**         configUSE_16_BIT_TICKS is set to 1, or 24 if
**         configUSE_16_BIT_TICKS is set to 0. The dependency on
**         configUSE_16_BIT_TICKS results from the data type used for
**         thread local storage in the internal implementation of RTOS
**         tasks. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         pxEventGroupBuffer - Must point
**                           to a variable of type StaticEventGroup_t,
**                           in which the event group data structure
**                           will be stored.
**     Returns     :
**         ---             - Event Group Handle. If the event group was
**                           created then a handle to the event group is
**                           returned. If there was insufficient
**                           FreeRTOS heap available to create the event
**                           group then NULL is returned. 
** ===================================================================
*/
/*
EventGroupHandle_t McuRTOS_xEventGroupCreateStatic(StaticEventGroup_t *pxEventGroupBuffer)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xTimerCreateStatic (component FreeRTOS)
**
**     Description :
**          Creates a new software timer instance. This allocates the
**         storage required by the new timer, initialises the new
**         timers internal state, and returns a handle by which the new
**         timer can be referenced.
**     Parameters  :
**         NAME            - DESCRIPTION
**         pcTimerName     -
**                           Atextnamethatisassignedtothetimer_Thisisdone
**                           purelytoassistdebugging_TheRTOSkernelitselfo
**                           nlyeverreferencesatimerbyitshandle_andneverb
**                           yitsname_
**         xTimerPeriod    - The timer period. The
**                           time is defined in tick periods so the
**                           constant portTICK_PERIOD_MS can be used to
**                           convert a time that has been specified in
**                           milliseconds. For example, if the timer
**                           must expire after 100 ticks, then
**                           xTimerPeriod should be set to 100.
**                           Alternatively, if the timer must expire
**                           after 500ms, then xPeriod can be set to (
**                           500 / portTICK_PERIOD_MS ) provided
**                           configTICK_RATE_HZ is less than or equal to
**                           1000. 
**         uxAutoReload    - If uxAutoReload is set
**                           to pdTRUE, then the timer will expire
**                           repeatedly with a frequency set by the
**                           xTimerPeriod parameter. If uxAutoReload is
**                           set to pdFALSE, then the timer will be a
**                           one-shot and enter the dormant state after
**                           it expires. 
**         pvTimerID       - An identifier that is assigned
**                           to the timer being created. Typically this
**                           would be used in the timer callback
**                           function to identify which timer expired
**                           when the same callback function is assigned
**                           to more than one timer. 
**         pxCallbackFunction - The function
**                           to call when the timer expires. Callback
**                           functions must have the prototype defined
**                           by TimerCallbackFunction_t, which is "void
**                           vCallbackFunction( TimerHandle_t xTimer );".
**         pxTimerBuffer   - Must point to a
**                           variable of type StaticTimer_t, which is
**                           then used to hold the timer's state. 
**     Returns     :
**         ---             - Timer handle. If the timer is successfully
**                           created then a handle to the newly created
**                           timer is returned. If the timer cannot be
**                           created (because either there is
**                           insufficient FreeRTOS heap remaining to
**                           allocate the timer structures, or the timer
**                           period was set to 0) then NULL is returned. 
** ===================================================================
*/
/*
TimerHandle_t McuRTOS_xTimerCreateStatic(const char * const pcTimerName, const TickType_t xTimerPeriod, const UBaseType_t uxAutoReload, void *const pvTimerID, TimerCallbackFunction_t pxCallbackFunction, StaticTimer_t *pxTimerBuffer)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xSemaphoreCreateBinaryStatic (component FreeRTOS)
**
**     Description :
**         The old vSemaphoreCreateBinary() macro is now deprecated in
**         favour of this xSemaphoreCreateBinary() function.  Note that
**         binary semaphores created using the vSemaphoreCreateBinary()
**         macro are created in a state such that the first call to
**         'take' the semaphore would pass, whereas binary semaphores
**         created using xSemaphoreCreateBinary() are created in a
**         state such that the the semaphore must first be 'given'
**         before it can be 'taken'.
**         Function that creates a semaphore by using the existing
**         queue mechanism. The queue length is 1 as this is a binary
**         semaphore.  The data size is 0 as nothing is actually stored
**         - all that is important is whether the queue is empty or
**         full (the binary semaphore is available or not).
**         This type of semaphore can be used for pure synchronisation
**         between tasks or between an interrupt and a task.  The
**         semaphore need not be given back once obtained, so one
**         task/interrupt can continuously 'give' the semaphore while
**         another continuously 'takes' the semaphore.  For this reason
**         this type of semaphore does not use a priority inheritance
**         mechanism.  For an alternative that does use priority
**         inheritance see xSemaphoreCreateMutex().
**     Parameters  :
**         NAME            - DESCRIPTION
**         pxSemaphoreBuffer - Must point to
**                           a variable of type StaticSemaphore_t, which
**                           will be used to hold the semaphore's state.
**     Returns     :
**         ---             - Handle to the created semaphore.
** ===================================================================
*/
/*
SemaphoreHandle_t McuRTOS_xSemaphoreCreateBinaryStatic(StaticSemaphore_t *pxSemaphoreBuffer)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xSemaphoreCreateCountingStatic (component FreeRTOS)
**
**     Description :
**         Macro that creates a counting semaphore by using the
**         existing queue mechanism.
**         Counting semaphores are typically used for two things:
**         1. Counting events.
**         In this usage scenario an event handler will 'give' a
**         semaphore each time an event occurs (incrementing the
**         semaphore count value), and a handler task will 'take' a
**         semaphore each time it processes an event (decrementing the
**         semaphore count value). The count value is therefore the
**         difference between the number of events that have occurred
**         and the number that have been processed. In this case it is
**         desirable for the initial count value to be zero.
**         2. Resource management.
**         In this usage scenario the count value indicates the number
**         of resources available. To obtain control of a resource a
**         task must first obtain a semaphore - decrementing the
**         semaphore count value. When the count value reaches zero
**         there are no free resources. When a task finishes with the
**         resource it 'gives' the semaphore back - incrementing the
**         semaphore count value. In this case it is desirable for the
**         initial count value to be equal to the maximum count value,
**         indicating that all resources are free.
**     Parameters  :
**         NAME            - DESCRIPTION
**         uxMaxCount      - The maximum count value that
**                           can be reached. When the semaphore reaches
**                           this value it can no longer be 'given'.
**         uxInitialCount  - The count value
**                           assigned to the semaphore when it is
**                           created.
**         pxSempahoreBuffer - Must point to
**                           a variable of type StaticSemaphore_t, which
**                           is then used to hold the semaphore's data
**                           structures.
**     Returns     :
**         ---             - xSemaphoreHandle handle
** ===================================================================
*/
/*
xSemaphoreHandle McuRTOS_xSemaphoreCreateCountingStatic(unsigned_portBASE_TYPE uxMaxCount, unsigned_portBASE_TYPE uxInitialCount, StaticSemaphore_t pxSempahoreBuffer)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xSemaphoreCreateMutexStatic (component FreeRTOS)
**
**     Description :
**         Macro that creates a mutex semaphore by using the existing
**         queue mechanism.
**         Mutexes created using this macro can be accessed using the
**         xSemaphoreTake() and xSemaphoreGive() macros. The
**         xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive()
**         macros should not be used.
**         Mutexes and binary semaphores are very similar but have some
**         subtle differences: Mutexes include a priority inheritance
**         mechanism, binary semaphores do not. This makes binary
**         semaphores the better choice for implementing
**         synchronisation (between tasks or between tasks and an
**         interrupt), and mutexes the better choice for implementing
**         simple mutual exclusion.
**         The priority of a task that 'takes' a mutex can potentially
**         be raised if another task of higher priority attempts to
**         obtain the same mutex. The task that owns the mutex
**         'inherits' the priority of the task attempting to 'take' the
**         same mutex. This means the mutex must always be 'given' back
**         - otherwise the higher priority task will never be able to
**         obtain the mutex, and the lower priority task will never
**         'disinherit' the priority. An example of a mutex being used
**         to implement mutual exclusion is provided on the
**         xSemaphoreTake() documentation page.
**         A binary semaphore need not be given back once obtained, so
**         task synchronisation can be implemented by one
**         task/interrupt continuously 'giving' the semaphore while
**         another continuously 'takes' the semaphore. This is
**         demonstrated by the sample code on the
**         xSemaphoreGiveFromISR() documentation page.
**         Both mutex and binary semaphores are assigned to variables
**         of type xSemaphoreHandle and can be used in any API function
**         that takes a parameter of this type. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         Variable_1      - Must point to a variable of
**                           type StaticSemaphore_t, which will be used
**                           to hold the mutex type semaphore's state. 
**     Returns     :
**         ---             - Handle to the created mutex semaphore.
**                           Should be of type  xSemaphoreHandle.
** ===================================================================
*/
/*
xSemaphoreHandle McuRTOS_xSemaphoreCreateMutexStatic(StaticSemaphore_t *pxMutexBuffer)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xTaskAbortDelay (component FreeRTOS)
**
**     Description :
**         Forces a task to leave the Blocked state, and enter the
**         Ready state, even if the event the task was in the Blocked
**         state to wait for has not occurred, and any specified
**         timeout has not expired. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xTask           - The handle of the task that will be
**                           forced out of the Blocked state. 
**     Returns     :
**         ---             - If the task referenced by xTask was not in
**                           the Blocked state then pdFAIL is returned.
**                           Otherwise pdPASS is returned. 
** ===================================================================
*/
/*
BaseType_t McuRTOS_xTaskAbortDelay(TaskHandle_t xTask)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  vTaskGetInfo (component FreeRTOS)
**
**     Description :
**         Whereas uxTaskGetSystemState() populates a TaskStatus_t
**         structure for each task in the system, vTaskGetInfo()
**         populates a TaskStatus_t structures for just a single task.
**         The TaskStatus_t structure contains, among other things,
**         members for the task handle, task name, task priority, task
**         state, and total amount of run time consumed by the task. 
**     Parameters  :
**         NAME            - DESCRIPTION
**         xTask           - The handle of the task being queried.
**                           Setting xTask to NULL will return
**                           information on the calling task. 
**         pxTaskStatus    - The TaskStatus_t
**                           structure pointed to by pxTaskStatus will
**                           be filled with information about the task
**                           referenced by the handle passed in the
**                           xTask parameter. 
**         xGetFreeStackSpace - The
**                           TaskStatus_t structure contains a member to
**                           report the stack high water mark of the
**                           task being queried. The stack high water
**                           mark is the minimum amount of stack space
**                           that has ever existed, so the closer the
**                           number is to zero the closer the task has
**                           come to overflowing its stack.Calculating
**                           the stack high water mark takes a
**                           relatively long time, and can make the
**                           system temporarily unresponsive - so the
**                           xGetFreeStackSpace parameter is provided to
**                           allow the high water mark checking to be
**                           skipped. The high watermark value will only
**                           be written to the TaskStatus_t structure if
**                           xGetFreeStackSpace is not set to pdFALSE. 
**         eState          - The TaskStatus_t structure contains
**                           a member to report the state of the task
**                           being queried. Obtaining the task state is
**                           not as fast as a simple assignment - so the
**                           eState parameter is provided to allow the
**                           state information to be omitted from the
**                           TaskStatus_t structure. To obtain state
**                           information then set eState to eInvalid -
**                           otherwise the value passed in eState will
**                           be reported as the task state in the
**                           TaskStatus_t structure. 
**     Returns     : Nothing
** ===================================================================
*/
/*
void McuRTOS_vTaskGetInfo(TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  uxSemaphoreGetCount (component FreeRTOS)
**
**     Description :
**         
**     Parameters  :
**         NAME            - DESCRIPTION
**         xSemaphore      - The handle of the semaphore
**                           being queried. 
**     Returns     :
**         ---             - If the semaphore is a counting semaphore
**                           then the semaphores current count value is
**                           returned. If the semaphore is a binary
**                           semaphore then 1 is returned if the
**                           semaphore is available, and 0 is returned
**                           if the semaphore is not available. 
** ===================================================================
*/
/*
UBaseType_t McuRTOS_uxSemaphoreGetCount(SemaphoreHandle_t xSemaphore)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  xSemaphoreCreateRecursiveMutexStatic (component FreeRTOS)
**
**     Description :
**         Macro that implements a recursive mutex by using the
**         existing queue mechanism.
**         Mutexes created using this macro can be accessed using the
**         xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive()
**         macros.  The  xSemaphoreTake() and xSemaphoreGive() macros
**         should not be used.
**         A mutex used recursively can be 'taken' repeatedly by the
**         owner. The mutex doesn't become available again until the
**         owner has called xSemaphoreGiveRecursive() for each
**         successful 'take' request.  For example, if a task
**         successfully 'takes' the same mutex 5 times then the mutex
**         will not be available to any other task until it has also
**         'given' the mutex back exactly five times.
**         This type of semaphore uses a priority inheritance mechanism
**         so a task 'taking' a semaphore MUST ALWAYS 'give' the
**         semaphore back once the semaphore it is no longer required.
**         Mutex type semaphores cannot be used from within interrupt
**         service routines.
**         See vSemaphoreCreateBinary() for an alternative
**         implementation that can be used for pure synchronisation
**         (where one task or interrupt always 'gives' the semaphore
**         and another always 'takes' the semaphore) and from within
**         interrupt service routines.
**     Parameters  :
**         NAME            - DESCRIPTION
**         Variable_1      - Must point to a variable of
**                           type StaticSemaphore_t, which will be used
**                           to hold the mutex type semaphore's state. 
**     Returns     :
**         ---             - Handle to the created mutex semaphore.
**                           Should be of type  xSemaphoreHandle.
** ===================================================================
*/
/*
xSemaphoreHandle McuRTOS_xSemaphoreCreateRecursiveMutexStatic(StaticSemaphore_t *pxMutexBuffer)
{
  *** Implemented as macro in the header file McuRTOS.h
}
*/

/*
** ===================================================================
**     Method      :  AppConfigureTimerForRuntimeStats (component FreeRTOS)
**
**     Description :
**         Configures the timer for generating runtime statistics
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
#if configGENERATE_RUN_TIME_STATS
void McuRTOS_AppConfigureTimerForRuntimeStats(void)
{
#if configGENERATE_RUN_TIME_STATS_USE_TICKS
  /* nothing needed, the RTOS will initialize the tick counter */
#else
  extern uint32_t McuRTOS_RunTimeCounter; /* runtime counter, used for configGENERATE_RUNTIME_STATS */
  McuRTOS_RunTimeCounter = 0;
#endif
}

#endif /* configGENERATE_RUN_TIME_STATS */
/*
** ===================================================================
**     Method      :  AppGetRuntimeCounterValueFromISR (component FreeRTOS)
**
**     Description :
**         returns the current runtime counter. Function can be called
**         from an interrupt service routine.
**     Parameters  : None
**     Returns     :
**         ---             - runtime counter value
** ===================================================================
*/
uint32_t McuRTOS_AppGetRuntimeCounterValueFromISR(void)
{
#if configGENERATE_RUN_TIME_STATS
  #if configGENERATE_RUN_TIME_STATS_USE_TICKS
  return xTaskGetTickCountFromISR(); /* using RTOS tick counter */
  #else /* using timer counter */
  extern uint32_t McuRTOS_RunTimeCounter; /* runtime counter, used for configGENERATE_RUNTIME_STATS */
  return McuRTOS_RunTimeCounter;
  #endif
#else
  return 0; /* dummy value */
#endif
}

#endif /* McuLib_CONFIG_SDK_USE_FREERTOS */
/* END McuRTOS. */

/*!
** @}
*/
