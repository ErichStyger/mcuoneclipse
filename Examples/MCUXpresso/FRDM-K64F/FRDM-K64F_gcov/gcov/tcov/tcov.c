#include <stdio.h>
#include <stdint.h>
#include "tcov.h"
#include "gcov_support.h"

#if GCOV_USE_TCOV

#if __GNUC__ == 5 && __GNUC_MINOR__ >= 1
#define GCOV_COUNTERS                   10
#elif __GNUC__ == 4 && __GNUC_MINOR__ >= 9
#define GCOV_COUNTERS                   9
#else
#define GCOV_COUNTERS                   8
#endif

#if BITS_PER_LONG >= 64
typedef long gcov_type;
#else
typedef long long gcov_type;
#endif

struct gcov_info;

/// \brief Information about counters for a single function
///
/// This data is generated by gcc during compilation and doesn't change
/// at run-time with the exception of the values array.
struct gcov_ctr_info {
  /// \brief number of counter values for this type
  unsigned int num;

  /// \brief array of counter values for this type
  gcov_type *values;
};

/// \brief Profiling meta data per function
///
/// This data is generated by gcc during compilation and doesn't change
/// at run-time.
///
/// Information about a single function.  This uses the trailing array
/// idiom. The number of counters is determined from the merge pointer
/// array in gcov_info.  The key is used to detect which of a set of
/// comdat functions was selected -- it points to the gcov_info object
/// of the object file containing the selected comdat function.
struct gcov_fn_info {
  /// \brief comdat key
  const struct gcov_info *key;

  /// \brief unique ident of function
  unsigned int ident;

  /// \brief function lineo_checksum
  unsigned int lineno_checksum;

  /// \brief function cfg checksum
  unsigned int cfg_checksum;

  /// \brief instrumented counters
  struct gcov_ctr_info ctrs[0];
};

/// Profiling data per object file
///
/// This data is generated by gcc during compilation and doesn't change
/// at run-time with the exception of the next pointer.
struct gcov_info {
  /// \brief gcov version magic indicating the gcc version used for compilation
  unsigned int version;

  /// \brief list head for a singly-linked list
  struct gcov_info *next;

  /// \brief uniquifying time stamp
  unsigned int stamp;

  /// \brief name of the associated gcov data file
  const char *filename;

  /// \brief merge functions (null for unused counter type)
  void (*merge[GCOV_COUNTERS])(gcov_type *, unsigned int);

  /// \brief number of instrumented functions
  unsigned int n_functions;

  /// \brief pointer to pointers to function information
  struct gcov_fn_info **functions;
};

static uint32_t infosCnt;
static struct gcov_info *gcov_info_head;

/// \brief __gcov_init is called by gcc-generated constructor code for each object
/// file compiled with -fprofile-arcs.
void __gcov_init(struct gcov_info *info) {
  info->next = gcov_info_head;
  gcov_info_head = info;
  infosCnt++;
}

void __gcov_merge_add(gcov_type *counters, unsigned int n_counters) {
  /* Unused. */
}

static struct gcov_info * priv_get_info(uint32_t const aCU) {
  struct gcov_info *lRet = gcov_info_head;
  for(uint32_t cIdx = 0; cIdx < aCU; cIdx++) {
    lRet = lRet->next;
  }

  return lRet;
}

uint32_t tcov_get_num_cu(void) {
  return infosCnt;
}

tcov_cu_t tcov_get_cu(uint32_t const aCU) {
  tcov_cu_t lRet = {0};

  if(aCU >= infosCnt) {
    return lRet;
  }

  struct gcov_info *lInfo = priv_get_info(aCU);

  lRet.stamp = lInfo->stamp;
  lRet.fnCount = lInfo->n_functions;

  return lRet;
}

tcov_fn_t tcov_get_fn(uint32_t const aCU, uint32_t const aFn) {
  tcov_fn_t lRet = {0};
  if(aCU >= infosCnt) {
    return lRet;
  }

  struct gcov_info *lInfo = priv_get_info(aCU);

  struct gcov_fn_info *lFn = lInfo->functions[aFn];

  lRet.ident = lFn->ident;
  lRet.cntrCount = lFn->ctrs[0].num;
  lRet.values = (uint64_t *) lFn->ctrs[0].values;

  return lRet;
}

void tcov_print_all(void) {
  printf("GCov info:\n");

  printf("CU#: %u\n", (unsigned int)infosCnt);

  struct gcov_info *lInfo = gcov_info_head;

  for(uint32_t cIdx = 0; cIdx < infosCnt; cIdx++) {
    printf(" Name: %s\n", lInfo->filename);
    printf(" Func#: %u\n", lInfo->n_functions);
    printf(" Stamp#: %u\n", lInfo->stamp);

    for(uint32_t cFnIdx = 0; cFnIdx < lInfo->n_functions; cFnIdx++) {
      struct gcov_fn_info *bFnInfo = lInfo->functions[cFnIdx];

      printf("  Func%u:\n", (unsigned int)cFnIdx);

      printf("   Ident: %u\n",(unsigned int) bFnInfo->ident);
      printf("   Linenum: %u\n", bFnInfo->lineno_checksum);

      for(uint32_t cCntrIdx = 0; cCntrIdx < bFnInfo->ctrs[0].num; cCntrIdx++) {
        printf("    Cntr%u: %u\n", (unsigned int)cCntrIdx, (unsigned int)(bFnInfo->ctrs[0].values[cCntrIdx]));
      }
    }

    lInfo = lInfo->next;
  }
}

#endif /* GCOV_USE_TCOV */
