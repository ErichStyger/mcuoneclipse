/* ###################################################################
**     This component module is generated by Processor Expert. Do not modify it.
**     Filename    : FATM1.c
**     Project     : ProcessorExpert
**     Processor   : MK64FN1M0VLL12
**     Component   : SD_Card
**     Version     : Component 01.182, Driver 01.00, CPU db: 3.00.000
**     Repository  : Legacy User Components
**     Compiler    : GNU C Compiler
**     Date/Time   : 2016-10-25, 10:00, # CodeGen: 176
**     Abstract    :
**         Implements interface to SD card for FatFs
**     Settings    :
**          Component name                                 : FATM1
**          Block size                                     : 512
**          Cmd wait counter                               : 10
**          Wait Ready Timeout (ms)                        : 500
**          Wait Cmd Timeout (ms)                          : 100
**          Receive Block Timeout (ms)                     : 500
**          SPI Block Transfer                             : no
**          Hardware                                       : 
**            SW SPI                                       : Disabled
**            HW SPI                                       : Enabled
**              Slow Baud Rate Mode                        : 0
**              Fast Baud Rate Mode                        : 1
**              LDD HW SPI                                 : Enabled
**                LDD HW SPI                               : SM2
**              non-LDD HW SPI                             : Disabled
**            SPI Read/Write Macros                        : Disabled
**            Slave Select                                 : Enabled
**              LDD SS                                     : Enabled
**                Slave Select Pin                         : LDDSS
**              non-LDD SS                                 : Disabled
**            Activate                                     : Disabled
**            Card detection                               : Enabled
**              Card Detect is LOW active                  : no
**              LDD CD                                     : Enabled
**                Card detection pin                       : LDDCDI
**              non-LDD CD                                 : Disabled
**            Report 'Card present' if no Card detection pin: yes
**            Write protection                             : Disabled
**          System                                         : 
**            Wait                                         : WAIT1
**            Timeout                                      : TMOUT1
**            RTOS                                         : Disabled
**     Contents    :
**         Activate         - void FATM1_Activate(void);
**         Deactivate       - void FATM1_Deactivate(void);
**         isWriteProtected - bool FATM1_isWriteProtected(void);
**         CardPresent      - bool FATM1_CardPresent(void);
**         WaitReady        - uint8_t FATM1_WaitReady(void);
**         ReceiveDataBlock - bool FATM1_ReceiveDataBlock(uint8_t *data, uint16_t nofBytes);
**         SendDataBlock    - bool FATM1_SendDataBlock(uint8_t *data, uint8_t token, uint16_t nofBytes);
**         SendCmd          - uint8_t FATM1_SendCmd(uint8_t cmd, uint32_t arg);
**         SetSlowMode      - void FATM1_SetSlowMode(void);
**         SetFastMode      - void FATM1_SetFastMode(void);
**         InitCommChannel  - void FATM1_InitCommChannel(void);
**         Deinit           - uint8_t FATM1_Deinit(void* unused);
**         Init             - uint8_t FATM1_Init(void* unused);
**
**     License   :  Open Source (LGPL)
**     Copyright : (c) Copyright Erich Styger, 2012-2016, all rights reserved.
**     Web       : www.mcuoneclipse.com
**     This an open source software implementing an SD card low level driver useful for the the ChaN FatFS, using Processor Expert.
**     This is a free software and is opened for education,  research and commercial developments under license policy of following terms:
**     * This is a free software and there is NO WARRANTY.
**     * No restriction on use. You can use, modify and redistribute it for personal, non-profit or commercial product UNDER YOUR RESPONSIBILITY.
**     * Redistributions of source code must retain the above copyright notice.
** ###################################################################*/
/*!
** @file FATM1.c
** @version 01.00
** @brief
**         Implements interface to SD card for FatFs
*/         
/*!
**  @addtogroup FATM1_module FATM1 module documentation
**  @{
*/         

/* MODULE FATM1. */

#include "FATM1.h"
#include "diskio.h"

static volatile DSTATUS Stat = STA_NOINIT; /* Disk status */
static uint8_t CardType = CT_SD1;       /* Card type flags */
static uint8_t currentSpeedMode = FATM1_ACTIVATE_MODE_NONE; /* current speed mode */

enum { /* SD card response codes */
  FATM1_OK = 0,
  FATM1_IDLE = 1
};

#define FATM1_SPI_WRITE_BLOCK_ENABLED          0
#define FATM1_SPI_WRITE_READ_BLOCK_ENABLED     0

/* different wait counters to deal with slow SD cards */
#define FATM1_TIMEOUT_READY_MS       500 /* user configured wait timeout until the device is ready */
#define FATM1_TIMEOUT_CMD_MS         100 /* user configured wait timeout for commands */
#define FATM1_TIMEOUT_READ_BLOCK_MS  500 /* user configured wait timeout for reading a data block */
#define FATM1_ENABLE_SS()   SS1_ClrVal(SS1_DeviceData) /* enable slave (low active) */
#define FATM1_DISABLE_SS()  SS1_SetVal(SS1_DeviceData) /* disable slave (low active) */
#define FATM1_DUMMY 0xff /* SPI dummy value */

/*-----------------------------------------------------------------------*/
/* Initialize a Drive                                                    */
DSTATUS FATM1_disk_initialize (
        uint8_t drv                     /* Physical drive number (0..) */
)
{
  uint8_t n, cmd, ty, ocr[4];

  (void)drv; /* not used */
  if (Stat&STA_NODISK) {
    return Stat;                        /* No card in the socket */
  }
  if (FATM1_Init(NULL) != ERR_OK) {
    return STA_NOINIT;
  }
  ty = 0;
  if (FATM1_SendCmd(FATM1_CMD0, 0) == 1) { /* Enter Idle state */
    if (FATM1_SendCmd(FATM1_CMD8, 0x1AA) == 1) { /* SDHC */
      for (n = 0; n < 4; n++) {
        ocr[n] = FATM1_ReceiveByte();   /* Get trailing return value of R7 resp */
      }
      if (ocr[2] == 0x01 && ocr[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
        while (FATM1_SendCmd(FATM1_ACMD41, 1UL << 30)) {
          /* Wait for leaving idle state (ACMD41 with HCS bit) */
        }
        if (FATM1_SendCmd(FATM1_CMD58, 0) == 0) { /* Check CCS bit in the OCR */
          for (n = 0; n < 4; n++) {
            ocr[n] = FATM1_ReceiveByte();
          }
          ty = (uint8_t)((ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2); /* SDv2 */
        }
      }
    } else {                            /* SDSC or MMC */
      if (FATM1_SendCmd(FATM1_ACMD41, 0) <= 1) {
        ty = CT_SD1; cmd = FATM1_ACMD41; /* SDv1 */
      } else {
        ty = CT_MMC; cmd = FATM1_CMD1;  /* MMCv3 */
      }
      while (FATM1_SendCmd(cmd, 0)) {
        /* Wait for leaving idle state */
      }
      if (FATM1_SendCmd(FATM1_CMD16, FATM1_BLOCK_SIZE) != 0) { /* Set R/W block length  */
        ty = 0;
      }
    }
    FATM1_SetFastMode();
  }
  CardType = ty;
  Stat &= ~STA_NOINIT;                  /* Clear STA_NOINIT */
  return Stat;
}

/*-----------------------------------------------------------------------*/
/* Return Disk Status                                                    */
DSTATUS FATM1_disk_status (
        uint8_t drv                     /* Physical drive number (0..) */
)
{
  (void)drv; /* not used */
  return Stat;
}

/*-----------------------------------------------------------------------*/
/* Read Sector(s)                                                        */
DRESULT FATM1_disk_read (
        uint8_t drv,                    /* Physical drive number (0..) */
        uint8_t *buff,                  /* Data buffer to store read data */
        uint32_t sector,                /* Sector address (LBA) */
        unsigned int count              /* Number of sectors to read (1..255) */
)
{
  (void)drv; /* not used */
  if (!count) {
    return RES_PARERR;
  }
  if (Stat & STA_NOINIT) {
    return RES_NOTRDY;
  }
  if (!(CardType & CT_BLOCK)) {
    sector *= FATM1_BLOCK_SIZE;         /* Convert to byte address if needed */
  }
  if (count == 1) {                     /* Single block read */
    if (   (FATM1_SendCmd(FATM1_CMD17, sector) == 0) /* READ_SINGLE_BLOCK */
        && FATM1_ReceiveDataBlock(buff, FATM1_BLOCK_SIZE))
    {
      count = 0;
    }
  } else {                              /* Multiple block read */
    if (FATM1_SendCmd(FATM1_CMD18, sector) == 0) { /* READ_MULTIPLE_BLOCK */
      do {
        if (!FATM1_ReceiveDataBlock(buff, FATM1_BLOCK_SIZE)) {
          break;
        }
        buff += FATM1_BLOCK_SIZE;
      } while (--count);
      (void)FATM1_SendCmd(FATM1_CMD12, 0); /* STOP_TRANSMISSION */
    }
  }
  return count ? RES_ERROR : RES_OK;
}

/*-----------------------------------------------------------------------*/
/* Write Sector(s)                                                       */
#if _READONLY == 0
DRESULT FATM1_disk_write (
        uint8_t drv,                    /* Physical drive number (0..) */
        const uint8_t *buff,            /* Data to be written */
        uint32_t sector,                /* Sector address (LBA) */
        unsigned int count              /* Number of sectors to write (1..255) */
)
{
  (void)drv; /* not used */
  if (!count) {
    return RES_PARERR;
  }
  if (Stat & STA_NOINIT) {
    return RES_NOTRDY;
  }
  if (Stat & STA_PROTECT) {
    return RES_WRPRT;
  }
  if (!(CardType & CT_BLOCK)) {
    sector *= FATM1_BLOCK_SIZE;         /* Convert to byte address if needed */
  }
  if (count == 1) {                     /* Single block write */
    if (  (FATM1_SendCmd(FATM1_CMD24, sector) == 0) /* WRITE_BLOCK */
        && FATM1_SendDataBlock((uint8_t*)buff, 0xFE, FATM1_BLOCK_SIZE))
    {
      count = 0;
    }
  } else {                              /* Multiple block write */
    if (CardType & CT_SDC) {
      (void)FATM1_SendCmd(FATM1_ACMD23, count);
    }
    if (FATM1_SendCmd(FATM1_CMD25, sector) == 0) { /* WRITE_MULTIPLE_BLOCK */
      do {
        if (!FATM1_SendDataBlock((uint8_t*)buff, 0xFC, FATM1_BLOCK_SIZE)) {
          break;
        }
        buff += FATM1_BLOCK_SIZE;
      } while (--count);
      if (!FATM1_SendDataBlock(0, 0xFD, FATM1_BLOCK_SIZE)) { /* STOP_TRAN token */
        count = 1;
      }
    }
  }
  return count ? RES_ERROR : RES_OK;
}
#endif /* _READONLY */
/*-----------------------------------------------------------------------*/
/* Miscellaneous Functions                                               */
static uint8_t chk_power(void) { return 1;}
static void power_off(void) {}
static void power_on(void) {}
/*-----------------------------------------------------------------------*/
DRESULT FATM1_disk_ioctl (
        uint8_t drv,                    /* Physical drive number (0..) */
        uint8_t ctrl,                   /* Control code */
        void *buff                      /* Buffer to send/receive control data */
)
{
  DRESULT res = RES_OK;
  uint8_t n, csd[16], *ptr = (uint8_t*)buff;
  uint16_t csize;

  (void)drv; /* not used */
  if (ctrl == CTRL_POWER) {
    switch (*ptr) {
      case 0:                           /* Sub control code == 0 (POWER_OFF) */
        if (chk_power()) {
        /*lint -save -e522 Highest operation lacks side effect */
          power_off();                  /* Power off */
        /*lint -restore */
        }
        break;
      case 1:                           /* Sub control code == 1 (POWER_ON) */
        /*lint -save -e522 Highest operation lacks side effect */
        power_on();                     /* Power on */
        /*lint -restore */
        break;
      case 2:                           /* Sub control code == 2 (POWER_GET) */
        *(ptr+1) = (uint8_t)chk_power();
        break;
      default:
        res = RES_PARERR;
    } /* switch */
  } else {
    if (Stat & STA_NOINIT) {
      return RES_NOTRDY;
    }
    switch (ctrl) {
      case CTRL_SYNC :                  /* Make sure that no pending write process. Do not remove this or written sector might not left updated. */
        if (FATM1_WaitReady() != ERR_OK) {
          res = RES_ERROR;
        }
        break;
      case MMC_GET_READ_BL_LEN:         /* get Block Length */
        if ((FATM1_SendCmd(FATM1_CMD9, 0) == 0) && FATM1_ReceiveDataBlock(csd, 16)) {
          switch((csd[5]&15)) {         /* READ_BL_LEN is either 9, 10 or 11, end the block size is 2^READ_BL_LEN */
            case 9: *(uint16_t*)ptr = 512; break;
            case 10: *(uint16_t*)ptr = 1024; break;
            case 11: *(uint16_t*)ptr = 2048; break;
            default: *(uint16_t*)ptr = 0; break; /* illegal */
          }
        }
        break;
      case MMC_GET_SDC_VERSION:         /* get CSD Version (1 byte: 1 for 1.xx or MMC, 2 for 2.0 */
        if ((FATM1_SendCmd(FATM1_CMD9, 0) == 0) && FATM1_ReceiveDataBlock(csd, 16)) {
          if ((csd[0] >> 6) == 1) {     /* SDC ver 2.00 */
            *ptr = 2;
          } else {                      /* SDC ver 1.XX or MMC*/
            *ptr = 1;
          }
        }
        break;
      case GET_SECTOR_COUNT :           /* Get number of sectors on the disk (uint32_t) */
        if ((FATM1_SendCmd(FATM1_CMD9, 0) == 0) && FATM1_ReceiveDataBlock(csd, 16)) {
          if ((csd[0] >> 6) == 1) {     /* SDC ver 2.00 */
            csize = (uint16_t)(csd[9] + ((uint16_t)csd[8] << 8) + 1);
            *(uint32_t*)buff = (uint32_t)csize << 10;
          } else {                      /* SDC ver 1.XX or MMC*/
            n = (uint8_t)((csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2);
            csize = (uint16_t)((csd[8] >> 6) + ((uint16_t)csd[7] << 2) + ((uint16_t)(csd[6] & 3) << 10) + 1);
            *(uint32_t*)buff = (uint32_t)csize << (uint8_t)(n - 9);
          }
        }
        break;
      case GET_SECTOR_SIZE :            /* Get R/W sector size (uint16_t) */
        *(uint16_t*)buff = FATM1_BLOCK_SIZE;
        break;
      case GET_BLOCK_SIZE :             /* Get erase block size in unit of sector (uint32_t) */
        if (CardType & CT_SD2) {        /* SDC ver 2.00 */
          if (FATM1_SendCmd(FATM1_ACMD13, 0) == 0) { /* Read SD status */
            (void)FATM1_ReceiveByte();
            if (FATM1_ReceiveDataBlock(csd, 16)) { /* Read partial block */
              for (n = 64 - 16; n; n--) {
                (void)FATM1_ReceiveByte(); /* Purge trailing data */
              }
              *(uint32_t*)buff = 16UL << (csd[10] >> 4);
            }
          }
        } else {                        /* SDC ver 1.XX or MMC */
          if ((FATM1_SendCmd(FATM1_CMD9, 0) == 0) && FATM1_ReceiveDataBlock(csd, 16)) {        /* Read CSD */
            if (CardType & CT_SD1) {    /* SDC ver 1.XX */
              *(uint32_t*)buff = (uint32_t)((((csd[10] & 63) << 1) + ((uint16_t)(csd[11] & 128) >> 7) + 1) << (uint8_t)((csd[13] >> 6) - 1));
            } else {                    /* MMC */
              *(uint32_t*)buff = (uint32_t)(((uint16_t)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1));
            }
          }
        }
        break;
      case MMC_GET_TYPE :               /* Get card type flags (1 byte) */
        *ptr = CardType;
        break;

      case MMC_GET_CSD :                /* Receive CSD as a data block (16 bytes) */
         if (!(FATM1_SendCmd(FATM1_CMD9, 0) == 0 /* READ_CSD */
            && FATM1_ReceiveDataBlock(ptr, 16)))
         {
           res = RES_PARERR;
         }
         break;
      case MMC_GET_CID :                /* Receive CID as a data block (16 bytes) */
        if (!(FATM1_SendCmd(FATM1_CMD10, 0) == 0 /* READ_CID */
            && FATM1_ReceiveDataBlock(ptr, 16)))
        {
          res = RES_PARERR;
        }
        break;

      case MMC_GET_OCR :                /* Receive OCR as an R3 resp (4 bytes) */
        if (FATM1_SendCmd(FATM1_CMD58, 0) == 0) { /* READ_OCR */
          for (n = 4; n; n--) {
            *ptr++ = FATM1_ReceiveByte();
          }
        } else {
          res = RES_PARERR;
        }
        break;

      case MMC_GET_SDSTAT :             /* Receive SD status as a data block (64 bytes) */
        if (FATM1_SendCmd(FATM1_ACMD13, 0) == 0) { /* SD_STATUS */
          (void)FATM1_ReceiveByte();
          if (!FATM1_ReceiveDataBlock(ptr, 64)) {
            res = RES_PARERR;
          }
        } else {
          res = RES_PARERR;
        }
        break;

      case MMC_GET_DRIVER_VERSION:      /* 1 byte: return: 0 SPI driver, 1 LLD SDHC driver */
        *ptr = 0;
        break;

      default:
        res = RES_PARERR;
    } /* switch */
  } /* if-else */
  return res;
}

#define FATM1_SPI_Enable()                   (void)SM2_Enable(SM2_DeviceData)
#define FATM1_SPI_Disable()                  (void)SM2_Disable(SM2_DeviceData)
#define FATM1_SPI_SetSlowMode()              (void)SM2_SelectConfiguration(SM2_DeviceData, 0, 0) /* max 400kbps */
#define FATM1_SPI_SetFastMode()              (void)SM2_SelectConfiguration(SM2_DeviceData, 1, 1) /* max 12Mbps */
#define FATM1_SPI_SetShiftClockPolarity(val) /* not needed for LDD */
#define FATM1_SPI_SetIdleClockPolarity(val)  /* not needed for LDD */

static volatile bool FATM1_DataReceivedFlag = FALSE;

void FATM1_SPI_WRITE(unsigned char write) {
  unsigned char dummy;

  FATM1_DataReceivedFlag = FALSE;
  (void)SM2_ReceiveBlock(SM2_DeviceData, &dummy, sizeof(dummy));
  (void)SM2_SendBlock(SM2_DeviceData, &write, sizeof(write));
  while(!FATM1_DataReceivedFlag){}
}

#if FATM1_SPI_WRITE_BLOCK_ENABLED
static void FATM1_SPI_WRITE_BLOCK(unsigned char *writeP, uint16_t size) {
  unsigned char dummy[4];
  uint16_t writeSize;

  while(size>0) {
    if (size>sizeof(dummy)) {
      writeSize = sizeof(dummy);
    } else {
      writeSize = size;
    }
    FATM1_DataReceivedFlag = FALSE;
    (void)SM2_ReceiveBlock(SM2_DeviceData, &dummy[0], writeSize);
    (void)SM2_SendBlock(SM2_DeviceData, writeP, writeSize);
    while(!FATM1_DataReceivedFlag){}
    size -= writeSize;
    writeP += writeSize;
  }
}
#endif /* FATM1_SPI_WRITE_BLOCK_ENABLED */

static void FATM1_SPI_WRITE_READ(unsigned char write, unsigned char *readP) {
  FATM1_DataReceivedFlag = FALSE;
  (void)SM2_ReceiveBlock(SM2_DeviceData, readP, 1);
  (void)SM2_SendBlock(SM2_DeviceData, &write, 1);
  while(!FATM1_DataReceivedFlag){}
}

#if FATM1_SPI_WRITE_READ_BLOCK_ENABLED
static void FATM1_SPI_WRITE_READ_BLOCK(unsigned char *writeP, unsigned char *readP, uint16_t size) {
  FATM1_DataReceivedFlag = FALSE;
  (void)SM2_ReceiveBlock(SM2_DeviceData, readP, size);
  (void)SM2_SendBlock(SM2_DeviceData, writeP, size);
  while(!FATM1_DataReceivedFlag){}
}
#endif /* FATM1_SPI_WRITE_READ_BLOCK_ENABLED */


#if FATM1_SPI_WRITE_BLOCK_ENABLED || FATM1_SPI_WRITE_READ_BLOCK_ENABLED
#if FATM1_BLOCK_SIZE==512
  #define SPI_WRITE_READ_BLOCK_SIZE_DUMMY 512 /* 512 bytes of dummy values */
  static const uint8_t dummyArr[SPI_WRITE_READ_BLOCK_SIZE_DUMMY] = {
    FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY,
    FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY,
    FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY,
    FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY,
    FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY,
    FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY
  };
#elif FATM1_BLOCK_SIZE==1024
  #define SPI_WRITE_READ_BLOCK_SIZE_DUMMY 1024 /* 1024 bytes of dummy values */
  static const uint8_t dummyArr[SPI_WRITE_READ_BLOCK_SIZE_DUMMY] = {
    FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY,
    FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY,
    FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY,
    FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY,
    FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY,
    FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY,
    FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY,
    FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY,
    FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY,
    FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY,
    FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY,
    FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY, FATM1_DUMMY
  };
#else
  #error "only 512 and 1024 block size supported"
#endif
#endif

/* Internal method prototypes */
static uint8_t SendCommand(uint8_t cmd, uint8_t *arg, uint8_t response);

/*
** ===================================================================
**     Method      :  FATM1_Activate (component SD_Card)
**     Description :
**         If multiple devices are used on the same SPI bus, then the
**         device needs to be activated. That way, the different SPI
**         protocol is selected.
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void FATM1_Activate(void)
{
  /* Note that the SD card SPI interface is defined with 'clock idle low polarity' and 'data shift on rising edge',
   * typically defined as well as 'Mode 0' (CPHA=0, CPOL=0). See http://elm-chan.org/docs/mmc/mmc_e.html
   */
  FATM1_InitCommChannel();
  FATM1_ENABLE_SS();                    /* select slave */
}

/*
** ===================================================================
**     Method      :  FATM1_Deactivate (component SD_Card)
**     Description :
**         Removes/deactivates the card from the bus
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void FATM1_Deactivate(void)
{
  FATM1_DISABLE_SS();                   /* de-select slave */
}

/*
** ===================================================================
**     Method      :  FATM1_WaitReady (component SD_Card)
**     Description :
**         Wait until the card is ready
**     Parameters  : None
**     Returns     :
**         ---             - Error code
**                           ERR_OK: device is ready
**                           ERR_BUSY: device is still busy
** ===================================================================
*/
uint8_t FATM1_WaitReady(void)
{
  uint8_t tmp;
  TMOUT1_CounterHandle timeout;

  FATM1_Activate();
  FATM1_SPI_WRITE(FATM1_DUMMY);
  timeout = TMOUT1_GetCounter(FATM1_TIMEOUT_READY_MS/TMOUT1_TICK_PERIOD_MS); /* set up timeout counter */
  for (;;) {                            /* will timeout */
    FATM1_SPI_WRITE_READ(FATM1_DUMMY, &tmp); /* write dummy value, read status */
    if (tmp==0xff) {
      break;
    }
    if (TMOUT1_CounterExpired(timeout)) {
      break;
    }
  } /* for */
  TMOUT1_LeaveCounter(timeout);
  FATM1_Deactivate();
  if (tmp==0xff) {
    return ERR_OK; /* device is ready */
  } else {
    return ERR_BUSY;
  }
}

/*
** ===================================================================
**     Method      :  FATM1_ReceiveDataBlock (component SD_Card)
**     Description :
**         Retrieve a data block from the device
**     Parameters  :
**         NAME            - DESCRIPTION
**       * data            - Pointer to data buffer
**         nofBytes        - number of bytes to retrieve,
**                           must be a multiple of 4
**     Returns     :
**         ---             - TRUE if reading was going fine, FALSE
**                           otherwise.
** ===================================================================
*/
bool FATM1_ReceiveDataBlock(uint8_t *data, uint16_t nofBytes)
{
  uint8_t tmp;
  TMOUT1_CounterHandle timeout;
  word cnt = 512; /* polling counter */

  FATM1_Activate();
  /* poll response */
  do {
    FATM1_SPI_WRITE_READ(FATM1_DUMMY, &tmp); /* send dummy value, poll response */
    cnt--;
  } while (tmp==0xFF && cnt>0);
  if (tmp==0xFF) { /* polling not successful, now poll for a longer period of time */
    timeout = TMOUT1_GetCounter(FATM1_TIMEOUT_READ_BLOCK_MS/TMOUT1_TICK_PERIOD_MS); /* timeout */
    for (;;) {                          /* will timeout */
      FATM1_SPI_WRITE_READ(FATM1_DUMMY, &tmp); /* send dummy value, poll response */
      if (tmp!=0xFF) {
        break;
      }
      if (TMOUT1_CounterExpired(timeout)) {
        break;
      }
    } /* for */
    TMOUT1_LeaveCounter(timeout);
  } /* if */
  if (tmp != 0xFE) {                    /* if it is not expected response, return with error */
    FATM1_Deactivate();
    return FALSE;
  }
  /*lint -save -e539 Did not expect positive indentation  */
#if FATM1_SPI_WRITE_READ_BLOCK_ENABLED
  if (nofBytes<=SPI_WRITE_READ_BLOCK_SIZE_DUMMY) {
    FATM1_SPI_WRITE_READ_BLOCK((unsigned char*)&dummyArr[0], data, nofBytes); /* write dummy value, read data */
  } else {
#endif
    while(nofBytes>0) {
      FATM1_SPI_WRITE_READ(FATM1_DUMMY, data); /* write dummy value, read data */
      data++;
      nofBytes--;
    }
#if FATM1_SPI_WRITE_READ_BLOCK_ENABLED
  }
#endif
  /*lint -restore Did not expect positive indentation */
  FATM1_SPI_WRITE(FATM1_DUMMY);         /* checksum Bytes not needed */
  FATM1_SPI_WRITE(FATM1_DUMMY);
  FATM1_Deactivate();
  return TRUE;
}

/*
** ===================================================================
**     Method      :  FATM1_SendDataBlock (component SD_Card)
**     Description :
**         Send a data block to the device
**     Parameters  :
**         NAME            - DESCRIPTION
**       * data            - Pointer to data blocks with 512 bytes
**                           each
**         token           - data/stop token
**         nofBytes        - Number of bytes to send
**     Returns     :
**         ---             - Returns TRUE for success, FALSE for
**                           failure.
** ===================================================================
*/
bool FATM1_SendDataBlock(uint8_t *data, uint8_t token, uint16_t nofBytes)
{
  uint8_t resp;

  if (FATM1_WaitReady()!=ERR_OK) {
    return FALSE;                       /* device not ready */
  }
  FATM1_Activate();
  FATM1_SPI_WRITE(token);               /* Xmit data token */
  if (token != 0xFD) {                  /* Is data token, not STOP_TRAN */
#if FATM1_SPI_WRITE_BLOCK_ENABLED
    FATM1_SPI_WRITE_BLOCK(data, nofBytes);
#else
    while (nofBytes!=0) {               /* send the bytes */
      FATM1_SPI_WRITE(*data);
      data++;
      nofBytes--;
    }
#endif
    FATM1_SPI_WRITE(FATM1_DUMMY);       /* CRC (Dummy) */
    FATM1_SPI_WRITE(FATM1_DUMMY);       /* CRC (Dummy) */
    FATM1_SPI_WRITE_READ(FATM1_DUMMY, &resp); /* write dummy value, receive data response */
    if ((resp&0x1F) != 0x05) {          /* If not accepted, return with error */
      FATM1_Deactivate();
      return FALSE;
    }
    /* if we do not poll the device for its busy state, we need to provide at least 8 clocks (dummy cycle).
     * See http://elm-chan.org/docs/mmc/mmc_e.html:
     *    In principle of the SPI mode, the CS signal must be asserted during a transaction,
     *    however there is an exception to this rule. When the card is busy, the host controller
     *    can deassert CS to release SPI bus for any other SPI devices. The card will drive DO signal
     *    low again when reselect it during internal process is in progress.
     *    Therefore a preceding busy check (wait ready immediately before command and data packet)
     *    instead of post wait can eliminate waste wait time. In addition the internal process is initiated
     *    a byte after the data response, this means eight clocks are required to initiate internal write operation.
     */
    FATM1_SPI_WRITE(FATM1_DUMMY);
  }
  FATM1_Deactivate();
  return TRUE;
}

/*
** ===================================================================
**     Method      :  FATM1_SendCmd (component SD_Card)
**     Description :
**         Sends a command to the device and returns the response
**     Parameters  :
**         NAME            - DESCRIPTION
**         cmd             - Command to send
**         arg             - command argument
**     Returns     :
**         ---             - device response
** ===================================================================
*/
uint8_t FATM1_SendCmd(uint8_t cmd, uint32_t arg)
{
  uint8_t n, res;
  TMOUT1_CounterHandle timeout;

  if (cmd&0x80) {                       /* ACMD<n> is the command sequence of CMD55-CMD<n> */
    cmd &= 0x7F;
    res = FATM1_SendCmd(FATM1_CMD55, 0);
    if (res > 1) {
      return res;
    }
  }
  /* Select the card and wait for ready */
  if (FATM1_WaitReady() != ERR_OK) {
    return 0xFF;
  }
  FATM1_Activate();
  /* Send command packet */
  FATM1_SPI_WRITE(cmd);                 /* Start + Command index */
  n = (uint8_t)(arg>>24);
  FATM1_SPI_WRITE(n);                   /* Argument[31..24] */
  n = (uint8_t)(arg>>16);
  FATM1_SPI_WRITE(n);                   /* Argument[23..16] */
  n = (uint8_t)(arg>>8);
  FATM1_SPI_WRITE(n);                   /* Argument[15..8] */
  FATM1_SPI_WRITE((uint8_t)arg);        /* Argument[7..0] */
  if (cmd == FATM1_CMD0) {
    n = 0x95;                           /* Valid CRC for CMD0(0) */
  } else if (cmd == FATM1_CMD8) {
    n = 0x87;                           /* Valid CRC for CMD8(0x1AA) */
  } else {
    n = 0x01;                           /* Dummy CRC + Stop */
  }
  FATM1_SPI_WRITE(n);
  /* Receive command response */
  if (cmd == FATM1_CMD12) {
    FATM1_SPI_WRITE_READ(FATM1_DUMMY, &res); /* send dummy value, poll response */
  }
  timeout = TMOUT1_GetCounter(FATM1_TIMEOUT_CMD_MS/TMOUT1_TICK_PERIOD_MS); /* timeout */
  for(;;) {                            /* will timeout */
    FATM1_SPI_WRITE_READ(FATM1_DUMMY, &res); /* send dummy value, poll response */
    if (!(res&0x80)) {                 /* valid response */
      break;
    }
    if (TMOUT1_CounterExpired(timeout)) {
      break;
    }
  }
  TMOUT1_LeaveCounter(timeout);
  FATM1_Deactivate();
  return res;                           /* Return with the response value */
}
/*
** ===================================================================
**     Method      :  FATM1_isWriteProtected (component SD_Card)
**     Description :
**         Determines if the card is write protected. Note that this is
**         an indicator only, as it is still possible to write to the
**         card even if the write protection is set on the card!
**     Parameters  : None
**     Returns     :
**         ---             - True if the card has the write protection
**                           set, false otherwise
** ===================================================================
*/
/*
bool FATM1_isWriteProtected(void)
{
  *** method is implemented as macro in the header file
}
*/

/*
** ===================================================================
**     Method      :  SendCommand (component SD_Card)
**
**     Description :
**         Sends a command to the SD card
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static uint8_t SendCommand(uint8_t cmd, uint8_t *arg, uint8_t response)
{
  #define NOF_WAIT_ITERATIONS 3
  uint8_t u8Temp=0;
  uint8_t u8Counter;

  FATM1_Activate();
  FATM1_SPI_WRITE(cmd);                 /* Send Start byte */
  /* Send Argument */
  for(u8Counter=0; u8Counter<4; u8Counter++) {
    FATM1_SPI_WRITE(arg[u8Counter]);
  }
  FATM1_SPI_WRITE(0x95);                /* Send CRC */
  /* Response Handler */
  for (u8Counter=0;u8Counter<NOF_WAIT_ITERATIONS;u8Counter++) {
    FATM1_SPI_WRITE_READ(FATM1_DUMMY, &u8Temp); /* send dummy value, poll response */
    if (u8Temp==response) {
      break;
    }
  } /* for */
  FATM1_Deactivate();
  if (u8Temp==response) {
    return ERR_OK;
  } else {
    return ERR_FAULT;
  }
}

/*
** ===================================================================
**     Method      :  FATM1_Init (component SD_Card)
**     Description :
**         Initializes the driver
**     Parameters  :
**         NAME            - DESCRIPTION
**       * unused          - unused parameter
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t FATM1_Init(void* unused)
{
  /* The behavior of SD cards in SPI mode is basically the same as for any SPI slave device.
     The maximum transfer rate of the SD card in SPI mode is 25 Mbps, but in the initialization process the
     transfer rate must be less than 375 kbps. This is because the SPI mode of the SD cards is compatible with
     the MMC cards, and MMC cards can only reach 375 kbps. After initialization, the SPI clock can be
     changed to 25 Mbps.
     Note that the SPI interface is defined with 'clock idle low polarity' and 'data shift on rising edge',
     typically defined as well as 'Mode 0' (CPHA=0, CPOL=0). See http://elm-chan.org/docs/mmc/mmc_e.html
   */
  dword arg;
  TMOUT1_CounterHandle timeout;
  bool isTimeout = FALSE;
  uint8_t cnt;

  (void)unused;
  /* -------------------------------- Init & Slow Mode -------------------------------- */
  /* after voltage reaches 2.2V, need to wait at least 1 ms. Then we need to set Data and CS/Chipselect high for at least 74 clocks */
  /*lint -save -e522 function lacks side-effects */
  WAIT1_Waitms(1);                      /* wait at least for 1 ms on insertion and power on */
  /*lint -restore */
  currentSpeedMode = FATM1_ACTIVATE_MODE_NONE;
  FATM1_Activate();                     /* select slave */
  FATM1_SetSlowMode();                  /* set the SPI clock to 375 kbps. This is required for compatibility across a wide range of SD and MMC cards. */
  FATM1_DISABLE_SS();                   /* disable slave (CS high) */
  for(cnt=0;cnt<10;cnt++) {             /* send at least 75 SPI clock cycles with the SS signal asserted to ensure that the SD card internal state machine is initialized. */
    FATM1_SPI_WRITE(FATM1_DUMMY);
  }
  /*lint -save -e522 function lacks side-effects */
  WAIT1_Waitus(50);                     /* need to wait a little bin in order SPI transfer to be finished (need this on CN128, but on others too?) */
  /*lint -restore */
  FATM1_Deactivate();
  /* -------------------------------- IDLE Command -------------------------------- */
  arg = 0;
  timeout = TMOUT1_GetCounter(FATM1_TIMEOUT_READY_MS/TMOUT1_TICK_PERIOD_MS); /* timeout */
  while (SendCommand(FATM1_CMD0, (uint8_t*)&arg, FATM1_IDLE) != ERR_OK) {
    if (TMOUT1_CounterExpired(timeout)) {
      isTimeout = TRUE;                /* indicate a timeout */
      break;
    }
  } /* while */
  TMOUT1_LeaveCounter(timeout);
  if (isTimeout) {                      /* timeout */
    return ERR_FAULT;
  }
  /* Send 8 SPI clocks (SS unasserted). */
  FATM1_Activate();
  FATM1_DISABLE_SS();                   /* disable slave */
  FATM1_SPI_WRITE(FATM1_DUMMY);         /* dummy SPI cycle */
  FATM1_Deactivate();                   /* de-select slave */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  FATM1_ReceiveByte (component SD_Card)
**
**     Description :
**         Receives a byte from the SPI bus
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
uint8_t FATM1_ReceiveByte(void)
{
  uint8_t data;

  FATM1_Activate();
  FATM1_SPI_WRITE_READ(FATM1_DUMMY, &data); /* send dummy value, poll response */
  FATM1_Deactivate();
  return data;
}

/*
** ===================================================================
**     Method      :  FATM1_CardPresent (component SD_Card)
**     Description :
**         Returns true in case a card is present. If there is no card
**         detection pin, then this routine will always return true.
**     Parameters  : None
**     Returns     :
**         ---             - Returns true if card is present, false
**                           otherwise.
** ===================================================================
*/
/*
bool FATM1_CardPresent(void)
{
  *** method is implemented as macro in the header file
}
*/

/*
** ===================================================================
**     Method      :  FATM1_SetSlowMode (component SD_Card)
**     Description :
**         Switches to slow mode SPI communication speed.
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void FATM1_SetSlowMode(void)
{
  if (currentSpeedMode!=FATM1_ACTIVATE_MODE_SLOW) {
    /* not already in slow mode */
#if 0 /* if using LDD component, do not disable the SPI, as FATM1_SPI_SetSlowMode() (SelectConfiguration()) only works with enabled device! */
    FATM1_SPI_Disable();
#endif
    FATM1_SPI_SetSlowMode();            /* the SPI clock is set to the maximum supported by the MCU and allowed by the SD card */
    currentSpeedMode = FATM1_ACTIVATE_MODE_SLOW;
#if 0 /* if using LDD component, do not disable the SPI, as FATM1_SPI_SetSlowMode() (SelectConfiguration()) only works with enabled device! */
    FATM1_SPI_Enable();
#endif
  } /* if */
}

/*
** ===================================================================
**     Method      :  FATM1_SetFastMode (component SD_Card)
**     Description :
**         Switches to fast mode SPI communication speed.
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void FATM1_SetFastMode(void)
{
  if (currentSpeedMode!=FATM1_ACTIVATE_MODE_FAST) {
    /* not already in fast mode */
#if 0 /* if using LDD component, do not disable the SPI, as FATM1_SPI_SetSlowMode() (SelectConfiguration()) only works with enabled device! */
    FATM1_SPI_Disable();
#endif
    FATM1_SPI_SetFastMode();            /* the SPI clock is set to the maximum supported by the MCU and allowed by the SD card */
    currentSpeedMode = FATM1_ACTIVATE_MODE_FAST;
#if 0 /* if using LDD component, do not disable the SPI, as FATM1_SPI_SetSlowMode() (SelectConfiguration()) only works with enabled device! */
    FATM1_SPI_Enable();
#endif
  } /* if */
}

/*
** ===================================================================
**     Method      :  FATM1_InitCommChannel (component SD_Card)
**     Description :
**         Method to initialize the communication channel. This is
**         needed if the bus to the SD card is shared with other
**         devices.
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void FATM1_InitCommChannel(void)
{
  /* Settings:
    - 100-400 kHz clock during init, then max 12 MHz
    - Send MSB first
    - Shift clock idle polarity: low
    - Clock edge: falling edge
  */
  if (currentSpeedMode==FATM1_ACTIVATE_MODE_FAST) {
    FATM1_SetFastMode(); /* use fast mode. */
  } else if (currentSpeedMode==FATM1_ACTIVATE_MODE_SLOW) {
    FATM1_SetSlowMode(); /* use slow mode. */
  }
}

/*
** ===================================================================
**     Method      :  FATM1_Deinit (component SD_Card)
**     Description :
**         Driver deinitialization routine.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * unused          - dummy parameter
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t FATM1_Deinit(void* unused)
{
  (void)unused;
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  FATM1_OnBlockReceived (component SD_Card)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
void SM2_OnBlockReceived(LDD_TUserData *UserDataPtr)
{
  /* Calling inherited event */
  (void)UserDataPtr; /* unused */
  FATM1_DataReceivedFlag=TRUE;
}

/* END FATM1. */

/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.5 [05.21]
**     for the Freescale Kinetis series of microcontrollers.
**
** ###################################################################
*/
