<?xml version="1.0" encoding="UTF-8"?>
<Bean>
  <Header>
    <Name>FreeRTOS</Name>
    <Description>FreeRTOS</Description>
    <Author>Erich Styger</Author>
    <Version>01.269</Version>
    <Icon>FreeRTOS</Icon>
    <TypesFiles>PE,FreeRTOS\FreeRTOS</TypesFiles>
    <FileVersion>6</FileVersion>
  </Header>
  <Options>
    <Category>Operating Systems</Category>
    <OperatingSystemId>FreeRTOS</OperatingSystemId>
    <BW_HelpType>BasicPlusUsageAppNote</BW_HelpType>
    <BW_HelpFiles>,Properties,Methods,Events,"Typical Usage","Application Notes"</BW_HelpFiles>
    <BW_AutoSaveHelp>yes</BW_AutoSaveHelp>
    <BW_AutoSaveDriver>yes</BW_AutoSaveDriver>
    <BW_DetailedHelp>yes</BW_DetailedHelp>
    <BW_NeedTps>yes</BW_NeedTps>
    <BW_NeedUst>11</BW_NeedUst>
    <BW_NeedCns>0</BW_NeedCns>
    <BeanStatus>PROPOSAL</BeanStatus>
    <Copyright>License : Open Source (LGPL)\nFreeRTOS (c) Copyright 2003-2013 Richard Barry, http: www.FreeRTOS.org\nFreeRTOS Processor Expert Component: (c) Copyright Erich Styger, 2013\nProcessor Expert and CodeWarrior (c) Copyright Freescale Semiconductor, 2013, all rights reserved\nThis is a free software and is opened for education, research and commercial developments under license policy of following terms:\n* This is a free software and there is NO WARRANTY.\n* No restriction on use. You can use, modify and redistribute it for personal, non-profit or commercial product UNDER YOUR RESPONSIBILITY.\n* Redistributions of source code must retain the above copyright notice.</Copyright>
    <Shortcut>FRTOS</Shortcut>
    <DemoDriver>no</DemoDriver>
    <BeanLevel>High</BeanLevel>
    <OneBeanInstance>There can be only one FreeRTOS active in the project, as the RTOS files need to have different names.</OneBeanInstance>
  </Options>
  <PropertyList>
    <Property>
      <TCompNameItem>
        <Name>Component name</Name>
        <Symbol>DeviceName</Symbol>
        <Hint>Name of the component.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue/>
      </TCompNameItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Disabled Interrupts in Startup</Name>
        <Symbol>DisabledInterruptsInStartup</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>If set to 'yes', then interrupts will be disabled in PE_low_level_init() using the PEX_RTOS_INIT() macro.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TStrgItem>
        <Name>RTOS Version</Name>
        <Symbol>FreeRTOSVersion</Symbol>
        <Hint>Identifies the RTOS version</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>V7.4.2</DefaultValue>
        <StrDefine>nothing</StrDefine>
        <MinLength>0</MinLength>
        <MaxLength>-1</MaxLength>
      </TStrgItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Classic CodeWarrior</Name>
        <Symbol>IsClassicCW</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>If you are using this component in classic (non-eclipse based) CodeWarrior, then this setting has to be set to 'yes'. If you want to know why: The reason is that classic CodeWarrior does not come with the common_RTOSAdaptor.prg file. As such a test has to be present  in FreeRTOS.ts2.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TInhrLinkItem>
        <Name>Utility</Name>
        <Symbol>Utility</Symbol>
        <TypeSpec>Utility_I</TypeSpec>
        <Hint>Interface to utility functions</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <DefaultValue/>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <SortStyle/>
      </TInhrLinkItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Application Task Tags</Name>
        <Symbol>UseApplicationTaskTags</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>This configures configUSE_APPLICATION_TASK_TAG. If enabled, the methodsxTaskGetApplicationTaskTag(), vTaskSetApplicationTaskTag() and xTaskCallApplicationTaskHook() are enabled.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Use Trace Facility</Name>
        <Symbol>UseTraceFacility</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>Set to 1 if you wish the trace visualisation functionality to be available, or 0 if the trace functionality is not going to be used. If you use the trace functionality a trace buffer must also be provided. If using Trace Hooks, this property is automatically enabled. This setting controls the configUSE_TRACE_FACILITY macro.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TBoolGrupItem>
        <Name>TraceHooks</Name>
        <Symbol>UseTraceHooksGroup</Symbol>
        <TypeSpec>typeEnaDis</TypeSpec>
        <Hint>If enabled, you can condfigure trace hooks to collect information about the RTOS behaviour.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>Disabled</Description>
        <Expanded>No</Expanded>
        <DefaultValue>false</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <Children>
          <GrupItem>
            <TInhrItem>
              <Name>FreeRTOS Trace</Name>
              <Symbol>FRTrace</Symbol>
              <TypeSpec>FreeRTOS\FreeRTOSTraceInterface</TypeSpec>
              <Hint>Interface to the trace hooks.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>-1</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <InhrBeanBaseName>RTOSTRC</InhrBeanBaseName>
              <ShowInheritedMethodsEventsInPrjTree>true</ShowInheritedMethodsEventsInPrjTree>
            </TInhrItem>
          </GrupItem>
        </Children>
      </TBoolGrupItem>
    </Property>
    <Property>
      <TBoolGrupItem>
        <Name>Collect Runtime Statistics</Name>
        <Symbol>CollectRuntimeStatisticsGroup</Symbol>
        <TypeSpec>typeEnaDis</TypeSpec>
        <Hint>If enabled, runtime statistics are collected. This setting configures configGENERATE_RUN_TIME_STATS. A timer with at least  least 10 times faster than the tick counter needs to be provided)</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>Disabled</Description>
        <Expanded>No</Expanded>
        <DefaultValue>false</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <Children>
          <GrupItem>
            <TBoolGrupItem>
              <Name>LDD</Name>
              <Symbol>LDDRuntimeCounterGroup</Symbol>
              <TypeSpec>typeEnaDis</TypeSpec>
              <Hint>Logical Device Driver</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description>Disabled</Description>
              <Expanded>No</Expanded>
              <DefaultValue>false</DefaultValue>
              <DefineSymbol>YES_NO</DefineSymbol>
              <IfDisabled>setNOTHING</IfDisabled>
              <Children>
                <GrupItem>
                  <TInhrItem>
                    <Name>Runtime Counter LDD</Name>
                    <Symbol>RuntimeCntrLDD</Symbol>
                    <TypeSpec>FreeRTOS\RuntimeCntrLDD</TypeSpec>
                    <Hint>Logical Device Driver implementing the runtime counter. Counter to be used to collect run time statistics. portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and  portGET_RUN_TIME_COUNTER_VALUE() will be created to access the counter value. The counter frequency should be about 10 times the frequency of the tick timer.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>false</EditLine>
                    <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
                    <DefaultIndex>-1</DefaultIndex>
                    <TextValueIndex>false</TextValueIndex>
                    <RuntimeProperty>false</RuntimeProperty>
                    <CanDelete>false</CanDelete>
                    <IconPopup>false</IconPopup>
                    <InhrBeanBaseName>RTOSCNTRLDD</InhrBeanBaseName>
                    <ShowInheritedMethodsEventsInPrjTree>true</ShowInheritedMethodsEventsInPrjTree>
                  </TInhrItem>
                </GrupItem>
              </Children>
            </TBoolGrupItem>
          </GrupItem>
          <GrupItem>
            <TBoolGrupItem>
              <Name>non-LDD</Name>
              <Symbol>NonLDDRuntimeCounterGroup</Symbol>
              <TypeSpec>typeEnaDis</TypeSpec>
              <Hint>Using a traditional (non Logical Device Driver) component</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description>Enabled</Description>
              <Expanded>Yes</Expanded>
              <DefaultValue>true</DefaultValue>
              <DefineSymbol>YES_NO</DefineSymbol>
              <IfDisabled>setNOTHING</IfDisabled>
              <Children>
                <GrupItem>
                  <TInhrItem>
                    <Name>Runtime Counter</Name>
                    <Symbol>RuntimeCntr</Symbol>
                    <TypeSpec>FreeRTOS\RuntimeCntr</TypeSpec>
                    <Hint>Counter to be used to collect run time statistics. portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and  portGET_RUN_TIME_COUNTER_VALUE() will be created to access the counter value. The counter frequency should be about 10 times the frequency of the tick timer.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>false</EditLine>
                    <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
                    <DefaultIndex>-1</DefaultIndex>
                    <TextValueIndex>false</TextValueIndex>
                    <RuntimeProperty>false</RuntimeProperty>
                    <CanDelete>false</CanDelete>
                    <IconPopup>false</IconPopup>
                    <InhrBeanBaseName>RTOSCNTR</InhrBeanBaseName>
                    <ShowInheritedMethodsEventsInPrjTree>true</ShowInheritedMethodsEventsInPrjTree>
                  </TInhrItem>
                </GrupItem>
              </Children>
            </TBoolGrupItem>
          </GrupItem>
        </Children>
      </TBoolGrupItem>
    </Property>
    <Property>
      <TGrupItem>
        <Name>Scheduler</Name>
        <Symbol>SchedulerGroup</Symbol>
        <Hint>Settings for the scheduler</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>Settings for the scheduler</Description>
        <Expanded>Yes</Expanded>
        <Children>
          <GrupItem>
            <TBoolGrupItem>
              <Name>ColdFire V1</Name>
              <Symbol>ColdFireV1CPUSpecific</Symbol>
              <TypeSpec>typeEnaDis</TypeSpec>
              <Hint>This group is used to configure the RTOS for the ColdFire V1 cores</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description>Enabled</Description>
              <Expanded>Yes</Expanded>
              <DefaultValue>true</DefaultValue>
              <DefineSymbol>YES_NO</DefineSymbol>
              <IfDisabled>setNOTHING</IfDisabled>
              <Children>
                <GrupItem>
                  <TEnumItem>
                    <Name>CPU</Name>
                    <Symbol>FreeRTOSColdFireCPU</Symbol>
                    <TypeSpec>typeCFcpu</TypeSpec>
                    <Hint>Specify which ColdFire CPU is used (ColdFire V1 only). This is affecting the portCF_INTC_VALUE macro in portmacro.h</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
                    <DefaultIndex>0</DefaultIndex>
                    <TextValueIndex>true</TextValueIndex>
                    <RuntimeProperty>false</RuntimeProperty>
                    <CanDelete>false</CanDelete>
                    <IconPopup>false</IconPopup>
                  </TEnumItem>
                </GrupItem>
                <GrupItem>
                  <TEnumItem>
                    <Name>SWI</Name>
                    <Symbol>ColdFireSWI</Symbol>
                    <TypeSpec>typeCFswi</TypeSpec>
                    <Hint>Specify which software interrupt shall be used for task switching (ColdFire only)</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
                    <DefaultIndex>0</DefaultIndex>
                    <TextValueIndex>true</TextValueIndex>
                    <RuntimeProperty>false</RuntimeProperty>
                    <CanDelete>false</CanDelete>
                    <IconPopup>false</IconPopup>
                  </TEnumItem>
                </GrupItem>
              </Children>
            </TBoolGrupItem>
          </GrupItem>
          <GrupItem>
            <TBoolGrupItem>
              <Name>ColdFire V2</Name>
              <Symbol>ColdFireV2CPUSpecific</Symbol>
              <TypeSpec>typeEnaDis</TypeSpec>
              <Hint>This group is used to configure the RTOS for the ColdFire V2 cores</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description>Enabled</Description>
              <Expanded>Yes</Expanded>
              <DefaultValue>true</DefaultValue>
              <DefineSymbol>YES_NO</DefineSymbol>
              <IfDisabled>setNOTHING</IfDisabled>
              <Children>
                <GrupItem>
                  <TEnumItem>
                    <Name>CPU</Name>
                    <Symbol>FreeRTOSColdFireV2CPU</Symbol>
                    <TypeSpec>typeCF2cpu</TypeSpec>
                    <Hint>CPU</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
                    <DefaultIndex>0</DefaultIndex>
                    <TextValueIndex>true</TextValueIndex>
                    <RuntimeProperty>false</RuntimeProperty>
                    <CanDelete>false</CanDelete>
                    <IconPopup>false</IconPopup>
                  </TEnumItem>
                </GrupItem>
                <GrupItem>
                  <TIntgItem>
                    <Name>Library Lowest Interrupt Priority</Name>
                    <Symbol>ColdFireV2LibraryLowestInterruptPriority</Symbol>
                    <Hint>Used for configLIBRARY_LOWEST_INTERRUPT_PRIORITY. The RTOS will disable interrupts equal or lower than this priority. So for example if you set it to 5, then interrupts with level 6 can happen while the RTOS is running. This means as well that you shall *not* call any RTOS functions with an interrupt priority higher than this value! Keep in mind that for the ColdFire V2, the interrupts of level 7 can *not* be masked.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>7</DefaultValue>
                    <MinValue>0</MinValue>
                    <MaxValue>7</MaxValue>
                    <Bases>DEC</Bases>
                    <DefaultBase>DEC</DefaultBase>
                    <ExtraHintDisabled>false</ExtraHintDisabled>
                    <ChangeValueIntoRange>false</ChangeValueIntoRange>
                    <RuntimeProperty>false</RuntimeProperty>
                  </TIntgItem>
                </GrupItem>
                <GrupItem>
                  <TIntgItem>
                    <Name>SWI Number</Name>
                    <Symbol>ColdFireV2SWInumber</Symbol>
                    <Hint>Software Interrupt Vector number.\n
Mapping for number to vector for the MCF52259:\n
     0: 0x40  0x00000100 Reserved64    \n
     1: 0x41  0x00000104 INT_EPORT_EPF1\n
     2: 0x42  0x00000108 INT_EPORT_EPF2\n
     3: 0x43  0x0000010C INT_EPORT_EPF3\n
     4: 0x44  0x00000110 INT_EPORT_EPF4\n
     5: 0x45  0x00000114 INT_EPORT_EPF5\n
     6: 0x46  0x00000118 INT_EPORT_EPF6\n
     7: 0x47  0x0000011C INT_EPORT_EPF7\n
     8: 0x48  0x00000120 INT_SCM_SWTI  \n
     9: 0x49  0x00000124 INT_DMA0_DONE \n
    10: 0x4A  0x00000128 INT_DMA1_DONE \n
    11: 0x4B  0x0000012C INT_DMA2_DONE \n
    12: 0x4C  0x00000130 INT_DMA3_DONE \n
    13: 0x4D  0x00000134 INT_UART0     \n
    14: 0x4E  0x00000138 INT_UART1     \n
    15: 0x4F  0x0000013C INT_UART2     \n
    16: 0x50  0x00000140 Reserved80    </Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>1</DefaultValue>
                    <MinValue>0</MinValue>
                    <MaxValue>-1</MaxValue>
                    <Bases>DEC</Bases>
                    <DefaultBase>DEC</DefaultBase>
                    <ExtraHintDisabled>false</ExtraHintDisabled>
                    <ChangeValueIntoRange>false</ChangeValueIntoRange>
                    <RuntimeProperty>false</RuntimeProperty>
                  </TIntgItem>
                </GrupItem>
              </Children>
            </TBoolGrupItem>
          </GrupItem>
          <GrupItem>
            <TBoolGrupItem>
              <Name>Kinetis</Name>
              <Symbol>KinetisCPUSpecific</Symbol>
              <TypeSpec>typeEnaDis</TypeSpec>
              <Hint>This group is used to configure the RTOS for the Kinetis/ARM cores</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description>Enabled</Description>
              <Expanded>Yes</Expanded>
              <DefaultValue>true</DefaultValue>
              <DefineSymbol>YES_NO</DefineSymbol>
              <IfDisabled>setNOTHING</IfDisabled>
              <Children>
                <GrupItem>
                  <TEnumItem>
                    <Name>ARM Family</Name>
                    <Symbol>ARMFamilyType</Symbol>
                    <TypeSpec>typeARMFamily</TypeSpec>
                    <Hint>Specifies the ARM family used</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
                    <DefaultIndex>1</DefaultIndex>
                    <TextValueIndex>true</TextValueIndex>
                    <RuntimeProperty>false</RuntimeProperty>
                    <CanDelete>false</CanDelete>
                    <IconPopup>false</IconPopup>
                  </TEnumItem>
                </GrupItem>
                <GrupItem>
                  <TBoolItem>
                    <Name>Floating Point Support</Name>
                    <Symbol>M4FFloatingPointSupport</Symbol>
                    <TypeSpec>typeYesNo</TypeSpec>
                    <Hint>If enabled, the port is supporting the different stack frame created by the Cortex M4F</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>false</EditLine>
                    <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
                    <DefaultIndex>1</DefaultIndex>
                    <TextValueIndex>false</TextValueIndex>
                    <RuntimeProperty>false</RuntimeProperty>
                    <CanDelete>false</CanDelete>
                    <IconPopup>false</IconPopup>
                    <DefaultValue>false</DefaultValue>
                    <Popup>false</Popup>
                  </TBoolItem>
                </GrupItem>
                <GrupItem>
                  <TIntgItem>
                    <Name>Lowest Interrupt Priority</Name>
                    <Symbol>ARMLowestInterrutpPriority</Symbol>
                    <Hint>Lowest possible interrupt priority as defined by the CPU, with zero the *highest* priority. This property is informal only.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <ReadOnly>true</ReadOnly>
                    <EditLine>true</EditLine>
                    <DefaultValue>0</DefaultValue>
                    <MinValue>0</MinValue>
                    <MaxValue>-1</MaxValue>
                    <Bases>DEC</Bases>
                    <DefaultBase>DEC</DefaultBase>
                    <ExtraHintDisabled>false</ExtraHintDisabled>
                    <ChangeValueIntoRange>false</ChangeValueIntoRange>
                    <RuntimeProperty>false</RuntimeProperty>
                  </TIntgItem>
                </GrupItem>
                <GrupItem>
                  <TIntgItem>
                    <Name>Library Lowest Interrupt Priority</Name>
                    <Symbol>KinetisLibraryLowestInterruptPriority</Symbol>
                    <Hint>Used for configLIBRARY_LOWEST_INTERRUPT_PRIORITY. The lowest interrupt priority that can be used in a call to a "set priority" function. This priority is used for the kernel port itself too. Note that 0 is the highest priority for ARM/Kinetis.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>15</DefaultValue>
                    <MinValue>0</MinValue>
                    <MaxValue>15</MaxValue>
                    <Bases>DEC</Bases>
                    <DefaultBase>DEC</DefaultBase>
                    <ExtraHintDisabled>false</ExtraHintDisabled>
                    <ChangeValueIntoRange>false</ChangeValueIntoRange>
                    <RuntimeProperty>false</RuntimeProperty>
                  </TIntgItem>
                </GrupItem>
                <GrupItem>
                  <TIntgItem>
                    <Name>Max SysCall Interrupt Priority</Name>
                    <Symbol>KinetisLibraryMaxInterruptPriority</Symbol>
                    <Hint>Used for configMAX_SYSCALL_INTERRUPT_PRIORITY. \n
The highest interrupt priority that can be used by any interrupt service routine that makes calls to interrupt safe FreeRTOS API functions.  DO NOT CALL INTERRUPT SAFE FREERTOS API FUNCTIONS FROM ANY INTERRUPT THAT HAS A HIGHER PRIORITY THAN THIS! (higher priorities are lower numeric values). configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to zero! See  http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html. Note that 0 is the highest priority for Kinetis.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>5</DefaultValue>
                    <MinValue>1</MinValue>
                    <MaxValue>15</MaxValue>
                    <Bases>DEC</Bases>
                    <DefaultBase>DEC</DefaultBase>
                    <ExtraHintDisabled>false</ExtraHintDisabled>
                    <ChangeValueIntoRange>false</ChangeValueIntoRange>
                    <RuntimeProperty>false</RuntimeProperty>
                  </TIntgItem>
                </GrupItem>
                <GrupItem>
                  <TEnumItem>
                    <Name>Compiler Optimization Level</Name>
                    <Symbol>CompilerOptimizationLevel</Symbol>
                    <TypeSpec>typeOptimizationLevel</TypeSpec>
                    <Hint>Not applicable for gcc. Optimization level of the compiler as in the build tools settings. Depending on the optimization level, the stack frame of the Processor Expert functions and consequently the xPortPendSVHandler() and vPortSVCHandler() functions need to be different, and the port needs to be aware about it. With the MCU10.2 compiler (after Jan 1st 2012) the compiler defines a macro (__optlevel0, etc) for the optimization level used which is checked in the generated code. If the settings do not match, then the source code will raise an #error at compilation time.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
                    <DefaultIndex>0</DefaultIndex>
                    <TextValueIndex>true</TextValueIndex>
                    <RuntimeProperty>false</RuntimeProperty>
                    <CanDelete>false</CanDelete>
                    <IconPopup>false</IconPopup>
                  </TEnumItem>
                </GrupItem>
              </Children>
            </TBoolGrupItem>
          </GrupItem>
          <GrupItem>
            <TBoolGrupItem>
              <Name>LDD SWI</Name>
              <Symbol>LDDSWIGroup</Symbol>
              <TypeSpec>typeEnaDis</TypeSpec>
              <Hint>Group configuring the software interrupt using Low Level Driver component</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description>Enabled</Description>
              <Expanded>Yes</Expanded>
              <DefaultValue>true</DefaultValue>
              <DefineSymbol>YES_NO</DefineSymbol>
              <IfDisabled>setNOTHING</IfDisabled>
            </TBoolGrupItem>
          </GrupItem>
          <GrupItem>
            <TBoolGrupItem>
              <Name>non-LDD SWI</Name>
              <Symbol>NonLDDSWIGroup</Symbol>
              <TypeSpec>typeEnaDis</TypeSpec>
              <Hint>Group configuring the software interrupt using classic non-Low Level Driver component</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description>Enabled</Description>
              <Expanded>Yes</Expanded>
              <DefaultValue>true</DefaultValue>
              <DefineSymbol>YES_NO</DefineSymbol>
              <IfDisabled>setNOTHING</IfDisabled>
              <Children>
                <GrupItem>
                  <TInhrItem>
                    <Name>SWI</Name>
                    <Symbol>SWI</Symbol>
                    <TypeSpec>FreeRTOS\SWI</TypeSpec>
                    <Hint>In order to make a context switch, the RTOS needs a SWI (software interrupt).</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>false</EditLine>
                    <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
                    <DefaultIndex>-1</DefaultIndex>
                    <TextValueIndex>false</TextValueIndex>
                    <RuntimeProperty>false</RuntimeProperty>
                    <CanDelete>false</CanDelete>
                    <IconPopup>false</IconPopup>
                    <InhrBeanBaseName>RTOSSWI</InhrBeanBaseName>
                    <ShowInheritedMethodsEventsInPrjTree>true</ShowInheritedMethodsEventsInPrjTree>
                  </TInhrItem>
                </GrupItem>
              </Children>
            </TBoolGrupItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Preemptive</Name>
              <Symbol>UsePreemption</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>Set to 1 to use the preemptive kernel, or 0 to use the cooperative kernel. (configUSE_PREEMPTION flag)</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>0</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>true</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Use Co-Routines</Name>
              <Symbol>UseCoroutines</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>Set to 1 to include co-routine functionality in the build, or 0 to omit co-routine functionality from the build. To include co-routines croutine.c must be included in the project. </Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>1</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>false</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Idle should yield</Name>
              <Symbol>IdleShouldYield</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>This parameter controls the behaviour of tasks at the idle priority. It only has an effect if:\n
   1. The preemptive scheduler is being used.\n
   2. The users application creates tasks that run at the idle priority.\n
Tasks that share the same priority will time slice. Assuming none of the tasks get preempted, it might be assumed that each task of at a given priority will be allocated an equal amount of processing time - and if the shared priority is above the idle priority then this is indeed the case. </Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>0</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>true</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TIntgItem>
              <Name>Task Name Length</Name>
              <Symbol>TaskNameLength</Symbol>
              <Hint>The maximum permissible length of the descriptive name given to a task when the task is created. The length is specified in the number of characters including the NULL termination byte. (configMAX_TASK_NAME_LEN)</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>12</DefaultValue>
              <MinValue>1</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>true</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TIntgItem>
              <Name>Minimal Stack Size</Name>
              <Symbol>MinimalStackSize</Symbol>
              <Hint>The size of the stack used by the idle task (configMINIMAL_STACK_SIZE flag). Generally this should not be reduced from the value set in the FreeRTOSConfig.h file provided with the demo application for the port you are using. Note that the size is in stack units (portSTACK_TYPE), which is 4 bytes for a 32bit core like ColdFire and ARM/Kinetis and 1 byte for HCS08. Keep in mind that there is the IDLE task too which needs stack plus the task descriptor block.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>200</DefaultValue>
              <MinValue>1</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>true</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TIntgItem>
              <Name>Maximum Priorities</Name>
              <Symbol>MaxPriority</Symbol>
              <Hint>Each task is assigned a priority from 0 to ( configMAX_PRIORITIES - 1 ). configMAX_PRIORITIES is defined within FreeRTOSConfig.h and can be set on an application by application basis. The higher the value given to configMAX_PRIORITIES the more RAM the FreeRTOS kernel will consume. </Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>6</DefaultValue>
              <MinValue>1</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>true</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TIntgItem>
              <Name>Maximum Coroutine Priorities</Name>
              <Symbol>MaxCoroutinePriorities</Symbol>
              <Hint>Each co-routine is assigned a priority from 0 to ( configMAX_CO_ROUTINE_PRIORITIES - 1 ). configMAX_CO_ROUTINE_PRIORITIES is defined within FreeRTOSConfig.h and can be set on an application by application basis. The higher the value given to configMAX_CO_ROUTINE_PRIORITIES the more RAM the FreeRTOS kernel will consume. </Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>2</DefaultValue>
              <MinValue>1</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>true</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TEnumItem>
              <Name>Stackoverflow checking method</Name>
              <Symbol>StackOverflowCheckingMethodNumber</Symbol>
              <TypeSpec>typeStackOverflowMethod</TypeSpec>
              <Hint>Stack Overflow Detection - Method 1\n
It is likely that the stack will reach its greatest (deepest) value after the kernel has swapped the task out of the Running state because this is when the stack will contain the task context. At this point the kernel can check that the processor stack pointer remains within the valid stack space. The stack overflow hook function is called if the stack pointer contain a value that is outside of the valid stack range.\n
This method is quick but not guaranteed to catch all stack overflows. Set configCHECK_FOR_STACK_OVERFLOW to 1 to use this method only.\n
\n
Stack Overflow Detection - Method 2\n
When a task is first created its stack is filled with a known value. When swapping a task out of the Running state the kernel can check the last 16 bytes within the valid stack range to ensure that these known values have not been overwritten by the task or interrupt activity. The stack overflow hook function is called should any of these 16 bytes not remain at their initial value.\n
This method is less efficient than method one, but still fairly fast. It is very likely to catch stack overflows but is still not guaranteed to catch all overflows.\n
To use this method in combination with method 1 set configCHECK_FOR_STACK_OVERFLOW to 2. It is not possible to use only this method.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>0</DefaultIndex>
              <TextValueIndex>true</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
            </TEnumItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Cleanup Resources</Name>
              <Symbol>CleanupResources</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>This setting controls the INCLUDE_vTaskCleanUpResources define.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>0</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>true</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TBoolGrupItem>
              <Name>Tickless Idle Mode</Name>
              <Symbol>TicklessIdleModeEnabled</Symbol>
              <TypeSpec>typeEnaDis</TypeSpec>
              <Hint>If supported, a tickless idle mode is used for power reduction. See http://www.freertos.org/low-power-tickless-rtos.html</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description>Disabled</Description>
              <Expanded>No</Expanded>
              <DefaultValue>false</DefaultValue>
              <DefineSymbol>YES_NO</DefineSymbol>
              <IfDisabled>setNOTHING</IfDisabled>
              <Children>
                <GrupItem>
                  <TIntgItem>
                    <Name>Stopped Timer Compensation</Name>
                    <Symbol>StoppedTimerCompensation</Symbol>
                    <Hint>vPortSuppressTicksAndSleep() needs to stop the tick timer for a short time. This value compensates for the time delay. This value is assigned to configSTOPPED_TIMER_COMPENSATION in port.c</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>42</DefaultValue>
                    <MinValue>0</MinValue>
                    <MaxValue>-1</MaxValue>
                    <Bases>DEC</Bases>
                    <DefaultBase>DEC</DefaultBase>
                    <ExtraHintDisabled>false</ExtraHintDisabled>
                    <ChangeValueIntoRange>false</ChangeValueIntoRange>
                    <RuntimeProperty>false</RuntimeProperty>
                  </TIntgItem>
                </GrupItem>
                <GrupItem>
                  <TIntgItem>
                    <Name>Expected Idle Time (Ticks) before Sleep</Name>
                    <Symbol>ExpectedIdleTimeBeforeSleep</Symbol>
                    <Hint>Tickless mode will only be entered if the idle ticks are larger than this value. This defines the value for configEXPECTED_IDLE_TIME_BEFORE_SLEEP.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>2</DefaultValue>
                    <MinValue>2</MinValue>
                    <MaxValue>-1</MaxValue>
                    <Bases>DEC</Bases>
                    <DefaultBase>DEC</DefaultBase>
                    <ExtraHintDisabled>false</ExtraHintDisabled>
                    <ChangeValueIntoRange>false</ChangeValueIntoRange>
                    <RuntimeProperty>false</RuntimeProperty>
                  </TIntgItem>
                </GrupItem>
              </Children>
            </TBoolGrupItem>
          </GrupItem>
        </Children>
      </TGrupItem>
    </Property>
    <Property>
      <TGrupItem>
        <Name>Ticks</Name>
        <Symbol>TicksGroup</Symbol>
        <Hint>Group controlling how ticks are handled</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>Settings for the periodic tick timer</Description>
        <Expanded>Yes</Expanded>
        <Children>
          <GrupItem>
            <TIntgItem>
              <Name>Tick Rate (Hz)</Name>
              <Symbol>TickRateHz</Symbol>
              <Hint>The frequency of the RTOS tick interrupt.\n
\n
The tick interrupt is used to measure time. Therefore a higher tick frequency means time can be measured to a higher resolution. However, a high tick frequency also means that the kernel will use more CPU time so be less efficient. The RTOS demo applications all use a tick rate of 1000Hz. This is used to test the kernel and is higher than would normally be required.\n
\n
More than one task can share the same priority. The kernel will share processor time between tasks of the same priority by switching between the tasks during each RTOS tick. A high tick rate frequency will therefore also have the effect of reducing the 'time slice' given to each task. </Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>100</DefaultValue>
              <MinValue>1</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>true</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Use 16bit ticks</Name>
              <Symbol>Use16bitTicks</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>Time is measured in 'ticks' - which is the number of times the tick interrupt has executed since the kernel was started. The tick count is held in a variable of type portTickType.\n
Defining configUSE_16_BIT_TICKS as 1 causes portTickType to be defined (typedef'ed) as an unsigned 16bit type. Defining configUSE_16_BIT_TICKS as 0 causes portTickType to be defined (typedef'ed) as an unsigned 32bit type.\n
Using a 16 bit type will greatly improve performance on 8 and 16 bit architectures, but limits the maximum specifiable time period to 65535 'ticks'. Therefore, assuming a tick frequency of 250Hz, the maximum time a task can delay or block when a 16bit counter is used is 262 seconds, compared to 17179869 seconds when using a 32bit counter. </Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>1</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>false</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TBoolGrupItem>
              <Name>non-LDD Tick</Name>
              <Symbol>NonLDDTickGroup</Symbol>
              <TypeSpec>typeEnaDis</TypeSpec>
              <Hint>Group for classic non-LDD components</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description>Enabled</Description>
              <Expanded>Yes</Expanded>
              <DefaultValue>true</DefaultValue>
              <DefineSymbol>YES_NO</DefineSymbol>
              <IfDisabled>setNOTHING</IfDisabled>
              <Children>
                <GrupItem>
                  <TInhrItem>
                    <Name>Tick Counter</Name>
                    <Symbol>TickCntr</Symbol>
                    <TypeSpec>FreeRTOS\TickCntr</TypeSpec>
                    <Hint>Timer generating the ticks for the RTOS</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>false</EditLine>
                    <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
                    <DefaultIndex>-1</DefaultIndex>
                    <TextValueIndex>false</TextValueIndex>
                    <RuntimeProperty>false</RuntimeProperty>
                    <CanDelete>false</CanDelete>
                    <IconPopup>false</IconPopup>
                    <InhrBeanBaseName>TickCntr</InhrBeanBaseName>
                    <ShowInheritedMethodsEventsInPrjTree>true</ShowInheritedMethodsEventsInPrjTree>
                  </TInhrItem>
                </GrupItem>
              </Children>
            </TBoolGrupItem>
          </GrupItem>
          <GrupItem>
            <TBoolGrupItem>
              <Name>LDD Tick</Name>
              <Symbol>LDDTickGroup</Symbol>
              <TypeSpec>typeEnaDis</TypeSpec>
              <Hint>Group for Logical Device Drivers</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description>Enabled</Description>
              <Expanded>Yes</Expanded>
              <DefaultValue>true</DefaultValue>
              <DefineSymbol>YES_NO</DefineSymbol>
              <IfDisabled>setNOTHING</IfDisabled>
              <Children>
                <GrupItem>
                  <TInhrItem>
                    <Name>Tick Timer</Name>
                    <Symbol>TickTimerLDD</Symbol>
                    <TypeSpec>FreeRTOS\TickLDD</TypeSpec>
                    <Hint>Tick Timer Interrupt</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>false</EditLine>
                    <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
                    <DefaultIndex>-1</DefaultIndex>
                    <TextValueIndex>false</TextValueIndex>
                    <RuntimeProperty>false</RuntimeProperty>
                    <CanDelete>false</CanDelete>
                    <IconPopup>false</IconPopup>
                    <InhrBeanBaseName>RTOSTICKLDD</InhrBeanBaseName>
                    <ShowInheritedMethodsEventsInPrjTree>true</ShowInheritedMethodsEventsInPrjTree>
                  </TInhrItem>
                </GrupItem>
              </Children>
            </TBoolGrupItem>
          </GrupItem>
        </Children>
      </TGrupItem>
    </Property>
    <Property>
      <TGrupItem>
        <Name>Queues</Name>
        <Symbol>QueuesGroup</Symbol>
        <Hint>This group defines how queues are handled</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>Settings for Queues</Description>
        <Expanded>Yes</Expanded>
        <Children>
          <GrupItem>
            <TIntgItem>
              <Name>Queue Registry Size</Name>
              <Symbol>QueueRegistrySize</Symbol>
              <Hint>The queue registry has two purposes, both of which are associated with kernel aware debugging:\n
   1. It allows a textual name to be associated with a queue for easy queue identification within a debugging GUI.\n
   2. It contains the information required by a debugger to locate each registered queue and semaphore.\n
The queue registry has no purpose unless you are using a kernel aware debugger.\n
configQUEUE_REGISTRY_SIZE defines the maximum number of queues and semaphores that can be registered. Only those queues and semaphores that you want to view using a kernel aware debugger need be registered. See the API reference documentation for vQueueAddToRegistry() and vQueueUnregisterQueue() for more information.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>0</DefaultValue>
              <MinValue>0</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>true</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
        </Children>
      </TGrupItem>
    </Property>
    <Property>
      <TGrupItem>
        <Name>Semaphores and Mutexes</Name>
        <Symbol>MutexGroup</Symbol>
        <Hint>This group defines how semaphores and mutexes are handled</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>Settings for Mutex and Semaphore</Description>
        <Expanded>Yes</Expanded>
        <Children>
          <GrupItem>
            <TBoolItem>
              <Name>Use Mutexes</Name>
              <Symbol>UseMutexes</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>Set to 1 to include mutex functionality in the build, or 0 to omit mutex functionality from the build. Readers should familiarise themselves with the differences between mutexes and binary semaphores in relation to the FreeRTOS.org functionality.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>0</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>true</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Use Recursive Mutexes</Name>
              <Symbol>UseRecursiveMutexes</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>Set to 1 to include recursive mutex functionality in the build, or 0 to omit recursive mutex functionality from the build. This affects if xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() are available or not.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>0</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>true</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
        </Children>
      </TGrupItem>
    </Property>
    <Property>
      <TBoolGrupItem>
        <Name>Timers</Name>
        <Symbol>TimersEnabled</Symbol>
        <TypeSpec>typeEnaDis</TypeSpec>
        <Hint>Group configuring the software timers</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>Disabled</Description>
        <Expanded>No</Expanded>
        <DefaultValue>false</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <Children>
          <GrupItem>
            <TIntgItem>
              <Name>Priority</Name>
              <Symbol>TimerTaskPriority</Symbol>
              <Hint>Priority of the software timer task (configTIMER_TASK_PRIORITY)</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>2</DefaultValue>
              <MinValue>0</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>false</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TIntgItem>
              <Name>Queue Length</Name>
              <Symbol>TimerTaskQueueLength</Symbol>
              <Hint>Sets configTIMER_QUEUE_LENGTH</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>10</DefaultValue>
              <MinValue>0</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>false</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TIntgItem>
              <Name>Stack Depth</Name>
              <Symbol>TimerTaskStackDepth</Symbol>
              <Hint>configures the value of configTIMER_TASK_STACK_DEPTH which defines the stack size for the timer task</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>100</DefaultValue>
              <MinValue>1</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>false</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
        </Children>
      </TBoolGrupItem>
    </Property>
    <Property>
      <TGrupItem>
        <Name>Memory</Name>
        <Symbol>MemoryGroup</Symbol>
        <Hint>This group controls the heap and memory settings</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>Settings for the memory and heap allocation</Description>
        <Expanded>Yes</Expanded>
        <Children>
          <GrupItem>
            <TEnumItem>
              <Name>Memory Allocation Scheme</Name>
              <Symbol>MemoryScheme</Symbol>
              <TypeSpec>typeMemAllocScheme</TypeSpec>
              <Hint>Scheme 1:\n
This is the simplest scheme of all. It does not permit memory to be freed once it has been allocated, but despite this is suitable for a surprisingly large number of applications.\n
The algorithm simply subdivides a single array into smaller blocks as requests for RAM are made. The total size of the array is set by the definition configTOTAL_HEAP_SIZE - which is defined in FreeRTOSConfig.h.\n
This scheme:\n
    * Can be used if your application never deletes a task or queue (no calls to vTaskDelete() or vQueueDelete() are ever made).\n
    * Is always deterministic (always takes the same amount of time to return a block).\n
heap_1.c is suitable for a lot of small real time systems provided that all tasks and queues are created before the kernel is started.\n
\n
Scheme 2:\n
This scheme uses a best fit algorithm and, unlike scheme 1, allows previously allocated blocks to be freed. It does not however combine adjacent free blocks into a single large block.\n
Again the total amount of available RAM is set by the definition configTOTAL_HEAP_SIZE - which is defined in FreeRTOSConfig.h.\n
This scheme:\n
    * Can be used even when the application repeatedly calls vTaskCreate()/vTaskDelete() or vQueueCreate()/vQueueDelete() (causing multiple calls to pvPortMalloc() and vPortFree()).\n
    * Should not be used if the memory being allocated and freed is of a random size - this would only be the case if tasks being deleted each had a different stack depth, or queues being deleted were of different lengths.\n
    * Could possible result in memory fragmentation problems should your application create blocks of queues and tasks in an unpredictable order. This would be unlikely for nearly all applications but should be kept in mind.\n
    * Is not deterministic - but is also not particularly inefficient.\n
heap_2.c is suitable for most small real time systems that have to dynamically create tasks.\n
\n
Scheme 3:\n
This is just a wrapper for the standard malloc() and free() functions. It makes them thread safe.\n
This scheme:\n
    * Requires the linker to setup a heap, and the compiler library to provide malloc() and free() implementations.\n
    * Is not deterministic.\n
    * Will probably considerably increase the kernel code size.\n
\n
Scheme 4:\n
This scheme uses a first fit algorithm and, unlike scheme 2, does combine adjacent free memory blocks into a single large block (it does include a coalescence algorithm). The total amount of available heap space is set by configTOTAL_HEAP_SIZE - which is defined in FreeRTOSConfig.h. The xPortGetFreeHeapSize() API function returns the total amount of heap space that remains unallocated (allowing the configTOTAL_HEAP_SIZE setting to be optimised), but does not provided information on how the unallocated memory is fragmented into smaller blocks.\n
This implementation:\n
   * Can be used even when the application repeatedly deletes tasks, queues, semaphores, mutexes, etc..\n
   * Is much less likely than the heap_2 implementation to result in a heap space that is badly fragmented into multiple small blocks - even when the memory being allocated and freed is of random size.\n
   * Is not deterministic - but is much more efficient that most standard C library malloc implementations.\n
heap_4.c is particularly useful for applications that want to use the portable layer memory allocation schemes directly in the application code (rather than just indirectly by calling API functions that themselves call pvPortMalloc() and vPortFree()). </Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>1</DefaultIndex>
              <TextValueIndex>true</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
            </TEnumItem>
          </GrupItem>
          <GrupItem>
            <TBoolGrupItem>
              <Name>User Heap Section</Name>
              <Symbol>UserHeapSectionEnabled</Symbol>
              <TypeSpec>typeEnaDis</TypeSpec>
              <Hint>An optional user section attribute can be provided to place the heap into a user section. This is for example needed for the Kinetis K series where the RAM area is splitted. With this, e.g.  __attribute__((section (".m_data_20000000"))) can be specified for the heap object in heap.c</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description>Disabled</Description>
              <Expanded>No</Expanded>
              <DefaultValue>false</DefaultValue>
              <DefineSymbol>YES_NO</DefineSymbol>
              <IfDisabled>setNOTHING</IfDisabled>
              <Children>
                <GrupItem>
                  <TStrgItem>
                    <Name>Heap Section Name</Name>
                    <Symbol>HeapSectionName</Symbol>
                    <Hint>The following will be added to the heap variable: __attribute__((section ("sectionName")))</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>.m_data_20000000</DefaultValue>
                    <StrDefine>nothing</StrDefine>
                    <MinLength>0</MinLength>
                    <MaxLength>-1</MaxLength>
                  </TStrgItem>
                </GrupItem>
              </Children>
            </TBoolGrupItem>
          </GrupItem>
          <GrupItem>
            <TIntgItem>
              <Name>Total Heap Size</Name>
              <Symbol>TotalHeapSize</Symbol>
              <Hint>The total amount of RAM available to the kernel. This value is used by the memory allocation schemes.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>2048</DefaultValue>
              <MinValue>1</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC HEX</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>true</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
        </Children>
      </TGrupItem>
    </Property>
    <Property>
      <TBoolGrupItem>
        <Name>Command Interpreter</Name>
        <Symbol>CommandInterpreterEnabled</Symbol>
        <TypeSpec>typeEnaDis</TypeSpec>
        <Hint>Settings for the Command Interpreter. Earlier FreeRTOS included an open source command interpreter, now this has moved to a non-free-of-charge FreeRTOS+ version. This port includes for compatibility the original and free version of it.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>Disabled</Description>
        <Expanded>Yes</Expanded>
        <DefaultValue>false</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <Children>
          <GrupItem>
            <TIntgItem>
              <Name>Output Buffer Size</Name>
              <Symbol>CommandIntMaxOutputSize</Symbol>
              <Hint>Buffer size into which command outputs can be written. This defines configCOMMAND_INT_MAX_OUTPUT_SIZE</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>32</DefaultValue>
              <MinValue>1</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>false</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
        </Children>
      </TBoolGrupItem>
    </Property>
    <Property>
      <TGrupItem>
        <Name>RTOS Adaptor</Name>
        <Symbol>RTOSAdaptorGrp</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>Contains the RTOS specific settings. RTOS adaptor is a part of RTOS component which handles the integration of HAL into specific RTOS.</Hint>
        <ItemLevel>@ HIDDEN @</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>Configures the RTOS adapter settings</Description>
        <Expanded>Yes</Expanded>
        <Children>
          <GrupItem>
            <TGrupItem>
              <Name>Memory allocation</Name>
              <Symbol>MemoryAllocationGroup</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>Definition of the RTOS API which provides the memory allocation functionality for HAL driver code.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description>Configures how memory is allocated and deallocated.</Description>
              <Expanded>Yes</Expanded>
              <Children>
                <GrupItem>
                  <TBoolGrupItem>
                    <Name>User function for memory allocation</Name>
                    <Symbol>hasUserMallocFun</Symbol>
                    <TypeSpec>typeYesNo</TypeSpec>
                    <Hint>The memory allocation function should allocate the specified number of bytes of memory and return the address of the allocated space. The allocated memory area type should be suitable for usage by RTOS component. If there is an error, it should return NULL pointer.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <BoldName>true</BoldName>
                    <EditLine>false</EditLine>
                    <Description>no</Description>
                    <Expanded>No</Expanded>
                    <DefaultValue>false</DefaultValue>
                    <DefineSymbol>YES_NO</DefineSymbol>
                    <IfDisabled>setNOTHING</IfDisabled>
                    <Children>
                      <GrupItem>
                        <TStrgItem>
                          <Name>User function name</Name>
                          <Symbol>userMallocFunName</Symbol>
                          <Hint>The name of the user function (see above for description).</Hint>
                          <ItemLevel>BASIC</ItemLevel>
                          <EditLine>true</EditLine>
                          <DefaultValue>malloc</DefaultValue>
                          <StrDefine>nothing</StrDefine>
                          <MinLength>0</MinLength>
                          <MaxLength>-1</MaxLength>
                        </TStrgItem>
                      </GrupItem>
                    </Children>
                  </TBoolGrupItem>
                </GrupItem>
                <GrupItem>
                  <TBoolGrupItem>
                    <Name>User function for memory deallocation</Name>
                    <Symbol>hasUserDeallocFun</Symbol>
                    <TypeSpec>typeYesNo</TypeSpec>
                    <Hint>The memory deallocation function should free the memory area allocated by the memory allocation function. The function can be called only for areas allocated by a pair memory allocation function (see property hasUserMallocFun User function for memory allocation.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <BoldName>true</BoldName>
                    <EditLine>false</EditLine>
                    <Description>no</Description>
                    <Expanded>No</Expanded>
                    <DefaultValue>false</DefaultValue>
                    <DefineSymbol>YES_NO</DefineSymbol>
                    <IfDisabled>setNOTHING</IfDisabled>
                    <Children>
                      <GrupItem>
                        <TStrgItem>
                          <Name>User function name</Name>
                          <Symbol>userDeallocFunName</Symbol>
                          <Hint>The name of the user function (see above for description).</Hint>
                          <ItemLevel>BASIC</ItemLevel>
                          <EditLine>true</EditLine>
                          <DefaultValue>free</DefaultValue>
                          <StrDefine>nothing</StrDefine>
                          <MinLength>0</MinLength>
                          <MaxLength>-1</MaxLength>
                        </TStrgItem>
                      </GrupItem>
                    </Children>
                  </TBoolGrupItem>
                </GrupItem>
              </Children>
            </TGrupItem>
          </GrupItem>
          <GrupItem>
            <TGrupItem>
              <Name>Critical section</Name>
              <Symbol>CriticalSectionGroup</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>Definition of the RTOS API which provides the critical section handling for HAL driver code.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description>Configures how critical sections are handled.</Description>
              <Expanded>Yes</Expanded>
              <Children>
                <GrupItem>
                  <TBoolGrupItem>
                    <Name>User function for entering critical section</Name>
                    <Symbol>hasUserEnterCriticalFun</Symbol>
                    <TypeSpec>typeYesNo</TypeSpec>
                    <Hint>The open critical section function should introduce the code what cannot be interrupted by the ISRs. Such function can be also called from ISRs and/or within context where ISRs are already disabled. In this situation the function has no effect (except that the pair call to critical section close function will be also ignored - see property hasUserExitCriticalFun. The function has no parameters and returns no value.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <BoldName>true</BoldName>
                    <EditLine>false</EditLine>
                    <Description>no</Description>
                    <Expanded>No</Expanded>
                    <DefaultValue>false</DefaultValue>
                    <DefineSymbol>YES_NO</DefineSymbol>
                    <IfDisabled>setNOTHING</IfDisabled>
                    <Children>
                      <GrupItem>
                        <TStrgItem>
                          <Name>User function name</Name>
                          <Symbol>userEnterCriticalFunName</Symbol>
                          <Hint>The name of the user function (see above for description).</Hint>
                          <ItemLevel>BASIC</ItemLevel>
                          <EditLine>true</EditLine>
                          <DefaultValue>EnterCritical</DefaultValue>
                          <StrDefine>nothing</StrDefine>
                          <MinLength>0</MinLength>
                          <MaxLength>-1</MaxLength>
                        </TStrgItem>
                      </GrupItem>
                    </Children>
                  </TBoolGrupItem>
                </GrupItem>
                <GrupItem>
                  <TBoolGrupItem>
                    <Name>User function for exiting critical section</Name>
                    <Symbol>hasUserExitCriticalFun</Symbol>
                    <TypeSpec>typeYesNo</TypeSpec>
                    <Hint>The close critical section function should terminate the code what cannot be interrupted by the ISRs. Such function need always to have a pair open critical section call (see property hasUserEnterCriticalFun. If call to the pair open critical section was ignored, the respective close should be also ignored. The function has no parameters and returns no value.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <BoldName>true</BoldName>
                    <EditLine>false</EditLine>
                    <Description>no</Description>
                    <Expanded>No</Expanded>
                    <DefaultValue>false</DefaultValue>
                    <DefineSymbol>YES_NO</DefineSymbol>
                    <IfDisabled>setNOTHING</IfDisabled>
                    <Children>
                      <GrupItem>
                        <TStrgItem>
                          <Name>User function name</Name>
                          <Symbol>userExitCriticalFunName</Symbol>
                          <Hint>The name of the user function (see above for description).</Hint>
                          <ItemLevel>BASIC</ItemLevel>
                          <EditLine>true</EditLine>
                          <DefaultValue>ExitCritical</DefaultValue>
                          <StrDefine>nothing</StrDefine>
                          <MinLength>0</MinLength>
                          <MaxLength>-1</MaxLength>
                        </TStrgItem>
                      </GrupItem>
                    </Children>
                  </TBoolGrupItem>
                </GrupItem>
              </Children>
            </TGrupItem>
          </GrupItem>
        </Children>
      </TGrupItem>
    </Property>
    <Property>
      <TBoolGrupItem>
        <Name>Shell</Name>
        <Symbol>ShellEnabled</Symbol>
        <TypeSpec>typeEnaDis</TypeSpec>
        <Hint>If shell support shall be added or not</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>Disabled</Description>
        <Expanded>No</Expanded>
        <DefaultValue>false</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <Children>
          <GrupItem>
            <TInhrLinkItem>
              <Name>Shell</Name>
              <Symbol>Shell</Symbol>
              <TypeSpec>FreeRTOS\Shell</TypeSpec>
              <Hint>Interface to shell</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <DefaultValue/>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <SortStyle/>
            </TInhrLinkItem>
          </GrupItem>
        </Children>
      </TBoolGrupItem>
    </Property>
  </PropertyList>
  <MethodList>
    <Method>
      <TMthdItem>
        <Name>xTaskCreate</Name>
        <Symbol>xTaskCreate</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Create a new task and add it to the list of tasks that are ready to run.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portBASE_TYPE</ReturnType>
        <RetHint>pdPASS if the task was successfully created and added to a ready list, otherwise an error code defined in the file projdefs.h</RetHint>
        <ParamCount>6</ParamCount>
        <Parameter>
          <ParName>pvTaskCode</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to the task entry function. Tasks must be implemented to never return (i.e. continuous loop).</ParHint>
          <ParUserDeclaration>pdTASK_CODE pvTaskCode</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>pcName</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A descriptive name for the task. This is mainly used to facilitate debugging. Max length defined by configMAX_TASK_NAME_LEN.</ParHint>
          <ParUserDeclaration>const portCHAR * const pcName</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>usStackDepth</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The size of the task stack specified as the number of variables the stack can hold - not the number of bytes. For example, if the stack is 16 bits wide and usStackDepth is defined as 100, 200 bytes will be allocated for stack storage. The stack depth multiplied by the stack width must not exceed the maximum value that can be contained in a variable of type size_t.</ParHint>
          <ParUserDeclaration>unsigned portSHORT usStackDepth</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>pvParameters</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer that will be used as the parameter for the task being created.</ParHint>
          <ParUserDeclaration>void *pvParameters</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>uxPriority</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The priority at which the task should run.</ParHint>
          <ParUserDeclaration>unsigned portBASE_TYPE uxPriority</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>pvCreatedTask</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Used to pass back a handle by which the created task can be referenced.</ParHint>
          <ParUserDeclaration>xTaskHandle *pvCreatedTask</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portBASE_TYPE #M#_#C#(pdTASK_CODE pvTaskCode, const portCHAR * const pcName, unsigned portSHORT usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pvCreatedTask)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTaskDelete</Name>
        <Symbol>vTaskDelete</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Remove a task from the RTOS real time kernels management. The task being deleted will be removed from all ready, blocked, suspended and event lists.\n
NOTE: The idle task is responsible for freeing the kernel allocated memory from tasks that have been deleted. It is therefore important that the idle task is not starved of microcontroller processing time if your application makes any calls to vTaskDelete (). Memory allocated by the task code is not automatically freed, and should be freed before the task is deleted.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>pxTask</ParName>
          <ParType>xTaskHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the task to be deleted. Passing NULL will cause the calling task to be deleted.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(xTaskHandle pxTask)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTaskStartScheduler</Name>
        <Symbol>vTaskStartScheduler</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Starts the real time kernel tick processing. After calling the kernel has control over which tasks are executed and when.\n
The idle task is created automatically when vTaskStartScheduler() is called.\n
If vTaskStartScheduler() is successful the function will not return until an executing task calls vTaskEndScheduler(). The function might fail and return immediately if there is insufficient RAM available for the idle task to be created.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTaskEndScheduler</Name>
        <Symbol>vTaskEndScheduler</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Stops the real time kernel tick. All created tasks will be automatically deleted and multitasking (either preemptive or cooperative) will stop. Execution then resumes from the point where vTaskStartScheduler() was called, as if vTaskStartScheduler() had just returned.\n
\n
See the demo application file main. c in the demo/PC directory for an example that uses vTaskEndScheduler ().\n
\n
vTaskEndScheduler () requires an exit function to be defined within the portable layer (see vPortEndScheduler () in port. c for the PC port). This performs hardware specific operations such as stopping the kernel tick.\n
\n
vTaskEndScheduler () will cause all of the resources allocated by the kernel to be freed - but will not free resources allocated by application tasks.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTaskSuspend</Name>
        <Symbol>vTaskSuspend</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Suspend any task. When suspended a task will never get any microcontroller processing time, no matter what its priority. Calls to vTaskSuspend are not accumulative - i.e. calling vTaskSuspend() twice on the same task still only requires one call to vTaskResume() to ready the suspended task.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>pxTaskToSuspend</ParName>
          <ParType>xTaskHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Handle to the task being suspended. Passing a NULL handle will cause the calling task to be suspended.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(xTaskHandle pxTaskToSuspend)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTaskSuspendAll</Name>
        <Symbol>vTaskSuspendAll</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Suspends all real time kernel activity while keeping interrupts (including the kernel tick) enabled.\n
After calling vTaskSuspendAll () the calling task will continue to execute without risk of being swapped out until a call to xTaskResumeAll () has been made.\n
API functions that have the potential to cause a context switch (for example, vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler is suspended.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTaskResume</Name>
        <Symbol>vTaskResume</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Resumes a suspended task. A task that has been suspended by one of more calls to vTaskSuspend() will be made available for running again by a single call to vTaskResume().</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>pxTaskToResume</ParName>
          <ParType>xTaskHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Handle to the task being readied.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(xTaskHandle pxTaskToResume)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTaskResumeAll</Name>
        <Symbol>xTaskResumeAll</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Resumes real time kernel activity following a call to vTaskSuspendAll (). After a call to xTaskSuspendAll () the kernel will take control of which task is executing at any time.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portBASE_TYPE</ReturnType>
        <RetHint>If resuming the scheduler caused a context switch then pdTRUE is returned, otherwise pdFALSE is returned.</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portBASE_TYPE #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTaskResumeFromISR</Name>
        <Symbol>xTaskResumeFromISR</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>An implementation of vTaskResume() that can be called from within an ISR. A task that has been suspended by one of more calls to vTaskSuspend() will be made available for running again by a single call to xTaskResumeFromISR().</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portBASE_TYPE</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>pxTaskToResume</ParName>
          <ParType>xTaskHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Handle to the task being readied.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portBASE_TYPE #M#_#C#(xTaskHandle pxTaskToResume)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTaskStepTick</Name>
        <Symbol>vTaskStepTick</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint> If the RTOS is configured to use tickless idle functionality then the tick interrupt will be stopped, and the microcontroller placed into a low power state, whenever the Idle task is the only task able to execute. Upon exiting the low power state the tick count value must be corrected to account for the time that passed while it was stopped.\n
\n
If a FreeRTOS port includes a default portSUPPRESS_TICKS_AND_SLEEP() implementation, then vTaskStepTick() is used internally to ensure the correct tick count value is maintained. vTaskStepTick() is a public API function to allow the default portSUPPRESS_TICKS_AND_SLEEP() implementation to be overridden, and for a portSUPPRESS_TICKS_AND_SLEEP() to be provided if the port being used does not provide a default. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xTicksToJump</ParName>
          <ParType>portTickType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The number of RTOS ticks that have passed since the tick interrupt was stopped. For correct operation the parameter must be less than or equal to the portSUPPRESS_TICKS_AND_SLEEP() parameter. </ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(portTickType xTicksToJump)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>taskYIELD</Name>
        <Symbol>taskYIELD</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro for forcing a context switch.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>taskENTER_CRITICAL</Name>
        <Symbol>taskENTER_CRITICAL</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro to mark the start of a critical code region. Preemptive context switches cannot occur when in a critical region.\n
\n
NOTE: This may alter the stack (depending on the portable implementation) so must be used with care!</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>taskEXIT_CRITICAL</Name>
        <Symbol>taskEXIT_CRITICAL</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro to mark the end of a critical code region. Preemptive context switches cannot occur when in a critical region.\n
\n
NOTE: This may alter the stack (depending on the portable implementation) so must be used with care!</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>taskDISABLE_INTERRUPTS</Name>
        <Symbol>taskDISABLE_INTERRUPTS</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro to disable all maskable interrupts.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>taskENABLE_INTERRUPTS</Name>
        <Symbol>taskENABLE_INTERRUPTS</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro to enable microcontroller interrupts.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTaskDelay</Name>
        <Symbol>vTaskDelay</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Delay a task for a given number of ticks. The actual time that the task remains blocked depends on the tick rate. The constant portTICK_RATE_MS can be used to calculate real time from the tick rate - with the resolution of one tick period.\n
\n
vTaskDelay() specifies a time at which the task wishes to unblock relative to the time at which vTaskDelay() is called. For example, specifying a block period of 100 ticks will cause the task to unblock 100 ticks after vTaskDelay() is called. vTaskDelay() does not therefore provide a good method of controlling the frequency of a cyclical task as the path taken through the code, as well as other task and interrupt activity, will effect the frequency at which vTaskDelay() gets called and therefore the time at which the task next executes. See vTaskDelayUntil() for an alternative API function designed to facilitate fixed frequency execution. It does this by specifying an absolute time (rather than a relative time) at which the calling task should unblock. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xTicksToDelay</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The amount of time, in tick periods, that the calling task should block.</ParHint>
          <ParUserDeclaration>portTickType xTicksToDelay</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(portTickType xTicksToDelay)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTaskDelayUntil</Name>
        <Symbol>vTaskDelayUntil</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Delay a task until a specified time. This function can be used by cyclical tasks to ensure a constant execution frequency.\n
\n
This function differs from vTaskDelay() in one important aspect: vTaskDelay() specifies a time at which the task wishes to unblock relative to the time at which vTaskDelay() is called, whereas vTaskDelayUntil() specifies an absolute time at which the task wishes to unblock.\n
\n
vTaskDelay() will cause a task to block for the specified number of ticks from the time vTaskDelay() is called. It is therefore difficult to use vTaskDelay() by itself to generate a fixed execution frequency as the time between a task unblocking following a call to vTaskDelay() and that task next calling vTaskDelay() may not be fixed [the task may take a different path though the code between calls, or may get interrupted or preempted a different number of times each time it executes].\n
\n
Whereas vTaskDelay() specifies a wake time relative to the time at which the function is called, vTaskDelayUntil() specifies the absolute (exact) time at which it wishes to unblock.\n
\n
It should be noted that vTaskDelayUntil() will return immediately (without blocking) if it is used to specify a wake time that is already in the past. Therefore a task using vTaskDelayUntil() to execute periodically will have to re-calculate its required wake time if the periodic execution is halted for any reason (for example, the task is temporarily placed into the Suspended state) causing the task to miss one or more periodic executions. This can be detected by checking the variable passed by reference as the pxPreviousWakeTime parameter against the current tick count. This is however not necessary under most usage scenarios.\n
\n
The constant portTICK_RATE_MS can be used to calculate real time from the tick rate - with the resolution of one tick period.\n
\n
This function must not be called while the scheduler has been suspended by a call to vTaskSuspendAll(). </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>pxPreviousWakeTime</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to a variable that holds the time at which the task was last unblocked. The variable must be initialised with the current time prior to its first use (see the example below). Following this the variable is automatically updated within vTaskDelayUntil(). </ParHint>
          <ParUserDeclaration>portTickType *pxPreviousWakeTime</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>xTimeIncrement</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The cycle time period. The task will be unblocked at time (*pxPreviousWakeTime + xTimeIncrement). Calling vTaskDelayUntil with the same xTimeIncrement parameter value will cause the task to execute with a fixed interval period. </ParHint>
          <ParUserDeclaration>portTickType xTimeIncrement</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(portTickType *pxPreviousWakeTime, portTickType xTimeIncrement)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>uxTaskPriorityGet</Name>
        <Symbol>uxTaskPriorityGet</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Obtain the priority of any task.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>unsigned_portBASE_TYPE</ReturnType>
        <RetHint>The priority of pxTask.</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>pxTask</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Handle of the task to be queried. Passing a NULL handle results in the priority of the calling task being returned.</ParHint>
          <ParUserDeclaration>xTaskHandle pxTask</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>unsigned_portBASE_TYPE #M#_#C#(xTaskHandle pxTask)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTaskPrioritySet</Name>
        <Symbol>vTaskPrioritySet</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Set the priority of any task.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>pxTask</ParName>
          <ParType>xTaskHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Handle to the task for which the priority is being set. Passing a NULL handle results in the priority of the calling task being set.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>uxNewPriority</ParName>
          <ParType>unsigned_portBASE_TYPE</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The priority to which the task will be set.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(xTaskHandle pxTask, unsigned_portBASE_TYPE uxNewPriority)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTaskGetTickCount</Name>
        <Symbol>xTaskGetTickCount</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Return the count of ticks since vTaskStartScheduler was called.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portTickType</ReturnType>
        <RetHint>tick count</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portTickType #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTaskGetTickCountFromISR</Name>
        <Symbol>xTaskGetTickCountFromISR</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>A version of xTaskGetTickCount() that can be called from an ISR. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portTickType</ReturnType>
        <RetHint>The count of ticks since vTaskStartScheduler was called. </RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portTickType #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xSemaphoreCreateRecursiveMutex</Name>
        <Symbol>xSemaphoreCreateRecursiveMutex</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro that implements a recursive mutex by using the existing queue mechanism.\n
Mutexes created using this macro can be accessed using the xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros.  The  xSemaphoreTake() and xSemaphoreGive() macros should not be used.\n
A mutex used recursively can be 'taken' repeatedly by the owner. The mutex doesn't become available again until the owner has called xSemaphoreGiveRecursive() for each successful 'take' request.  For example, if a task successfully 'takes' the same mutex 5 times then the mutex will not be available to any other task until it has also  'given' the mutex back exactly five times.\n
This type of semaphore uses a priority inheritance mechanism so a task 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the semaphore it is no longer required. Mutex type semaphores cannot be used from within interrupt service routines.\n
See vSemaphoreCreateBinary() for an alternative implementation that can be used for pure synchronisation (where one task or interrupt always 'gives' the semaphore and another always 'takes' the semaphore) and from within interrupt service routines.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>xSemaphoreHandle</ReturnType>
        <RetHint>Handle to the created mutex semaphore.  Should be of type  xSemaphoreHandle.</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>xSemaphoreHandle #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xSemaphoreTakeRecursive</Name>
        <Symbol>xSemaphoreTakeRecursive</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro to recursively obtain, or 'take', a mutex type semaphore. The mutex must have previously been created using a call to xSemaphoreCreateRecursiveMutex();\n
This macro must not be used on mutexes created using xSemaphoreCreateMutex(). A mutex used recursively can be 'taken' repeatedly by the owner. The mutex doesn't become available again until the owner has called xSemaphoreGiveRecursive() for each successful 'take' request.  For example, if a task successfully 'takes' the same mutex 5 times then the mutex will not be available to any other task until it has also  'given' the mutex back exactly five times.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>Boolean</ReturnType>
        <RetHint>Returns pdTRUE if the semaphore was obtained.  pdFALSE if xBlockTime expired without the semaphore becoming available.</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>xMutex</ParName>
          <ParType>xSemaphoreHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A handle to the mutex being obtained.  This is the handle returned by xSemaphoreCreateRecursiveMutex();</ParHint>
        </Parameter>
        <Parameter>
          <ParName>xBlockTime</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The time in ticks to wait for the semaphore to become available.  The macro portTICK_RATE_MS can be used to convert this to a real time.  A block time of zero can be used to poll the semaphore.  If the task already owns the semaphore then xSemaphoreTakeRecursive() will return immediately no matter what the value of xBlockTime.</ParHint>
          <ParUserDeclaration>portTickType xBlockTime</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>bool #M#_#C#(xSemaphoreHandle xMutex, portTickType xBlockTime)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xSemaphoreGiveRecursive</Name>
        <Symbol>xSemaphoreGiveRecursive</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro to recursively release, or 'give', a mutex type semaphore. The mutex must have previously been created using a call to xSemaphoreCreateRecursiveMutex();\n
This macro must not be used on mutexes created using xSemaphoreCreateMutex(). A mutex used recursively can be 'taken' repeatedly by the owner. The mutex doesn't become available again until the owner has called xSemaphoreGiveRecursive() for each successful 'take' request.  For example, if a task successfully 'takes' the same mutex 5 times then the mutex will not be available to any other task until it has also  'given' the mutex back exactly five times.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>Boolean</ReturnType>
        <RetHint>Returns pdTRUE if the semaphore was given.</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xMutex</ParName>
          <ParType>xSemaphoreHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A handle to the mutex being released, or 'given'.  This is the handle returned by xSemaphoreCreateMutex();</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>bool #M#_#C#(xSemaphoreHandle xMutex)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xSemaphoreCreateMutex</Name>
        <Symbol>xSemaphoreCreateMutex</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro that creates a mutex semaphore by using the existing queue mechanism.\n
\n
Mutexes created using this macro can be accessed using the xSemaphoreTake() and xSemaphoreGive() macros. The xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros should not be used.\n
\n
Mutexes and binary semaphores are very similar but have some subtle differences: Mutexes include a priority inheritance mechanism, binary semaphores do not. This makes binary semaphores the better choice for implementing synchronisation (between tasks or between tasks and an interrupt), and mutexes the better choice for implementing simple mutual exclusion.\n
\n
The priority of a task that 'takes' a mutex can potentially be raised if another task of higher priority attempts to obtain the same mutex. The task that owns the mutex 'inherits' the priority of the task attempting to 'take' the same mutex. This means the mutex must always be 'given' back - otherwise the higher priority task will never be able to obtain the mutex, and the lower priority task will never 'disinherit' the priority. An example of a mutex being used to implement mutual exclusion is provided on the xSemaphoreTake() documentation page.\n
\n
A binary semaphore need not be given back once obtained, so task synchronisation can be implemented by one task/interrupt continuously 'giving' the semaphore while another continuously 'takes' the semaphore. This is demonstrated by the sample code on the xSemaphoreGiveFromISR() documentation page.\n
\n
Both mutex and binary semaphores are assigned to variables of type xSemaphoreHandle and can be used in any API function that takes a parameter of this type. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>xSemaphoreHandle</ReturnType>
        <RetHint>Handle to the created mutex semaphore.  Should be of type  xSemaphoreHandle.</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>xSemaphoreHandle #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xSemaphoreTake</Name>
        <Symbol>xSemaphoreTake</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro to obtain a semaphore. The semaphore must have previously been created with a call to vSemaphoreCreateBinary(), xSemaphoreCreateMutex() or xSemaphoreCreateCounting().\n
\n
This macro must not be called from an ISR. xQueueReceiveFromISR() can be used to take a semaphore from within an interrupt if required, although this would not be a normal operation. Semaphores use queues as their underlying mechanism, so functions are to some extent interoperable.\n
\n
xSemaphoreTake() is part of the fully featured intertask communications API. xSemaphoreAltTake() is the alternative API equivalent. Both versions require the same parameters and return the same values.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>Boolean</ReturnType>
        <RetHint>Returns pdTRUE if the semaphore was obtained.  pdFALSE if xBlockTime expired without the semaphore becoming available.</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>xMutex</ParName>
          <ParType>xSemaphoreHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A handle to the mutex being obtained.  This is the handle returned by xSemaphoreCreateMutex();</ParHint>
        </Parameter>
        <Parameter>
          <ParName>xBlockTime</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The time in ticks to wait for the semaphore to become available.  The macro portTICK_RATE_MS can be used to convert this to a real time.  A block time of zero can be used to poll the semaphore.  If the task already owns the semaphore then xSemaphoreTakeRecursive() will return immediately no matter what the value of xBlockTime. Specifying the block time as portMAX_DELAY will cause the task to block indefinitely (without a timeout).</ParHint>
          <ParUserDeclaration>portTickType xBlockTime</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>bool #M#_#C#(xSemaphoreHandle xMutex, portTickType xBlockTime)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xSemaphoreGive</Name>
        <Symbol>xSemaphoreGive</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro to release a semaphore. The semaphore must have previously been created with a call to vSemaphoreCreateBinary(), xSemaphoreCreateMutex() or xSemaphoreCreateCounting(), and obtained using sSemaphoreTake().\n
\n
This must not be used from an ISR. See xSemaphoreGiveFromISR() for an alternative which can be used from an ISR.\n
\n
This macro must also not be used on semaphores created using xSemaphoreCreateRecursiveMutex().\n
\n
xSemaphoreGive() is part of the fully featured intertask communications API. xSemaphoreAltGive() is the alternative API equivalent. Both versions require the same parameters and return the same values. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>Boolean</ReturnType>
        <RetHint>Returns pdTRUE if the semaphore was given.</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xMutex</ParName>
          <ParType>xSemaphoreHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A handle to the mutex being released, or 'given'.  This is the handle returned by xSemaphoreCreateMutex();</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>bool #M#_#C#(xSemaphoreHandle xMutex)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vSemaphoreCreateBinary</Name>
        <Symbol>vSemaphoreCreateBinary</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro that creates a semaphore by using the existing queue mechanism. The queue length is 1 as this is a binary semaphore. The data size is 0 as we don't want to actually store any data - we just want to know if the queue is empty or full.\n
\n
Binary semaphores and mutexes are very similar but have some subtle differences: Mutexes include a priority inheritance mechanism, binary semaphores do not. This makes binary semaphores the better choice for implementing synchronisation (between tasks or between tasks and an interrupt), and mutexes the better choice for implementing simple mutual exclusion.\n
\n
A binary semaphore need not be given back once obtained, so task synchronisation can be implemented by one task/interrupt continuously 'giving' the semaphore while another continuously 'takes' the semaphore. This is demonstrated by the sample code on the xSemaphoreGiveFromISR() documentation page.\n
\n
The priority of a task that 'takes' a mutex can potentially be raised if another task of higher priority attempts to obtain the same mutex. The task that owns the mutex 'inherits' the priority of the task attempting to 'take' the same mutex. This means the mutex must always be 'given' back - otherwise the higher priority task will never be able to obtain the mutex, and the lower priority task will never 'disinherit' the priority. An example of a mutex being used to implement mutual exclusion is provided on the xSemaphoreTake() documentation page.\n
\n
Both mutex and binary semaphores are assigned to variables of type xSemaphoreHandle and can be used in any API function that takes a parameter of this type. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>void</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xSemaphore</ParName>
          <ParType>xSemaphoreHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Handle to the created semaphore. Should be of type xSemaphoreHandle.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(xSemaphoreHandle xSemaphore)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xSemaphoreCreateCounting</Name>
        <Symbol>xSemaphoreCreateCounting</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro that creates a counting semaphore by using the existing queue mechanism.\n
\n
Counting semaphores are typically used for two things:\n
\n
1. Counting events.\n
In this usage scenario an event handler will 'give' a semaphore each time an event occurs (incrementing the semaphore count value), and a handler task will 'take' a semaphore each time it processes an event (decrementing the semaphore count value). The count value is therefore the difference between the number of events that have occurred and the number that have been processed. In this case it is desirable for the initial count value to be zero.\n
\n
2. Resource management.\n
In this usage scenario the count value indicates the number of resources available. To obtain control of a resource a task must first obtain a semaphore - decrementing the semaphore count value. When the count value reaches zero there are no free resources. When a task finishes with the resource it 'gives' the semaphore back - incrementing the semaphore count value. In this case it is desirable for the initial count value to be equal to the maximum count value, indicating that all resources are free.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>xSemaphoreHandle</ReturnType>
        <RetHint>xSemaphoreHandle handle</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>uxMaxCount</ParName>
          <ParType>unsigned_portBASE_TYPE</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The maximum count value that can be reached. When the semaphore reaches this value it can no longer be 'given'.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>uxInitialCount</ParName>
          <ParType>unsigned_portBASE_TYPE</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The count value assigned to the semaphore when it is created.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>xSemaphoreHandle #M#_#C#(unsigned_portBASE_TYPE uxMaxCount, unsigned_portBASE_TYPE uxInitialCount)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xSemaphoreGiveFromISR</Name>
        <Symbol>xSemaphoreGiveFromISR</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro to release a semaphore. The semaphore must have previously been created with a call to vSemaphoreCreateBinary() or xSemaphoreCreateCounting().\n
\n
Mutex type semaphores (those created using a call to xSemaphoreCreateMutex()) must not be used with this macro.\n
\n
This macro can be used from an ISR.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>Boolean</ReturnType>
        <RetHint>Returns pdTRUE if the semaphore was given.</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>xSemaphore</ParName>
          <ParType>xSemaphoreHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A handle to the semaphore being released. This is the handle returned when the semaphore was created.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>pxHigherPriorityTaskWoken</ParName>
          <ParType>signed_portBASE_TYPE</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>xSemaphoreGiveFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if giving the semaphoree caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xSemaphoreGiveFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>bool #M#_#C#(xSemaphoreHandle xSemaphore, signed_portBASE_TYPE *pxHigherPriorityTaskWoken)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xSemaphoreTakeFromISR</Name>
        <Symbol>xSemaphoreTakeFromISR</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro to take a semaphore from an ISR. The semaphore must have previously been created with a call to vSemaphoreCreateBinary() or xSemaphoreCreateCounting().\n
\n
Mutex type semaphores (those created using a call to xSemaphoreCreateMutex()) must not be used with this macro.\n
\n
This macro can be used from an ISR, however taking a semaphore from an ISR is not a common operation.  It is likely to only be useful when taking a counting semaphore when an interrupt is obtaining an object from a resource pool (when the semaphore count indicates the number of resources available).</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>Boolean</ReturnType>
        <RetHint>Returns pdTRUE if the semaphore was given.</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>xSemaphore</ParName>
          <ParType>xSemaphoreHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A handle to the semaphore being taken. This is the handle returned when the semaphore was created.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>pxHigherPriorityTaskWoken</ParName>
          <ParType>signed_portBASE_TYPE</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>xSemaphoreTakeFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if taking the semaphore caused a task to unblock, and the unblocked task has a priority higher than the currently running task.  If xSemaphoreTakeFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>bool #M#_#C#(xSemaphoreHandle xSemaphore, signed_portBASE_TYPE *pxHigherPriorityTaskWoken)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vSemaphoreDelete</Name>
        <Symbol>vSemaphoreDelete</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Delete a semaphore.  This function must be used with care.  For example, do not delete a mutex type semaphore if the mutex is held by a task.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>void</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xSemaphore</ParName>
          <ParType>xSemaphoreHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A handle to the semaphore to be deleted.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(xSemaphoreHandle xSemaphore)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xSemaphoreGetMutexHolder</Name>
        <Symbol>xSemaphoreGetMutexHolder</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Returns the holder of a mutex or semaphore. If xMutex is indeed a mutex type semaphore, return the current mutex holder. If xMutex is not a mutex type semaphore, or the mutex is available (not held by a task), return NULL. Note: This Is is a good way of determining if the calling task is the mutex holder, but not a good way of determining the identity of the mutex holder as the holder may change between the function exiting and the returned value being tested.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>pointer</ReturnType>
        <RetHint>Not NULL if the calling task is the holder of the mutex, NULL otherwise.</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xSemaphore</ParName>
          <ParType>xSemaphoreHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A handle to the semaphore.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void* #M#_#C#(xSemaphoreHandle xSemaphore)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>pvPortMalloc</Name>
        <Symbol>pvPortMalloc</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Allocates a memory block using the port pvPortMalloc() function</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>pVoid</ReturnType>
        <RetHint>memory block or NULL if failed</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xWantedSize</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>size of memory block requested</ParHint>
          <ParUserDeclaration>size_t xWantedSize</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>pVoid #M#_#C#(size_t xWantedSize)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vPortFree</Name>
        <Symbol>vPortFree</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Frees a memory block previously allocated with pvPortMalloc()</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>pv</ParName>
          <ParType>Boolean</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to data</ParHint>
          <ParUserDeclaration>void *pv</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void *pv)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xPortGetFreeHeapSize</Name>
        <Symbol>xPortGetFreeHeapSize</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Returns the actual free size of the heap</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>Tsize_t</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>Tsize_t #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTaskSetApplicationTaskTag</Name>
        <Symbol>vTaskSetApplicationTaskTag</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>A 'tag' value can be assigned to each task. This value is for the use of the application only - the RTOS kernel itself does not make use of it in any way.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>xTask</ParName>
          <ParType>xTaskHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the task to which a tag value is being assigned. Passing xTask as NULL causes the tag to be assigned to the calling task.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>pxHookFunction</ParName>
          <ParType>pdTASK_HOOK_CODE</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The value being assigned to the task tag. This is of type pdTASK_HOOK_CODE to permit a function pointer to be assigned as the tag, although any value can actually be assigned. See the example below.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>Variable_1</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint/>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction, byte Variable_1)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTaskGetApplicationTaskTag</Name>
        <Symbol>xTaskGetApplicationTaskTag</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Returns the tag value associated with a task. The meaning and use of the tag value is defined by the application writer. The RTOS kernel itself will not normally access the tag value. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>pdTASK_HOOK_CODE</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xTask</ParName>
          <ParType>xTaskHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the task being queried. A task can query its own tag value by using NULL as the parameter value.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>pdTASK_HOOK_CODE #M#_#C#(xTaskHandle xTask)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTaskCallApplicationTaskHook</Name>
        <Symbol>xTaskCallApplicationTaskHook</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint> A 'tag' value can be assigned to each task. Normally this value is for the use of the application only and the RTOS kernel does not access it. However, it is possible to use the tag to assign a hook (or callback) function to a task - the hook function being executed by calling xTaskCallApplicationTaskHook(). Each task can define its own callback, or simply not define a callback at all.\n
\n
Although it is possible to use the first function parameter to call the hook function of any task, the most common use of task hook function is with the trace hook macros, as per the example given below.\n
\n
Task hook functions must have type pdTASK_HOOK_CODE, that is take a void * parameter, and return a value of type portBASE_TYPE. The void * parameter can be used to pass any information into the hook function. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portBASE_TYPE</ReturnType>
        <RetHint>return value</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>xTask</ParName>
          <ParType>xTaskHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the task whose hook function is being called. Passing NULL as xTask will call the hook function associated with the currently executing task.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>pvParameter</ParName>
          <ParType>pointer</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The value to pass to the hook function. This can be a pointer to a structure, or simply a numeric value.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portBASE_TYPE #M#_#C#(xTaskHandle xTask, void* pvParameter)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTaskGetCurrentTaskHandle</Name>
        <Symbol>xTaskGetCurrentTaskHandle</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>The handle of the currently running (calling) task.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>xTaskHandle</ReturnType>
        <RetHint>The handle of the currently running (calling) task.</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>xTaskHandle #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTaskGetIdleTaskHandle</Name>
        <Symbol>xTaskGetIdleTaskHandle</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>The task handle associated with the Idle task. The Idle task is created automatically when the RTOS scheduler is started.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>xTaskHandle</ReturnType>
        <RetHint>The task handle associated with the Idle task. The Idle task is created automatically when the RTOS scheduler is started.</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>xTaskHandle #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>pcTaskGetTaskName</Name>
        <Symbol>pcTaskGetTaskName</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Returns the name of the task.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>8bit signed</ReturnType>
        <RetHint>A pointer to the subject tasks name, which is a standard NULL terminated C string</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xTaskToQuery</ParName>
          <ParType>xTaskHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the task being queried. xTaskToQuery can be set to NULL to query the name of the calling task.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>signed char #M#_#C#(xTaskHandle xTaskToQuery)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>eTaskGetState</Name>
        <Symbol>eTaskGetState</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Returns as an enumerated type the state in which a task existed at the time eTaskGetState() was executed. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>eTaskState</ReturnType>
        <RetHint>task state (eReady, eRunning, eBlocked, eSuspended, eDeleted)</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xTask</ParName>
          <ParType>xTaskHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the subject task (the task being queried).</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>eTaskState #M#_#C#(xTaskHandle xTask)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTaskGetSchedulerState</Name>
        <Symbol>xTaskGetSchedulerState</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Returns the state of the scheduler</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portBASE_TYPE</ReturnType>
        <RetHint>One of the following constants (defined within task.h): taskSCHEDULER_NOT_STARTED, taskSCHEDULER_RUNNING, taskSCHEDULER_SUSPENDED.</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portBASE_TYPE #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTaskList</Name>
        <Symbol>vTaskList</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>configUSE_TRACE_FACILITY, INCLUDE_vTaskDelete and INCLUDE_vTaskSuspend must all be defined as 1 for this function to be available. See the configuration section for more information.\n
NOTE: This function will disable interrupts for its duration.  It is not intended for normal application runtime use but as a debug aid. Lists all the current tasks, along with their current state and stack usage high water mark.\n
Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or suspended ('S').</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>pcWriteBuffer</ParName>
          <ParType>8bit signed</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to buffer. A buffer into which the above mentioned details will be written, in ascii form.  This buffer is assumed to be large enough to contain the generated report.  Approximately 40 bytes per task should be sufficient.</ParHint>
          <ParUserDeclaration>signed portCHAR *pcWriteBuffer</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>bufSize</ParName>
          <ParType>uint16_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>size of buffer</ParHint>
          <ParUserDeclaration>size_t bufSize</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(signed portCHAR *pcWriteBuffer, size_t bufSize)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>uxTaskGetStackHighWaterMark</Name>
        <Symbol>uxTaskGetStackHighWaterMark</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>The stack used by a task will grow and shrink as the task executes and interrupts are processed. uxTaskGetStackHighWaterMark() returns the minimum amount of remaining stack space that was available to the task since the task started executing - that is the amount of stack that remained unused when the task stack was at its greatest (deepest) value. This is what is referred to as the stack 'high water mark'.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>unsigned_portBASE_TYPE</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xTask</ParName>
          <ParType>xTaskHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the task being queried. A task may query its own high water mark by passing NULL as the xTask parameter.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>unsigned_portBASE_TYPE #M#_#C#(xTaskHandle xTask)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>uxTaskGetNumberOfTasks</Name>
        <Symbol>uxTaskGetNumberOfTasks</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Returns the number of tasks</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>unsigned_portBASE_TYPE</ReturnType>
        <RetHint>number of tasks</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>unsigned_portBASE_TYPE #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTaskGetRunTimeStats</Name>
        <Symbol>vTaskGetRunTimeStats</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>configGENERATE_RUN_TIME_STATS must be defined as 1 for this function to be available. The application must also then provide definitions for portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE to configure a peripheral timer/counter and return the timers current count value respectively. The counter should be at least 10 times the frequency of the tick count.\n
NOTE: This function will disable interrupts for its duration. It is not intended for normal application runtime use but as a debug aid.\n
Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total accumulated execution time being stored for each task. The resolution of the accumulated time value depends on the frequency of the timer configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro. Calling vTaskGetRunTimeStats() writes the total execution time of each task into a buffer, both as an absolute count value and as a percentage of the total system execution time. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>pcWriteBuffer</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A buffer into which the execution times will be written, in ascii form. This buffer is assumed to be large enough to contain the generated report. Approximately 40 bytes per task should be sufficient. </ParHint>
          <ParUserDeclaration>portCHAR *pcWriteBuffer</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>bufSize</ParName>
          <ParType>16bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>size of buffer</ParHint>
          <ParUserDeclaration>size_t bufSize</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(portCHAR *pcWriteBuffer, size_t bufSize)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xQueueCreate</Name>
        <Symbol>xQueueCreate</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Creates a queue.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>xQueueHandle</ReturnType>
        <RetHint>A handle to the created queue is returned provided the queue was created successfully. NULL is returned if the queue cannot be created because there is too little heap RAM available.</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>uxQueueLength</ParName>
          <ParType>unsigned_portBASE_TYPE</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The maximum number of items the queue can hold at any time.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>uxItemSize</ParName>
          <ParType>unsigned_portBASE_TYPE</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The size in bytes of each item the queue will hold.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>xQueueHandle #M#_#C#(unsigned_portBASE_TYPE uxQueueLength, unsigned_portBASE_TYPE uxItemSize)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vQueueDelete</Name>
        <Symbol>vQueueDelete</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Deletes a queue that was previously created using a call to xQueueCreate(). vQueueDelete() can also be used to delete a semaphore.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>void</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>pxQueueToDelete</ParName>
          <ParType>xQueueHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the queue being deleted. Semaphore handles can also be used. Queues are used to pass data between tasks and between tasks and interrupts. A queue/semaphore must not be deleted if there are any tasks that are blocked on the queue/semaphore waiting for events (sends or receives).</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(xQueueHandle pxQueueToDelete)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xQueueSendToFront</Name>
        <Symbol>xQueueSendToFront</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sends an item to the front of a queue.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portBASE_TYPE</ReturnType>
        <RetHint>pdPASS: Data was successfully sent to the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for space to become available and space did become available before the block time expired.\nerrQUEUE_FULL: The queue is already full so no data could be sent to the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for space to become available, but no space became available before the block time expired.</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>xQueue</ParName>
          <ParType>xQueueHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the queue to which the data is to be sent.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>pvItemToQueue</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A pointer to the data to be sent to the queue. The size of the data that can be sent to a queue was defined when the queue was created.</ParHint>
          <ParUserDeclaration>const void *pvItemToQueue</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>xTicksToWait</ParName>
          <ParType>portTickType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The number of ticks for which the calling task should be held in the Blocked state to wait for space to become available on the queue should the queue already be full.\nA value of zero will prevent the calling task from entering the Blocked state.\nIf INCLUDE_vTaskSuspend is set to 1 then a value of portMAX_DELAY will hold the task in the Blocked state indefinitely to wait for space to become available on the queue.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portBASE_TYPE #M#_#C#(xQueueHandle xQueue, const void *pvItemToQueue, portTickType xTicksToWait)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xQueueSendToFrontFromISR</Name>
        <Symbol>xQueueSendToFrontFromISR</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Versions of xQueueSendToFront() API functions that can be called from an ISR. Unlike xQueueSendToFront() these functions do not permit a block time to be specified.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portBASE_TYPE</ReturnType>
        <RetHint>pdTRUE Data was successfully sent to the queue.\nerrQUEUE_FULL Data could not be sent to the queue because the queue was already full.</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>xQueue</ParName>
          <ParType>xQueueHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the queue to which the data is to be sent.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>pvItemToQueue</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A pointer to the data to be sent to the queue. The size of the data that can be sent to a queue was defined when the queue was created.</ParHint>
          <ParUserDeclaration>const void *pvItemToQueue</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>pxHigherPriorityTaskWoken</ParName>
          <ParType>portBASE_TYPE</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>xQueueSendFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xQueueSendFromISR() sets this value to pdTRUE then a context switch should be performed before the interrupt is exited.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portBASE_TYPE #M#_#C#(xQueueHandle xQueue, const void *pvItemToQueue, portBASE_TYPE *pxHigherPriorityTaskWoken)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xQueueSendToBack</Name>
        <Symbol>xQueueSendToBack</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sends an item to the back of a queue.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portBASE_TYPE</ReturnType>
        <RetHint>pdPASS: Data was successfully sent to the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for space to become available and space did become available before the block time expired.\nerrQUEUE_FULL: The queue is already full so no data could be sent to the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for space to become available, but no space became available before the block time expired.</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>xQueue</ParName>
          <ParType>xQueueHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the queue to which the data is to be sent.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>pvItemToQueue</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A pointer to the data to be sent to the queue. The size of the data that can be sent to a queue was defined when the queue was created.</ParHint>
          <ParUserDeclaration>const void *pvItemToQueue</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>xTicksToWait</ParName>
          <ParType>portTickType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The number of ticks for which the calling task should be held in the Blocked state to wait for space to become available on the queue should the queue already be full.\nA value of zero will prevent the calling task from entering the Blocked state.\nIf INCLUDE_vTaskSuspend is set to 1 then a value of portMAX_DELAY will hold the task in the Blocked state indefinitely to wait for space to become available on the queue.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portBASE_TYPE #M#_#C#(xQueueHandle xQueue, const void *pvItemToQueue, portTickType xTicksToWait)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xQueueSendToBackFromISR</Name>
        <Symbol>xQueueSendToBackFromISR</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Versions of xQueueSendToBack() API functions that can be called from an ISR. Unlike xQueueSendToBack() these functions do not permit a block time to be specified.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portBASE_TYPE</ReturnType>
        <RetHint>pdTRUE Data was successfully sent to the queue.\nerrQUEUE_FULL Data could not be sent to the queue because the queue was already full.</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>xQueue</ParName>
          <ParType>xQueueHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the queue to which the data is to be sent.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>pvItemToQueue</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A pointer to the data to be sent to the queue. The size of the data that can be sent to a queue was defined when the queue was created.</ParHint>
          <ParUserDeclaration>const void *pvItemToQueue</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>pxHigherPriorityTaskWoken</ParName>
          <ParType>portBASE_TYPE</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>xQueueSendFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xQueueSendFromISR() sets this value to pdTRUE then a context switch should be performed before the interrupt is exited.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portBASE_TYPE #M#_#C#(xQueueHandle xQueue, const void *pvItemToQueue, portBASE_TYPE *pxHigherPriorityTaskWoken)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xQueueReceive</Name>
        <Symbol>xQueueReceive</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Receives an item from a queue.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portBASE_TYPE</ReturnType>
        <RetHint>pdPASS: Data was successfully read from the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for data to become available and data did become available before the block time expired.\nerrQUEUE_EMPTY: The queue was empty so no date could be read form the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for data to become available, but no data became available before the block time expired.</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>xQueue</ParName>
          <ParType>xQueueHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the queue from which the data is to be received.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>pvBuffer</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A pointer to the memory into which the data received from the queue will be copied.\nThe length of the buffer must be at least equal to the queue item size (set when the queue was created).</ParHint>
          <ParUserDeclaration>void *pvBuffer</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>xTicksToWait</ParName>
          <ParType>portTickType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The number of ticks for which the calling task should be held in the Blocked state to wait for data to become available from the queue should the queue already be empty.\nA value of zero will prevent the calling task from entering the Blocked state.\nIf INCLUDE_vTaskSuspend is set to 1 then a value of portMAX_DELAY will hold the task in the Blocked state indefinitely to wait for data.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portBASE_TYPE #M#_#C#(xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWait)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xQueueReceivefromISR</Name>
        <Symbol>xQueueReceivefromISR</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>A version of xQueueReceive() that can be called from an ISR. Unlike xQueueReceive(), xQueueReceiveFromISR() does not permit a block time to be specified.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portBASE_TYPE</ReturnType>
        <RetHint>pdPASS: Data was successfully read from the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for data to become available and data did become available before the block time expired.\nerrQUEUE_EMPTY: The queue was empty so no date could be read form the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for data to become available, but no data became available before the block time expired.</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>xQueue</ParName>
          <ParType>xQueueHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the queue from which the data is to be received.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>pvBuffer</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A pointer to the memory into which the data received from the queue will be copied.The length of the buffer must be at least equal to the queue item size (set when the queue was created).</ParHint>
          <ParUserDeclaration>void *pvBuffer</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>pxHigherPriorityTaskWoken</ParName>
          <ParType>portBASE_TYPE</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to A task may be blocked waiting for space to become available on the queue. If xQueueReceiveFromISR() causes such a task to unblock then *pxHigherPriorityTaskWoken will get set to pdTRUE, otherwise *pxHigherPriorityTaskWoken will remain unchanged.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portBASE_TYPE #M#_#C#(xQueueHandle xQueue, void *pvBuffer, portBASE_TYPE *pxHigherPriorityTaskWoken)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xQueuePeek</Name>
        <Symbol>xQueuePeek</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Reads an item from a queue, but does not remove the item from the queue. Therefore the same item would be returned the next time xQueueReceive() or xQueuePeek() was called on the same queue.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portBASE_TYPE</ReturnType>
        <RetHint>pdPASS: Data was successfully read from the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for data to become available and data did become available before the block time expired.\nerrQUEUE_EMPTY: The queue was empty so no date could be read form the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for data to become available, but no data became available before the block time expired.</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>xQueue</ParName>
          <ParType>xQueueHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the queue from which the data is to be read.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>pvBuffer</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A pointer to the memory into which the data read from the queue will be copied. The length of the buffer must be at least equal to the queue item size (set when the queue was created).</ParHint>
          <ParUserDeclaration>void *pvBuffer</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>xTicksToWait</ParName>
          <ParType>portTickType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The number of ticks for which the calling task should be held in the Blocked state to wait for data to become available from the queue should the queue already be empty.\nA value of zero will prevent the calling task from entering the Blocked state.\nIf INCLUDE_vTaskSuspend is set to 1 then a value of portMAX_DELAY will hold the task in the Blocked state indefinitely to wait for data.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portBASE_TYPE #M#_#C#(xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWait)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>uxQueueMessagesWaiting</Name>
        <Symbol>uxQueueMessagesWaiting</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Queries the number of items that are currently held within a queue.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>unsigned_portBASE_TYPE</ReturnType>
        <RetHint>The number of items that are held within the queue being queried.</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xQueue</ParName>
          <ParType>xQueueHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the queue being queried.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>unsigned_portBASE_TYPE #M#_#C#(xQueueHandle xQueue)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>uxQueueMessagesWaitingfromISR</Name>
        <Symbol>uxQueueMessagesWaitingfromISR</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>A version of uxQueueMessagesWaiting() that can be used from inside an interrupt service routine.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>unsigned_portBASE_TYPE</ReturnType>
        <RetHint>The number of items that are held within the queue being queried.</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xQueue</ParName>
          <ParType>xQueueHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the queue being queried.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>unsigned_portBASE_TYPE #M#_#C#(xQueueHandle xQueue)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xQueueReset</Name>
        <Symbol>xQueueReset</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Reset a queue back to its original empty state.  pdPASS is returned if the queue is successfully reset.  pdFAIL is returned if the queue could not be reset because there are tasks blocked on the queue waiting to either receive from the queue or send to the queue.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portBASE_TYPE</ReturnType>
        <RetHint>pdPASS is returned if the queue is successfully reset. pdFAIL is returned if the queue could not be reset because there are tasks blocked on the queue waiting to either receive from the queue or send to the queue.</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xQueue</ParName>
          <ParType>xQueueHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the queue to reset.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portBASE_TYPE #M#_#C#(xQueueHandle xQueue)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ParseCommand</Name>
        <Symbol>ParseCommand</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Shell Command Line Parser</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>cmd</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to command string</ParHint>
          <ParUserDeclaration>const unsigned char *cmd</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>handled</ParName>
          <ParType>Boolean</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to variable which tells if the command has been handled or not</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to I/O structure</ParHint>
          <ParUserDeclaration>const %@Shell@'ModuleName'%.StdIOType *io</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(const unsigned char *cmd, bool *handled, const %@Shell@'ModuleName'%.StdIOType *io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>Init</Name>
        <Symbol>Init</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Low level initialization routine called from startup code. This method ensures that the tick timer is  not enabled.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
  </MethodList>
  <EventList>
    <Event>
      <TStrgItem>
        <Name>Event module name</Name>
        <Symbol>EventModule</Symbol>
        <Hint>Name of the user module (without extension), where the events from this bean are placed.</Hint>
        <ItemLevel>ADVANCED</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>Events</DefaultValue>
        <StrDefine>nothing</StrDefine>
        <MinLength>0</MinLength>
        <MaxLength>-1</MaxLength>
      </TStrgItem>
    </Event>
    <Event>
      <TEvntItem>
        <Name>vApplicationStackOverflowHook</Name>
        <Symbol>vApplicationStackOverflowHook</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>if enabled, this hook will be called in case of a stack overflow.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>generate code</Description>
        <Expanded>Yes</Expanded>
        <DefaultValue>true</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <IsAssembler>false</IsAssembler>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>pxTask</ParName>
          <ParType>xTaskHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Task handle</ParHint>
        </Parameter>
        <Parameter>
          <ParName>pcTaskName</ParName>
          <ParType>char</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to task name</ParHint>
          <ParUserDeclaration>signed portCHAR *pcTaskName</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #C#(xTaskHandle pxTask, signed portCHAR *pcTaskName)</ANSIC>
        </Declarations>
        <Children>
          <GrupItem>
            <TEvntName>
              <Name>Event procedure name</Name>
              <Symbol>Name</Symbol>
              <Hint>vApplicationStackOverflowHook procedure name</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue/>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
              <ErrorIfNotSet>true</ErrorIfNotSet>
              <IdentType>EVNT</IdentType>
            </TEvntName>
          </GrupItem>
        </Children>
      </TEvntItem>
    </Event>
    <Event>
      <TEvntItem>
        <Name>vApplicationTickHook</Name>
        <Symbol>vApplicationTickHook</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>If enabled, this hook will be called by the RTOS for every tick increment.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>generate code</Description>
        <Expanded>Yes</Expanded>
        <DefaultValue>true</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <IsAssembler>false</IsAssembler>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #C#(void)</ANSIC>
        </Declarations>
        <Children>
          <GrupItem>
            <TEvntName>
              <Name>Event procedure name</Name>
              <Symbol>Name</Symbol>
              <Hint>vApplicationTickHook procedure name</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue/>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
              <ErrorIfNotSet>true</ErrorIfNotSet>
              <IdentType>EVNT</IdentType>
            </TEvntName>
          </GrupItem>
        </Children>
      </TEvntItem>
    </Event>
    <Event>
      <TEvntItem>
        <Name>vApplicationIdleHook</Name>
        <Symbol>vApplicationIdleHook</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>If enabled, this hook will be called when the RTOS is idle. This might be a good place to go into low power mode.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>generate code</Description>
        <Expanded>Yes</Expanded>
        <DefaultValue>true</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <IsAssembler>false</IsAssembler>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #C#(void)</ANSIC>
        </Declarations>
        <Children>
          <GrupItem>
            <TEvntName>
              <Name>Event procedure name</Name>
              <Symbol>Name</Symbol>
              <Hint>vApplicationIdleHook procedure name</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue/>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
              <ErrorIfNotSet>true</ErrorIfNotSet>
              <IdentType>EVNT</IdentType>
            </TEvntName>
          </GrupItem>
        </Children>
      </TEvntItem>
    </Event>
    <Event>
      <TEvntItem>
        <Name>vApplicationMallocFailedHook</Name>
        <Symbol>vApplicationMallocFailedHook</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>If enabled, the RTOS will call this hook in case memory allocation failed.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>generate code</Description>
        <Expanded>Yes</Expanded>
        <DefaultValue>true</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <IsAssembler>false</IsAssembler>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #C#(void)</ANSIC>
        </Declarations>
        <Children>
          <GrupItem>
            <TEvntName>
              <Name>Event procedure name</Name>
              <Symbol>Name</Symbol>
              <Hint>vApplicationMallocFailedHook procedure name</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue/>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
              <ErrorIfNotSet>true</ErrorIfNotSet>
              <IdentType>EVNT</IdentType>
            </TEvntName>
          </GrupItem>
        </Children>
      </TEvntItem>
    </Event>
    <Event>
      <TEvntItem>
        <Name>vOnPreSleepProcessing</Name>
        <Symbol>vOnPreSleepProcessing</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Used in tickless idle mode only, but required in this mode. Hook for the application to enter low power mode.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>generate code</Description>
        <Expanded>Yes</Expanded>
        <DefaultValue>true</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <IsAssembler>false</IsAssembler>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>expectedIdleTicks</ParName>
          <ParType>portTickType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>expected idle time, in ticks</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #C#(portTickType expectedIdleTicks)</ANSIC>
        </Declarations>
        <Children>
          <GrupItem>
            <TEvntName>
              <Name>Event procedure name</Name>
              <Symbol>Name</Symbol>
              <Hint>vOnPreSleepProcessing procedure name</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue/>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
              <ErrorIfNotSet>true</ErrorIfNotSet>
              <IdentType>EVNT</IdentType>
            </TEvntName>
          </GrupItem>
        </Children>
      </TEvntItem>
    </Event>
    <Event>
      <TEvntItem>
        <Name>vOnPostSleepProcessing</Name>
        <Symbol>vOnPostSleepProcessing</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Event called after the CPU woke up after low power mode. This event is optional.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>generate code</Description>
        <Expanded>Yes</Expanded>
        <DefaultValue>true</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <IsAssembler>false</IsAssembler>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>expectedIdleTicks</ParName>
          <ParType>portTickType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>expected idle time, in ticks</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #C#(portTickType expectedIdleTicks)</ANSIC>
        </Declarations>
        <Children>
          <GrupItem>
            <TEvntName>
              <Name>Event procedure name</Name>
              <Symbol>Name</Symbol>
              <Hint>vOnPostSleepProcessing procedure name</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue/>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
              <ErrorIfNotSet>true</ErrorIfNotSet>
              <IdentType>EVNT</IdentType>
            </TEvntName>
          </GrupItem>
        </Children>
      </TEvntItem>
    </Event>
  </EventList>
  <Links>
    <EmptySection_DummyValue/>
  </Links>
  <Revisions>
    <RevisionVersion>2</RevisionVersion>
  </Revisions>
</Bean>
