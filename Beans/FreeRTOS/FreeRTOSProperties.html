<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1250">
<title>
Component  documentation - Properties
</title>
<STYLE type="text/css">
body{
  background-color: white;
  margin:0px;
  font: 13px Helvetica Neue, Helvetica, Arial, sans-serif;
}
A:visited {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:link {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:active {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:hover {
	COLOR: #2D8AA7; TEXT-DECORATION: underline
}
.VSP {
	COLOR: #2D8AA7; FONT: bold italic 14px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.reflink {
	FONT: 11px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
 	COLOR: #2D8AA7;
}
.user_text {
	FONT: 12px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
	COLOR: #000000;
}
.bluetext {
  COLOR: #695F52;
}
.versionspec {
  padding:5px; 
  background-color: RGB(243, 242, 230);
  margin-top:5px;
  margin-bottom:5px;  
}
.versionspecdetail {
  padding:5px; 
  background-color: RGB(243, 242, 230);
  margin-top:5px;
  margin-bottom:5px;  
}
.versionspeclabel {
  font-style: italic;
}
LI.DEF {
  list-style-image: url(DefaultLI.gif) ;
}
LI.BAS {
	list-style-image: url(BasicLI.gif) ;
}
LI.ADV {
	list-style-image: url(AdvancedLI.gif) ;
}
LI.EXP {
	list-style-image: url(ExpertLI.gif) ;
}
.titlebox {  
  font: bold 18px Helvetica Neue, Helvetica, Arial, sans-serif;
  color: #51626F;
  margin-bottom: 10px;
}
.lefttitlebox {
  background-color:#C3CFD1;  
}
.lefttitle {
  color:#51626F;
  font: bold 11px Helvetica Neue, Helvetica, Arial, sans-serif;   
}
.beanname {
  font: bold 14px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
  padding-top:6px;
  padding-bottom:5px;
  margin-bottom: 5px;
  border-bottom-style: dotted;
  border-bottom-width: 1;  
}
.descrtext {
  font-style: italic;
  font: 14px/18px Helvetica Neue, Helvetica, Arial, sans-serif;  
  padding-bottom:9px;
}
.footer {
  color: #b0b0b0; 
  font: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
  text-align: center;
  border-top-style: solid;
  border-top-color: #BOBOBO;
  border-top-width: 1px;  
  padding-top: 5px;
  margin-top: 20px;
}
.info_name {
  font: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
  padding: 0px;
  color: black;
}
.info_text {
  font: 11px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.text_title {
  COLOR: #000000; 
  FONT: bold 14px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.descr_line {
  COLOR: gray; 
  FONT: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.code {
  background-color: RGB(243, 242, 230);
  padding: 10px;
  white-space: pre;
  font-family: Courier New, Monospace;
}
</STYLE>

</head>

<body>

<table border="0"  cellspacing="0" cellpadding="0">
  <tr>
    <td valign="top" width="150" >
      <table  width="150" height="160" cellpadding="3" cellspacing="0" border="0">
        <tbody>
        <tr class="lefttitlebox">
          <td width="4"></td>
          <td align="center" valign="middle" height="30" width="128">
            <span class="lefttitle">
<b>FreeRTOS</b>
            </span>
          </td>
        </tr>
        <tr height="700">
          <td width="4"></td>
          <td width="128" valign="top">
            &nbsp;<br />
            <div class="reflink">
<!---HTMLLISTBEG_SHORT DON'T CHANGE THIS LINE-->
<a href="FreeRTOS.html">General Info</a><br />
<i>Properties</i><br />
<a href="FreeRTOSMethods.html">Methods</a><br />
<a href="FreeRTOSEvents.html">Events</a><br />
<a href="FreeRTOSTypical Usage.html">Typical Usage</a><br />
<a href="FreeRTOSApplication Notes.html">Application Notes</a><br />
<!---HTMLLISTEND DON'T CHANGE THIS LINE-->
<br /><br /><br />
<a href="../../DOCs/PredefSymbols.html">Types &amp; definitions</a><br/>
<a href="../../DOCs/BEANindex.html">Component Index</a><br/>
<a href="../../DOCs/CPUindex.html">CPU Component Index</a><br/>
<a href="../../DOCs/EmbeddedBeans.html">Embedded Components</a><br/>
<a href="../../DOCs/BeanCategories.html">Component Categories</a><br/>

<br /><br /><br />
<center>
<img src="FreeRTOS_b.gif" alt="Component icon"/>


</center>
            </div>
          </td>
        </tr>
        </tbody>
      </table>
    </td>
    <td width="1" class="lefttitlebox" valign="top">
      <table class="lefttitlebox" width="1" cellpadding="0" cellspacing="0" height="100%" border="0">
        <tr class="lefttitlebox"><td width="1"></td></tr>
      </table>
    </td>
    <td style="padding-left:15px;padding-right:10px;" valign="top" align="left" width="100%">

<!--      <table border="0" cellPadding="0" cellSpacing="0" width="100%">
        <tbody>
        <tr>
          <td class="titlebox">-->
          
           <div class="titlebox">
              <div class="beanname">
                Component
                
                
                FreeRTOS
              </div>
              <div class="descrtext">FreeRTOS</div>
              <div class="info_name">Component Level: <span class="info_text"><a href="../../DOCs/BeanCategoriesInfo.html#LevelAbstraction">High</a></span></div>
              <div class="info_name">Category: 
                <span class="info_text">
                <a href="../../DOCs/BeanCategoriesInfo.html">Operating Systems</a>
                
                </span>
              </div>
            </div>
                      
<!--
            </td>
        </tr>

        <tr>        
-->  
            
<!--            <td align="left"> -->
<!--                   <br /> -->                  
     <div class="text_title">
          Properties:
		 </div>		 
		 <div class="descr_line">                  
                  (Properties are parameters of the component. Please see the <a href="../../DOCs/EmbeddedBeans.html">Embedded Components page</a> for more information.)                   
     </div>
                  
<div class="user_text">
<ul>
<li>
<a name="DeviceName">
<b>Component name</b></a> - Name of the component.
</li>
<li>
<a name="FreeRTOSVersion">
<b>RTOS Version</b></a> - Identifies the RTOS version
</li>
<li>
<a name="configCOMPILER">
<b>Compiler</b></a> - Compiler to be used for code generation<br /><br />
There are 10 options:<br />
<ul>
  <li><u>automatic</u>: Automatic compiler selection, based on Processor Expert CPU settings</li>
  <li><u>ARM gcc</u>: ARM GNU gcc compiler</li>
  <li><u>ARM IAR</u>: IAR ARM compiler</li>
  <li><u>ARM Keil</u>: Keil ARM compiler</li>
  <li><u>ARM FSL (legacy)</u>: depreciated, Freescale ARM compiler</li>
  <li><u>S08 FSL</u>: Freescale S08 compiler</li>
  <li><u>S12 FSL</u>: Freescale S12(X) compiler</li>
  <li><u>ColdFire V1 FSL</u>: Freescale ColdFire V1 compiler</li>
  <li><u>ColdFire V2 FSL</u>: Freescale ColdFire V2 compiler</li>
  <li><u>DSC FSL</u>: Freescale DSC compiler</li>
</ul><br />

</li>
<li>
<a name="SourceGenerationOptions">
<b>Static Sources</b></a> - Source Code Generation Option for the RTOS. With this, the source file generation can be configured so they can be easily used outside of Processor Expert.<br />
The following items are available only if the group is enabled (the value is "Enabled"):<br />

<ul>
  <li>
  <a name="RTOSSrcFolderName">
  <b>Source Folder</b></a> - RTOS source files are generated into this sub folder name. The name can be empty.
  </li>
  <li>
  <a name="RTOSHeaderFolderName">
  <b>Header Folder</b></a> - RTOS header files are generated into this sub folder name. The name can be empty.
  </li>
  <li>
  <a name="RTOSPortFolderName">
  <b>Port Folder</b></a> - RTOS port depending sources files are generated into this sub folder name. The name can be empty.
  </li>
  <li>
  <a name="UseManualClockValues">
  <b>Manual Clock Values</b></a> - If enabled, it is using predefined clock values instead of the values from the Processor Expert Cpu.h<br />
The following items are available only if the group is enabled (the value is "Enabled"):<br />

  <ul>
    <li>
    <a name="configCPU_CLOCK_HZ">
    <b>configCPU_CLOCK_HZ</b></a> - Clock speed of CPU, default is CPU_CORE_CLK_HZ with Processor Expert
    </li>
    <li>
    <a name="configBUS_CLOCK_HZ">
    <b>configBUS_CLOCK_HZ</b></a> - Bus clock speed, default is CPU_BUS_CLK_HZ with Processor Expert
    </li>
  </ul>
  </li>
</ul>
</li>
<li>
<a name="IsClassicCW">
<b>Classic CodeWarrior</b></a> - If you are using this component in classic (non-eclipse based) CodeWarrior, then this setting has to be set to 'yes'. If you want to know why: The reason is that classic CodeWarrior does not come with the common_RTOSAdaptor.prg file. As such a test has to be present  in FreeRTOS.ts2.
</li>
<li>
<a name="DisabledInterruptsInStartup">
<b>Disabled Interrupts in Startup</b></a> - If set to 'yes', then interrupts will be disabled in PE_low_level_init() using the PEX_RTOS_INIT() macro.
</li>
<li>
<a name="Utility">
<b>Utility</b></a> - Interface to utility functions
</li>
<li>
<a name="UseApplicationTaskTags">
<b>Application Task Tags</b></a> - This configures configUSE_APPLICATION_TASK_TAG. If enabled, the methodsxTaskGetApplicationTaskTag(), vTaskSetApplicationTaskTag() and xTaskCallApplicationTaskHook() are enabled.
</li>
<li>
<a name="UseTraceFacility">
<b>Use Trace Facility</b></a> - Set to 1 if you wish the trace visualisation functionality to be available, or 0 if the trace functionality is not going to be used. If you use the trace functionality a trace buffer must also be provided. If using Trace Hooks, this property is automatically enabled. This setting controls the configUSE_TRACE_FACILITY macro.
</li>
<li>
<a name="UseTraceHooksGroup">
<b>Trace Hooks</b></a> - If enabled, you can condfigure trace hooks to collect information about the RTOS behaviour.<br />
The following items are available only if the group is enabled (the value is "Enabled"):<br />

<ul>
  <li>
  <a name="FRTrace">
  <b>FreeRTOS Trace</b></a> - Interface to the trace hooks.
  </li>
</ul>
</li>
<li>
<a name="CollectRuntimeStatisticsGroup">
<b>Collect Runtime Statistics</b></a> - If enabled, runtime statistics are collected. This setting configures configGENERATE_RUN_TIME_STATS. A timer with at least  least 10 times faster than the tick counter needs to be provided)<br />
The following items are available only if the group is enabled (the value is "Enabled"):<br />

<ul>
  <li>
  <a name="LDDRuntimeCounterGroup">
  <b>LDD</b></a> - Logical Device Driver<br />
The following items are available only if the group is enabled (the value is "Enabled"):<br />

  <ul>
    <li>
    <a name="RuntimeCntrLDD">
    <b>Runtime Counter LDD</b></a> - Logical Device Driver implementing the runtime counter. Counter to be used to collect run time statistics. portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and  portGET_RUN_TIME_COUNTER_VALUE() will be created to access the counter value. The counter frequency should be about 10 times the frequency of the tick timer.
    </li>
  </ul>
  </li>
  <li>
  <a name="NonLDDRuntimeCounterGroup">
  <b>non-LDD</b></a> - Using a traditional (non Logical Device Driver) component<br />
The following items are available only if the group is enabled (the value is "Enabled"):<br />

  <ul>
    <li>
    <a name="RuntimeCntr">
    <b>Runtime Counter</b></a> - Counter to be used to collect run time statistics. portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and  portGET_RUN_TIME_COUNTER_VALUE() will be created to access the counter value. The counter frequency should be about 10 times the frequency of the tick timer.
    </li>
  </ul>
  </li>
</ul>
</li>
<li>
<a name="SchedulerGroup">
<b>Scheduler</b></a> - Settings for the scheduler
<ul>
  <li>
  <a name="ColdFireV1CPUSpecific">
  <b>ColdFire V1</b></a> - This group is used to configure the RTOS for the ColdFire V1 cores<br />
The following items are available only if the group is enabled (the value is "Enabled"):<br />

  <ul>
    <li>
    <a name="FreeRTOSColdFireCPU">
    <b>CPU</b></a> - Specify which ColdFire CPU is used (ColdFire V1 only). This is affecting the portCF_INTC_VALUE macro in portmacro.h<br /><br />
There are 5 options:<br />
<ul>
  <li><u>MCF51CN</u>: ColdFire V1 MCF51CN family</li>
  <li><u>MCF51JM</u>: ColdFire V1 MCF51JM family</li>
  <li><u>MCF51QE</u>: ColdFire V1 MCF51QE family</li>
  <li><u>MCF51JE</u>: ColdFire V1 MCF51JE family</li>
  <li><u>MCF51MM</u>: ColdFire V1 MCF51MM family</li>
</ul><br />

    </li>
    <li>
    <a name="ColdFireSWI">
    <b>SWI</b></a> - Specify which software interrupt shall be used for task switching (ColdFire only)<br /><br />
There are 7 options:<br />
<ul>
  <li><u>VL1swi</u>: using VL1swi</li>
  <li><u>VL2swi</u>: using VL2swi</li>
  <li><u>VL3swi</u>: using VL3swi</li>
  <li><u>VL4swi</u>: using VL4swi</li>
  <li><u>VL5swi</u>: using VL5swi</li>
  <li><u>VL6swi</u>: using VL6swi</li>
  <li><u>VL7swi</u>: using VL7swi</li>
</ul><br />

    </li>
  </ul>
  </li>
  <li>
  <a name="ColdFireV2CPUSpecific">
  <b>ColdFire V2</b></a> - This group is used to configure the RTOS for the ColdFire V2 cores<br />
The following items are available only if the group is enabled (the value is "Enabled"):<br />

  <ul>
    <li>
    <a name="FreeRTOSColdFireV2CPU">
    <b>CPU</b></a> - CPU<br /><br />
There is 1 option:<br />
<ul>
  <li><u>MCF5225x</u>: ColdFire V2 MCF5225x family</li>
</ul><br />

    </li>
    <li>
    <a name="ColdFireV2LibraryLowestInterruptPriority">
    <b>Library Lowest Interrupt Priority</b></a> - Used for configLIBRARY_LOWEST_INTERRUPT_PRIORITY. The RTOS will disable interrupts equal or lower than this priority. So for example if you set it to 5, then interrupts with level 6 can happen while the RTOS is running. This means as well that you shall *not* call any RTOS functions with an interrupt priority higher than this value! Keep in mind that for the ColdFire V2, the interrupts of level 7 can *not* be masked.
    </li>
    <li>
    <a name="ColdFireV2SWInumber">
    <b>SWI Number</b></a> - Software Interrupt Vector number.<br />
Mapping for number to vector for the MCF52259:<br />
     0: 0x40  0x00000100 Reserved64    <br />
     1: 0x41  0x00000104 INT_EPORT_EPF1<br />
     2: 0x42  0x00000108 INT_EPORT_EPF2<br />
     3: 0x43  0x0000010C INT_EPORT_EPF3<br />
     4: 0x44  0x00000110 INT_EPORT_EPF4<br />
     5: 0x45  0x00000114 INT_EPORT_EPF5<br />
     6: 0x46  0x00000118 INT_EPORT_EPF6<br />
     7: 0x47  0x0000011C INT_EPORT_EPF7<br />
     8: 0x48  0x00000120 INT_SCM_SWTI  <br />
     9: 0x49  0x00000124 INT_DMA0_DONE <br />
    10: 0x4A  0x00000128 INT_DMA1_DONE <br />
    11: 0x4B  0x0000012C INT_DMA2_DONE <br />
    12: 0x4C  0x00000130 INT_DMA3_DONE <br />
    13: 0x4D  0x00000134 INT_UART0     <br />
    14: 0x4E  0x00000138 INT_UART1     <br />
    15: 0x4F  0x0000013C INT_UART2     <br />
    16: 0x50  0x00000140 Reserved80    
    </li>
  </ul>
  </li>
  <li>
  <a name="KinetisCPUSpecific">
  <b>Kinetis</b></a> - This group is used to configure the RTOS for the Kinetis/ARM cores<br />
The following items are available only if the group is enabled (the value is "Enabled"):<br />

  <ul>
    <li>
    <a name="ARMFamilyType">
    <b>ARM Family</b></a> - Specifies the ARM family used<br /><br />
There are 3 options:<br />
<ul>
  <li><u>Cortex M0+</u>: ARM Cortex M0+ (Kinetis L family)</li>
  <li><u>Cortex M4</u>: ARM Cortex M4 (Kinetis K family)</li>
  <li><u>Cortex M4F</u>: ARM Cortex M4 (Kinetis K family with floating point unit)</li>
</ul><br />

    </li>
    <li>
    <a name="M4FFloatingPointSupport">
    <b>Floating Point Support</b></a> - If enabled, the port is supporting the different stack frame created by the Cortex M4F
    </li>
    <li>
    <a name="KinetisLibraryMaxInterruptPriority">
    <b>Max SysCall Interrupt Priority</b></a> - Used for configMAX_SYSCALL_INTERRUPT_PRIORITY. <br />
The highest interrupt priority that can be used by any interrupt service routine that makes calls to interrupt safe FreeRTOS API functions.  DO NOT CALL INTERRUPT SAFE FREERTOS API FUNCTIONS FROM ANY INTERRUPT THAT HAS A HIGHER PRIORITY THAN THIS! (higher priorities are lower numeric values). configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to zero! See  http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html. Note that 0 is the highest priority for Kinetis.
    </li>
    <li>
    <a name="KinetisLibraryLowestInterruptPriority">
    <b>RTOS Interrupt Priority</b></a> - Used for configLIBRARY_LOWEST_INTERRUPT_PRIORITY. The lowest interrupt priority that can be used in a call to a &quot;set priority&quot; function. This priority is used for the kernel port itself too. Note that 0 is the highest priority for ARM/Kinetis.
    </li>
    <li>
    <a name="ARMLowestInterrutpPriority">
    <b>Lowest Interrupt Priority</b></a> - Lowest possible interrupt priority as defined by the CPU, with zero the *highest* priority. This property is informal only.
    </li>
    <li>
    <a name="CompilerOptimizationLevel">
    <b>Compiler Optimization Level</b></a> - Not applicable for gcc. Optimization level of the compiler as in the build tools settings. Depending on the optimization level, the stack frame of the Processor Expert functions and consequently the xPortPendSVHandler() and vPortSVCHandler() functions need to be different, and the port needs to be aware about it. With the MCU10.2 compiler (after Jan 1st 2012) the compiler defines a macro (__optlevel0, etc) for the optimization level used which is checked in the generated code. If the settings do not match, then the source code will raise an #error at compilation time.<br /><br />
There are 5 options:<br />
<ul>
  <li><u>0</u>: Optimization level 0</li>
  <li><u>1</u>: Optimization level 1</li>
  <li><u>2</u>: Optimization level 2</li>
  <li><u>3</u>: Optimization level 3</li>
  <li><u>4</u>: Optimization level 4</li>
</ul><br />

    </li>
    <li>
    <a name="useARMSysTickTimer">
    <b>SysTick</b></a> - If enabled, the port will use the ARM SysTick timer directly and no Processor Expert Timer is used.<br />
The following items are available only if the group is enabled (the value is "Enabled"):<br />

    <ul>
      <li>
      <a name="useARMSysTickUseCoreClock">
      <b>Core Clock</b></a> - If set to yes, the CLK bit in the SysTick configuration register will be set (using the core clock), otherwise the bit is cleared. If the bit is cleared,  the external reference clock will be used. The Kinetis K series does not implement this, so only the core clock can be used. For the Kinetis L series, a fixed prescaler of 16 is used.
      </li>
    </ul>
    </li>
  </ul>
  </li>
  <li>
  <a name="NonLDDSWIGroup">
  <b>non-LDD SWI</b></a> - Group configuring the software interrupt using classic non-Low Level Driver component<br />
The following items are available only if the group is enabled (the value is "Enabled"):<br />

  <ul>
    <li>
    <a name="SWI">
    <b>SWI</b></a> - In order to make a context switch, the RTOS needs a SWI (software interrupt).
    </li>
  </ul>
  </li>
  <li>
  <a name="UsePreemption">
  <b>Preemptive</b></a> - Set to 1 to use the preemptive kernel, or 0 to use the cooperative kernel. (configUSE_PREEMPTION flag)
  </li>
  <li>
  <a name="UseCoroutines">
  <b>Use Co-Routines</b></a> - Set to 1 to include co-routine functionality in the build, or 0 to omit co-routine functionality from the build. To include co-routines croutine.c must be included in the project. 
  </li>
  <li>
  <a name="IdleShouldYield">
  <b>Idle should yield</b></a> - This parameter controls the behaviour of tasks at the idle priority. It only has an effect if:<br />
   1. The preemptive scheduler is being used.<br />
   2. The users application creates tasks that run at the idle priority.<br />
Tasks that share the same priority will time slice. Assuming none of the tasks get preempted, it might be assumed that each task of at a given priority will be allocated an equal amount of processing time - and if the shared priority is above the idle priority then this is indeed the case. 
  </li>
  <li>
  <a name="TaskNameLength">
  <b>Task Name Length</b></a> - The maximum permissible length of the descriptive name given to a task when the task is created. The length is specified in the number of characters including the NULL termination byte. (configMAX_TASK_NAME_LEN)
  </li>
  <li>
  <a name="MinimalStackSize">
  <b>Minimal Stack Size</b></a> - The size of the stack used by the idle task (configMINIMAL_STACK_SIZE flag). Generally this should not be reduced from the value set in the FreeRTOSConfig.h file provided with the demo application for the port you are using. Note that the size is in stack units (portSTACK_TYPE), which is 4 bytes for a 32bit core like ColdFire and ARM/Kinetis and 1 byte for HCS08. Keep in mind that there is the IDLE task too which needs stack plus the task descriptor block.
  </li>
  <li>
  <a name="MaxPriority">
  <b>Maximum Priorities</b></a> - Each task is assigned a priority from 0 to ( configMAX_PRIORITIES - 1 ). configMAX_PRIORITIES is defined within FreeRTOSConfig.h and can be set on an application by application basis. The higher the value given to configMAX_PRIORITIES the more RAM the FreeRTOS kernel will consume. 
  </li>
  <li>
  <a name="MaxCoroutinePriorities">
  <b>Maximum Coroutine Priorities</b></a> - Each co-routine is assigned a priority from 0 to ( configMAX_CO_ROUTINE_PRIORITIES - 1 ). configMAX_CO_ROUTINE_PRIORITIES is defined within FreeRTOSConfig.h and can be set on an application by application basis. The higher the value given to configMAX_CO_ROUTINE_PRIORITIES the more RAM the FreeRTOS kernel will consume. 
  </li>
  <li>
  <a name="StackOverflowCheckingMethodNumber">
  <b>Stackoverflow checking method</b></a> - Stack Overflow Detection - Method 1<br />It is likely that the stack will reach its greatest (deepest) value after the kernel has swapped the task out of the Running state because this is when the stack will contain the task context. At this point the kernel can check that the processor stack pointer remains within the valid stack space. The stack overflow hook function is called if the stack pointer contain a value that is outside of the valid stack range.<br />This method is quick but not guaranteed to catch all stack overflows. Set configCHECK_FOR_STACK_OVERFLOW to 1 to use this method only.<br /><br />Stack Overflow Detection - Method 2<br />When a task is first created its stack is filled with a known value. When swapping a task out of the Running state the kernel can check the last 16 bytes within the valid stack range to ensure that these known values have not been overwritten by the task or interrupt activity. The stack overflow hook function is called should any of these 16 bytes not remain at their initial value.<br />This method is less efficient than method one, but still fairly fast. It is very likely to catch stack overflows but is still not guaranteed to catch all overflows.<br />To use this method in combination with method 1 set configCHECK_FOR_STACK_OVERFLOW to 2. It is not possible to use only this method.<br /><br />
There are 3 options:<br />
<ul>
  <li><u>Method 1</u>: It is likely that the stack will reach its greatest (deepest) value after the kernel has swapped the task out of the Running state because this is when the stack will contain the task context. At this point the kernel can check that the processor stack pointer remains within the valid stack space. The stack overflow hook function is called if the stack pointer contain a value that is outside of the valid stack range.  This method is quick but not guaranteed to catch all stack overflows.</li>
  <li><u>Method 2</u>: When a task is first created its stack is filled with a known value. When swapping a task out of the Running state the kernel can check the last 16 bytes within the valid stack range to ensure that these known values have not been overwritten by the task or interrupt activity. The stack overflow hook function is called should any of these 16 bytes not remain at their initial value.  This method is less efficient than method one, but still fairly fast. It is very likely to catch stack overflows but is still not guaranteed to catch all overflows.</li>
  <li><u>none</u>: No Stack Overflow checking</li>
</ul><br />

  </li>
  <li>
  <a name="CleanupResources">
  <b>Cleanup Resources</b></a> - This setting controls the INCLUDE_vTaskCleanUpResources define.
  </li>
</ul>
</li>
<li>
<a name="TicksGroup">
<b>Ticks</b></a> - Group controlling how ticks are handled
<ul>
  <li>
  <a name="TicklessIdleModeEnabled">
  <b>Tickless Idle Mode</b></a> - If supported, a tickless idle mode is used for power reduction. See http://www.freertos.org/low-power-tickless-rtos.html<br />
The following items are available only if the group is enabled (the value is "Enabled"):<br />

  <ul>
    <li>
    <a name="StoppedTimerCompensation">
    <b>Stopped Timer Compensation</b></a> - vPortSuppressTicksAndSleep() needs to stop the tick timer for a short time. This value compensates for the time delay. This value is assigned to configSTOPPED_TIMER_COMPENSATION in port.c
    </li>
    <li>
    <a name="ExpectedIdleTimeBeforeSleep">
    <b>Expected Idle Time (Ticks) before Sleep</b></a> - Tickless mode will only be entered if the idle ticks are larger than this value. This defines the value for configEXPECTED_IDLE_TIME_BEFORE_SLEEP.
    </li>
  </ul>
  </li>
  <li>
  <a name="TickRateHz">
  <b>Tick Rate (Hz)</b></a> - The frequency of the RTOS tick interrupt.<br />
<br />
The tick interrupt is used to measure time. Therefore a higher tick frequency means time can be measured to a higher resolution. However, a high tick frequency also means that the kernel will use more CPU time so be less efficient. The RTOS demo applications all use a tick rate of 1000Hz. This is used to test the kernel and is higher than would normally be required.<br />
<br />
More than one task can share the same priority. The kernel will share processor time between tasks of the same priority by switching between the tasks during each RTOS tick. A high tick rate frequency will therefore also have the effect of reducing the 'time slice' given to each task. 
  </li>
  <li>
  <a name="Use16bitTicks">
  <b>Use 16bit ticks</b></a> - Time is measured in 'ticks' - which is the number of times the tick interrupt has executed since the kernel was started. The tick count is held in a variable of type portTickType.<br />
Defining configUSE_16_BIT_TICKS as 1 causes portTickType to be defined (typedef'ed) as an unsigned 16bit type. Defining configUSE_16_BIT_TICKS as 0 causes portTickType to be defined (typedef'ed) as an unsigned 32bit type.<br />
Using a 16 bit type will greatly improve performance on 8 and 16 bit architectures, but limits the maximum specifiable time period to 65535 'ticks'. Therefore, assuming a tick frequency of 250Hz, the maximum time a task can delay or block when a 16bit counter is used is 262 seconds, compared to 17179869 seconds when using a 32bit counter. 
  </li>
  <li>
  <a name="NonLDDTickGroup">
  <b>non-LDD Tick</b></a> - Group for classic non-LDD components<br />
The following items are available only if the group is enabled (the value is "Enabled"):<br />

  <ul>
    <li>
    <a name="TickCntr">
    <b>Tick Counter</b></a> - Timer generating the ticks for the RTOS
    </li>
  </ul>
  </li>
  <li>
  <a name="LDDTickGroup">
  <b>LDD Tick</b></a> - Group for Logical Device Drivers<br />
The following items are available only if the group is enabled (the value is "Enabled"):<br />

  <ul>
    <li>
    <a name="TickTimerLDD">
    <b>Tick Timer</b></a> - Tick Timer Interrupt
    </li>
  </ul>
  </li>
</ul>
</li>
<li>
<a name="QueuesGroup">
<b>Queues</b></a> - This group defines how queues are handled
<ul>
  <li>
  <a name="QueueRegistrySize">
  <b>Queue Registry Size</b></a> - The queue registry has two purposes, both of which are associated with kernel aware debugging:<br />
   1. It allows a textual name to be associated with a queue for easy queue identification within a debugging GUI.<br />
   2. It contains the information required by a debugger to locate each registered queue and semaphore.<br />
The queue registry has no purpose unless you are using a kernel aware debugger.<br />
configQUEUE_REGISTRY_SIZE defines the maximum number of queues and semaphores that can be registered. Only those queues and semaphores that you want to view using a kernel aware debugger need be registered. See the API reference documentation for vQueueAddToRegistry() and vQueueUnregisterQueue() for more information.
  </li>
  <li>
  <a name="useQueueSets">
  <b>Queue Sets</b></a> - If queue sets are supported. This sets configUSE_QUEUE_SETS in FreeRTOSConfig.h
  </li>
</ul>
</li>
<li>
<a name="MutexGroup">
<b>Semaphores and Mutexes</b></a> - This group defines how semaphores and mutexes are handled
<ul>
  <li>
  <a name="UseMutexes">
  <b>Use Mutexes</b></a> - Set to 1 to include mutex functionality in the build, or 0 to omit mutex functionality from the build. Readers should familiarise themselves with the differences between mutexes and binary semaphores in relation to the FreeRTOS.org functionality.
  </li>
  <li>
  <a name="UseRecursiveMutexes">
  <b>Use Recursive Mutexes</b></a> - Set to 1 to include recursive mutex functionality in the build, or 0 to omit recursive mutex functionality from the build. This affects if xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() are available or not.
  </li>
</ul>
</li>
<li>
<a name="TimersEnabled">
<b>Timers</b></a> - Group configuring the software timers<br />
The following items are available only if the group is enabled (the value is "Enabled"):<br />

<ul>
  <li>
  <a name="TimerTaskPriority">
  <b>Priority</b></a> - Priority of the software timer task (configTIMER_TASK_PRIORITY)
  </li>
  <li>
  <a name="TimerTaskQueueLength">
  <b>Queue Length</b></a> - Sets configTIMER_QUEUE_LENGTH
  </li>
  <li>
  <a name="TimerTaskStackDepth">
  <b>Stack Depth</b></a> - configures the value of configTIMER_TASK_STACK_DEPTH which defines the stack size for the timer task
  </li>
</ul>
</li>
<li>
<a name="MemoryGroup">
<b>Memory</b></a> - This group controls the heap and memory settings
<ul>
  <li>
  <a name="MemoryScheme">
  <b>Memory Allocation Scheme</b></a> - Scheme 1:<br />This is the simplest scheme of all. It does not permit memory to be freed once it has been allocated, but despite this is suitable for a surprisingly large number of applications.<br />The algorithm simply subdivides a single array into smaller blocks as requests for RAM are made. The total size of the array is set by the definition configTOTAL_HEAP_SIZE - which is defined in FreeRTOSConfig.h.<br />This scheme:<br />    * Can be used if your application never deletes a task or queue (no calls to vTaskDelete() or vQueueDelete() are ever made).<br />    * Is always deterministic (always takes the same amount of time to return a block).<br />heap_1.c is suitable for a lot of small real time systems provided that all tasks and queues are created before the kernel is started.<br /><br />Scheme 2:<br />This scheme uses a best fit algorithm and, unlike scheme 1, allows previously allocated blocks to be freed. It does not however combine adjacent free blocks into a single large block.<br />Again the total amount of available RAM is set by the definition configTOTAL_HEAP_SIZE - which is defined in FreeRTOSConfig.h.<br />This scheme:<br />    * Can be used even when the application repeatedly calls vTaskCreate()/vTaskDelete() or vQueueCreate()/vQueueDelete() (causing multiple calls to pvPortMalloc() and vPortFree()).<br />    * Should not be used if the memory being allocated and freed is of a random size - this would only be the case if tasks being deleted each had a different stack depth, or queues being deleted were of different lengths.<br />    * Could possible result in memory fragmentation problems should your application create blocks of queues and tasks in an unpredictable order. This would be unlikely for nearly all applications but should be kept in mind.<br />    * Is not deterministic - but is also not particularly inefficient.<br />heap_2.c is suitable for most small real time systems that have to dynamically create tasks.<br /><br />Scheme 3:<br />This is just a wrapper for the standard malloc() and free() functions. It makes them thread safe.<br />This scheme:<br />    * Requires the linker to setup a heap, and the compiler library to provide malloc() and free() implementations.<br />    * Is not deterministic.<br />    * Will probably considerably increase the kernel code size.<br /><br />Scheme 4:<br />This scheme uses a first fit algorithm and, unlike scheme 2, does combine adjacent free memory blocks into a single large block (it does include a coalescence algorithm). The total amount of available heap space is set by configTOTAL_HEAP_SIZE - which is defined in FreeRTOSConfig.h. The xPortGetFreeHeapSize() API function returns the total amount of heap space that remains unallocated (allowing the configTOTAL_HEAP_SIZE setting to be optimised), but does not provided information on how the unallocated memory is fragmented into smaller blocks.<br />This implementation:<br />   * Can be used even when the application repeatedly deletes tasks, queues, semaphores, mutexes, etc..<br />   * Is much less likely than the heap_2 implementation to result in a heap space that is badly fragmented into multiple small blocks - even when the memory being allocated and freed is of random size.<br />   * Is not deterministic - but is much more efficient that most standard C library malloc implementations.<br />heap_4.c is particularly useful for applications that want to use the portable layer memory allocation schemes directly in the application code (rather than just indirectly by calling API functions that themselves call pvPortMalloc() and vPortFree()). <br /><br />
There are 4 options:<br />
<ul>
  <li><u>Scheme 1</u>: This is the simplest scheme of all. It does not permit memory to be freed once it has been allocated, but despite this is suitable for a surprisingly large number of applications.</li>
  <li><u>Scheme 2</u>: This scheme uses a best fit algorithm and, unlike scheme 1, allows previously allocated blocks to be freed. It does not however combine adjacent free blocks into a single large block.</li>
  <li><u>Scheme 3</u>: This is just a wrapper for the standard malloc() and free() functions. It makes them thread safe.</li>
  <li><u>Scheme 4</u>: This scheme includes memory block coalescence.</li>
</ul><br />

  </li>
  <li>
  <a name="UserHeapSectionEnabled">
  <b>User Heap Section</b></a> - An optional user section attribute can be provided to place the heap into a user section. This is for example needed for the Kinetis K series where the RAM area is splitted. With this, e.g.  __attribute__((section (&quot;.m_data_20000000&quot;))) can be specified for the heap object in heap.c<br />
The following items are available only if the group is enabled (the value is "Enabled"):<br />

  <ul>
    <li>
    <a name="HeapSectionName">
    <b>Heap Section Name</b></a> - Use &quot;.m_data_20000000&quot; for gcc, and &quot;m_data_20000000&quot; for IAR. The following will be added to the heap variable: __attribute__((section (&quot;sectionName&quot;))). For IAR a similar construct is used.
    </li>
  </ul>
  </li>
  <li>
  <a name="TotalHeapSize">
  <b>Total Heap Size</b></a> - The total amount of RAM available to the kernel. This value is used by the memory allocation schemes.
  </li>
</ul>
</li>
<li>
<a name="CommandInterpreterEnabled">
<b>Command Interpreter</b></a> - Settings for the Command Interpreter. Earlier FreeRTOS included an open source command interpreter, now this has moved to a non-free-of-charge FreeRTOS+ version. This port includes for compatibility the original and free version of it.<br />
The following items are available only if the group is enabled (the value is "Enabled"):<br />

<ul>
  <li>
  <a name="CommandIntMaxOutputSize">
  <b>Output Buffer Size</b></a> - Buffer size into which command outputs can be written. This defines configCOMMAND_INT_MAX_OUTPUT_SIZE
  </li>
</ul>
</li>
<li>
<a name="ShellEnabled">
<b>Shell</b></a> - If shell support shall be added or not<br />
The following items are available only if the group is enabled (the value is "Enabled"):<br />

<ul>
  <li>
  <a name="Shell">
  <b>Shell</b></a> - Interface to shell
  </li>
</ul>
</li>

     </ul>
<!---USERBEG DON'T CHANGE THIS LINE-->

<!---USEREND DON'T CHANGE THIS LINE-->
</div>
           <p class="footer">
            PROCESSOR EXPERT is trademark of Freescale Semiconductor, Inc.
            <br />
            
           </p>
    </td>
  </tr>

</table>

</body>
</html>
