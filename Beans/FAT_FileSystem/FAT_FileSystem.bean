<?xml version="1.0" encoding="UTF-8"?>
<Bean>
  <Header>
    <Name>FAT_FileSystem</Name>
    <Description>FAT file system module</Description>
    <Author>ChaN, adopted by Erich Styger for Processor Expert</Author>
    <Version>01.142</Version>
    <Icon>FAT_FileSystem</Icon>
    <TypesFiles>PE,FAT_FileSystem\FAT_FileSystem</TypesFiles>
    <FileVersion>6</FileVersion>
  </Header>
  <Options>
    <Category>SW-Memory Manager</Category>
    <BW_HelpType>Basic</BW_HelpType>
    <BW_HelpFiles>,Properties,Methods,Events</BW_HelpFiles>
    <BW_AutoSaveHelp>yes</BW_AutoSaveHelp>
    <BW_AutoSaveDriver>yes</BW_AutoSaveDriver>
    <BW_DetailedHelp>yes</BW_DetailedHelp>
    <BW_NeedTps>yes</BW_NeedTps>
    <BW_NeedUst>4</BW_NeedUst>
    <BW_NeedCns>0</BW_NeedCns>
    <BeanStatus>PROPOSAL</BeanStatus>
    <Copyright>License   :  Open Source (LGPL)\nCopyright : (c) Copyright Erich Styger, 2013, all rights reserved.\nFatFS: Copyright (C) 2013, ChaN, all right reserved. (see copyright notice and license in the FatFS implementation).\n\nThis an open source software implementing an interface to the ChaN FatFS using Processor Expert.\nThis is a free software and is opened for education,  research and commercial developments under license policy of following terms:\n* This is a free software and there is NO WARRANTY.\n* No restriction on use. You can use, modify and redistribute it for personal, non-profit or commercial product UNDER YOUR RESPONSIBILITY.\n* Redistributions of source code must retain the above copyright notice.</Copyright>
    <Shortcut>FAT</Shortcut>
    <DemoDriver>no</DemoDriver>
    <BeanLevel>High</BeanLevel>
  </Options>
  <PropertyList>
    <Property>
      <TCompNameItem>
        <Name>Component name</Name>
        <Symbol>DeviceName</Symbol>
        <Hint>Name of the component.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue/>
      </TCompNameItem>
    </Property>
    <Property>
      <TStrgItem>
        <Name>FatFs Version</Name>
        <Symbol>FatFsVersion</Symbol>
        <Hint>Indentifies the version of FatFs used</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <ReadOnly>true</ReadOnly>
        <EditLine>true</EditLine>
        <DefaultValue>R0.08a</DefaultValue>
        <StrDefine>nothing</StrDefine>
        <MinLength>0</MinLength>
        <MaxLength>-1</MaxLength>
      </TStrgItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Tiny</Name>
        <Symbol>Tiny</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>If the file system shall be really small and tiny. This corresponds to the _FS_TINY flag. If enabled, FatFs uses the sector buffer in the file system object instead of the sector buffer in the individual file object for file data transfer. This reduces memory consumption 512 bytes each file object.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Volumes</Name>
        <Symbol>Volumes</Symbol>
        <Hint>Number of volumes (logical drives) to be used.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>1</DefaultValue>
        <MinValue>1</MinValue>
        <MaxValue>255</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>FS_MINIMIZE</Name>
        <Symbol>FS_MINIMIZE</Symbol>
        <Hint>The _FS_MINIMIZE option defines minimization level to remove some functions.\n
0: Full function.\n
1: f_stat, f_getfree, f_unlink, f_mkdir, f_chmod, f_truncate and f_rename are removed.\n
2: f_opendir and f_readdir are removed in addition to 1.\n
3: f_lseek is removed in addition to 2.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>0</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>3</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TEnumItem>
        <Name>Maximum Sector Size</Name>
        <Symbol>MaxSectorSize</Symbol>
        <TypeSpec>typeMaxSS</TypeSpec>
        <Hint>Specifies the maximum sector size (in bytes) to be handled. This number affects the buffer size allocated in FatFS, so the higher the number, the more memory is used. This controls the _MAX_SS macro. When _MAX_SS &gt; 512, GET_SECTOR_SIZE must be implemented to disk_ioctl().</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
      </TEnumItem>
    </Property>
    <Property>
      <TEnumItem>
        <Name>Relative Path</Name>
        <Symbol>RelativePath</Symbol>
        <TypeSpec>typeRelPath</TypeSpec>
        <Hint>This option configures the relative path feature. It sets the _FS_RPATH variable.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>2</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
      </TEnumItem>
    </Property>
    <Property>
      <TEnumItem>
        <Name>Code Page</Name>
        <Symbol>CodePage</Symbol>
        <TypeSpec>typeCodePage</TypeSpec>
        <Hint>The _CODE_PAGE specifies the OEM code page to be used on the target system. Incorrect setting of the code page can cause a file open failure.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
      </TEnumItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>File Sharing</Name>
        <Symbol>FsShare</Symbol>
        <Hint>Enables the file sharing feature if value is greater than zero. The value defines how many files can be open simultaneously. This option sets _FS_SHARE.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>0</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Multipartion</Name>
        <Symbol>MultiPartitionEnabled</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>When _MULTI_PARTITION is disabled, each volume is bound to the same physical drive number and can mount only first primaly partition. When it is enabled, each volume is tied to the partitions listed in Drives[].</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Fast Seek</Name>
        <Symbol>FastSeekEnabled</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>Enable or disable the fast seek feature. This option sets the _USE_FASTSEEK define.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Use Erase</Name>
        <Symbol>UseErase</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>To enable sector erase feature, set _USE_ERASE to 1.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TEnumItem>
        <Name>String Functions</Name>
        <Symbol>UseStringFunctions</Symbol>
        <TypeSpec>typeUseStrFunc</TypeSpec>
        <Hint>Configures string functions (macro _USE_STRFUNC in ffconf.h)</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
      </TEnumItem>
    </Property>
    <Property>
      <TGrupItem>
        <Name>LFN</Name>
        <Symbol>LFNGroup</Symbol>
        <Hint>Long File Name (LFN)</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>Long File Name Support</Description>
        <Expanded>Yes</Expanded>
        <Children>
          <GrupItem>
            <TEnumItem>
              <Name>Use LFN</Name>
              <Symbol>UseLFN</Symbol>
              <TypeSpec>typeLFN</TypeSpec>
              <Hint>Configures how LFN (Long File Names) shall be used</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>0</DefaultIndex>
              <TextValueIndex>true</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
            </TEnumItem>
          </GrupItem>
          <GrupItem>
            <TIntgItem>
              <Name>Max LFN Length</Name>
              <Symbol>MaxLFN</Symbol>
              <Hint>Maximum LFN length to handle</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>255</DefaultValue>
              <MinValue>12</MinValue>
              <MaxValue>255</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>false</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>LFN Unicode</Name>
              <Symbol>LFNUnicode</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>If for long file names the names shall be ANSI/OEM (no) or in unicode (yes)</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>1</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>false</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
        </Children>
      </TGrupItem>
    </Property>
    <Property>
      <TBoolGrupItem>
        <Name>Write enabled</Name>
        <Symbol>WriteEnabled</Symbol>
        <TypeSpec>typeEnaDis</TypeSpec>
        <Hint>If disabled, the driver is in read only mode. This corresponds to the _FS_READONLY flag.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>Enabled</Description>
        <Expanded>Yes</Expanded>
        <DefaultValue>true</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <Children>
          <GrupItem>
            <TBoolGrupItem>
              <Name>Use TimeDate</Name>
              <Symbol>UseTimeDate</Symbol>
              <TypeSpec>typeEnaDis</TypeSpec>
              <Hint>If enabled, it uses the TimeDate component to provde time and date information to the FatFS. If disabled, you need to provide your own implementation.\n
You need to implement your own 'DWORD get_fattime (void)', see the implementation example in diskio.c</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description>Enabled</Description>
              <Expanded>Yes</Expanded>
              <DefaultValue>true</DefaultValue>
              <DefineSymbol>YES_NO</DefineSymbol>
              <IfDisabled>setNOTHING</IfDisabled>
              <Children>
                <GrupItem>
                  <TInhrLinkItem>
                    <Name>Realtime clock</Name>
                    <Symbol>RTC</Symbol>
                    <TypeSpec>FAT_FileSystem\RTC</TypeSpec>
                    <Hint>Interface to real time clock. Needed for time file time</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>false</EditLine>
                    <DefaultValue/>
                    <CanDelete>false</CanDelete>
                    <IconPopup>false</IconPopup>
                    <SortStyle/>
                  </TInhrLinkItem>
                </GrupItem>
              </Children>
            </TBoolGrupItem>
          </GrupItem>
        </Children>
      </TBoolGrupItem>
    </Property>
    <Property>
      <TBoolGrupItem>
        <Name>Reentrant</Name>
        <Symbol>Reentrant</Symbol>
        <TypeSpec>typeEnaDis</TypeSpec>
        <Hint>If the driver shall be reentrant. This defines the _FS_REENTRANT define.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>Disabled</Description>
        <Expanded>Yes</Expanded>
        <DefaultValue>false</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <Children>
          <GrupItem>
            <TIntgItem>
              <Name>Timeout ticks</Name>
              <Symbol>TimeoutTicks</Symbol>
              <Hint>Timeout period in unit of time ticks of the OS</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>1000</DefaultValue>
              <MinValue>0</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC HEX</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>false</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TStrgItem>
              <Name>Handle</Name>
              <Symbol>HandleStr</Symbol>
              <Hint>Type of sync object used on the OS. e.g. HANDLE, OS_EVENT*, ID and etc. If you are enabling an RTOS, then this handle is replaced by the one of the RTOS</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>HANDLE</DefaultValue>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
            </TStrgItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>User Sync Functions</Name>
              <Symbol>UserSyncFunctions</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>If set to 'yes', you have to provide your own ff_cre_syncobj(), ff_del_syncobj(), ff_req_grant() and ff_rel_grant() functions. Otherwise the component will provide an implementation.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>1</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>false</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TBoolGrupItem>
              <Name>RTOS</Name>
              <Symbol>RTOSenabled</Symbol>
              <TypeSpec>typeEnaDis</TypeSpec>
              <Hint>Configures the RTOS to be used. If enabled, it will use an RTOS synchronization method (e.g. semaphore) to protect access to the file system object.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description>Enabled</Description>
              <Expanded>Yes</Expanded>
              <DefaultValue>true</DefaultValue>
              <DefineSymbol>YES_NO</DefineSymbol>
              <IfDisabled>setNOTHING</IfDisabled>
              <Children>
                <GrupItem>
                  <TInhrLinkItem>
                    <Name>RTOS</Name>
                    <Symbol>RTOS</Symbol>
                    <TypeSpec>FAT_FileSystem\RTOS</TypeSpec>
                    <Hint>RTOS to be used</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>false</EditLine>
                    <DefaultValue/>
                    <CanDelete>false</CanDelete>
                    <IconPopup>false</IconPopup>
                    <SortStyle/>
                  </TInhrLinkItem>
                </GrupItem>
                <GrupItem>
                  <TBoolItem>
                    <Name>Use dynamic heap</Name>
                    <Symbol>UseRTOSDynamicMemory</Symbol>
                    <TypeSpec>typeYesNo</TypeSpec>
                    <Hint>If dynamic memory (malloc(), free()) of the RTOS shall be used. This will reduce the amount of stack and global memory used, but requires memory from the operating system.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>false</EditLine>
                    <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
                    <DefaultIndex>0</DefaultIndex>
                    <TextValueIndex>false</TextValueIndex>
                    <RuntimeProperty>false</RuntimeProperty>
                    <CanDelete>false</CanDelete>
                    <IconPopup>false</IconPopup>
                    <DefaultValue>true</DefaultValue>
                    <Popup>false</Popup>
                  </TBoolItem>
                </GrupItem>
              </Children>
            </TBoolGrupItem>
          </GrupItem>
        </Children>
      </TBoolGrupItem>
    </Property>
    <Property>
      <TInhrLinkItem>
        <Name>Memory</Name>
        <Symbol>Memory</Symbol>
        <TypeSpec>FAT_FileSystem\Memory</TypeSpec>
        <Hint>Interface for the underlying memory (e.g. SD Card)</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <DefaultValue/>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <SortStyle/>
      </TInhrLinkItem>
    </Property>
    <Property>
      <TBoolGrupItem>
        <Name>Shell</Name>
        <Symbol>ShellEnabled</Symbol>
        <TypeSpec>typeEnaDis</TypeSpec>
        <Hint>If enabled, the component offers a command line shell interface</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>Disabled</Description>
        <Expanded>Yes</Expanded>
        <DefaultValue>false</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <Children>
          <GrupItem>
            <TInhrLinkItem>
              <Name>Shell</Name>
              <Symbol>Shell</Symbol>
              <TypeSpec>FAT_FileSystem\Shell</TypeSpec>
              <Hint>Interface to command line shell</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <DefaultValue/>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <SortStyle/>
            </TInhrLinkItem>
          </GrupItem>
          <GrupItem>
            <TInhrLinkItem>
              <Name>Utility</Name>
              <Symbol>Utility</Symbol>
              <TypeSpec>FAT_FileSystem\Utility</TypeSpec>
              <Hint>Interface to utility functions</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <DefaultValue/>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <SortStyle/>
            </TInhrLinkItem>
          </GrupItem>
          <GrupItem>
            <TIntgItem>
              <Name>File print buffer size</Name>
              <Symbol>FilePrintBufferSize</Symbol>
              <Hint>Size of read buffer on stack for PrintFile() method: a higher number increases performance, but increases memory used on the stack.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>32</DefaultValue>
              <MinValue>4</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>false</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TIntgItem>
              <Name>File copy buffer size</Name>
              <Symbol>FileCopyBufferSize</Symbol>
              <Hint>Size of copy buffer on stack for CopyFile() method: a higher number increases performance, but increases memory used on the stack.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>32</DefaultValue>
              <MinValue>4</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>false</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
        </Children>
      </TBoolGrupItem>
    </Property>
  </PropertyList>
  <MethodList>
    <Method>
      <TMthdItem>
        <Name>open</Name>
        <Symbol>open</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Open/Create a file</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>FRESULT</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>fp</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to the blank file object structure</ParHint>
          <ParUserDeclaration>FIL *fp</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>path</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to a null-terminated string that specifies the file name to create or open.</ParHint>
          <ParUserDeclaration>const XCHAR *path</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>mode</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Specifies the type of access and open method for the file. It is specified by a combination of following flags.\nFA_READ: Specifies read access to the object. Data can be read from the file. Combine with FA_WRITE for read-write access.\nFA_WRITE: Specifies write access to the object. Data can be written to the file. Combine with FA_READ for read-write access.\nFA_OPEN_EXISTING: Opens the file. The function fails if the file is not existing. (Default)\nFA_OPEN_ALWAYS: Opens the file if it is existing. If not, a new file is created. To append data to the file, use f_lseek function after file open in this method.\nFA_CREATE_NEW: Creates a new file. The function fails if the file is already existing.\nFA_CREATE_ALWAYS: Creates a new file. If the file is existing, it is truncated and overwritten.</ParHint>
          <ParUserDeclaration>BYTE mode</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>FRESULT #M#_#C#(FIL *fp, const XCHAR *path, BYTE mode)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>close</Name>
        <Symbol>close</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Close a file</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>FRESULT</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>fp</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to the open file object structure to be closed.</ParHint>
          <ParUserDeclaration>FIL *fp</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>FRESULT #M#_#C#(FIL *fp)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>read</Name>
        <Symbol>read</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Read file</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>FRESULT</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>4</ParamCount>
        <Parameter>
          <ParName>fp</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to the file object</ParHint>
          <ParUserDeclaration>FIL *fp</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>buff</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to the data buffer</ParHint>
          <ParUserDeclaration>void *buff</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>btr</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Number of bytes to read</ParHint>
          <ParUserDeclaration>UINT btr</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>br</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to the number of bytes read</ParHint>
          <ParUserDeclaration>UINT *br</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>FRESULT #M#_#C#(FIL *fp, void *buff, UINT btr, UINT *br)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>write</Name>
        <Symbol>write</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Write to a file</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>FRESULT</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>4</ParamCount>
        <Parameter>
          <ParName>fp</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to the file object structure </ParHint>
          <ParUserDeclaration>FIL *fp</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>buff</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to the data to be written</ParHint>
          <ParUserDeclaration>const *void buff</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>btw</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Number of bytes to write</ParHint>
          <ParUserDeclaration>UINT btw</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>bw</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to the variable to return number of bytes written</ParHint>
          <ParUserDeclaration>UINT *bw</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>FRESULT #M#_#C#(FIL *fp, const *void buff, UINT btw, UINT *bw)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>opendir</Name>
        <Symbol>opendir</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Open a directory</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>FRESULT</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>dj</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to the blank directory object to be created.</ParHint>
          <ParUserDeclaration>DIR *dj</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>path</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to the null-terminated string that specifies the directory name to be opened.</ParHint>
          <ParUserDeclaration>const XCHAR *path</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>FRESULT #M#_#C#(DIR *dj, const XCHAR *path)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>readdir</Name>
        <Symbol>readdir</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Read a directory item</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>FRESULT</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>dir</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to the open directory object</ParHint>
          <ParUserDeclaration>DIR *dj</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>fno</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to the file information structure</ParHint>
          <ParUserDeclaration>FILINFO *fno</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>FRESULT #M#_#C#(DIR *dj, FILINFO *fno)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>lseek</Name>
        <Symbol>lseek</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>The f_lseek function moves the file read/write pointer of an open file object. It can also be used to increase the file size (cluster pre-allocation).</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>FRESULT</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>fp</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to the file object</ParHint>
          <ParUserDeclaration>FIL *fp</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>ofs</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>File pointer from top of file</ParHint>
          <ParUserDeclaration>DWORD ofs</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>FRESULT #M#_#C#(FIL *fp, DWORD ofs)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>unlink</Name>
        <Symbol>unlink</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Remove a file or directory</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>FRESULT</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>path</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to the object name</ParHint>
          <ParUserDeclaration>const XCHAR *path</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>FRESULT #M#_#C#(const XCHAR *path)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>mount</Name>
        <Symbol>mount</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Mount/unmount a logical drive</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>FRESULT</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>vol</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>logical drive number to be mounted/unmounted</ParHint>
        </Parameter>
        <Parameter>
          <ParName>fs</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>pointer to the new file system object (NULL for unmount)</ParHint>
          <ParUserDeclaration>FATFS *fs</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>FRESULT #M#_#C#(byte vol, FATFS *fs)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>getfree</Name>
        <Symbol>getfree</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Get Number of Free Clusters</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>FRESULT</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>path</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to the logical drive number (root dir)</ParHint>
          <ParUserDeclaration>const XCHAR *path</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>nclst</ParName>
          <ParType>32bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to the variable to return number of free clusters</ParHint>
        </Parameter>
        <Parameter>
          <ParName>fatfs</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to pointer to file system object</ParHint>
          <ParUserDeclaration>FATFS **fatfs</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>FRESULT #M#_#C#(const XCHAR *path, dword *nclst, FATFS **fatfs)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>sync</Name>
        <Symbol>sync</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Flush cached data of a writing file</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>FRESULT</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>fp</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to the file object</ParHint>
          <ParUserDeclaration>FIL *fp</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>FRESULT #M#_#C#(FIL *fp)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>rename</Name>
        <Symbol>rename</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Delete a file or directory</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>FRESULT</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>path_old</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to old object name</ParHint>
          <ParUserDeclaration>const XCHAR *path_old</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>path_new</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to new object name</ParHint>
          <ParUserDeclaration>const XCHAR *path_new</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>FRESULT #M#_#C#(const XCHAR *path_old, const XCHAR *path_new)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>isWriteProtected</Name>
        <Symbol>isWriteProtected</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Determines if the file system is write protected.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>Boolean</ReturnType>
        <RetHint>TRUE if file system is write protected</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>bool #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>isDiskPresent</Name>
        <Symbol>isDiskPresent</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Determines if the disk is present or not (e.g. disk inserted).</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>Boolean</ReturnType>
        <RetHint>TRUE if file system is write protected</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>bool #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>mkdir</Name>
        <Symbol>mkdir</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Creates a directory</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>FRESULT</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>path</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Name of directory to be created</ParHint>
          <ParUserDeclaration>const XCHAR *path</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>FRESULT #M#_#C#(const XCHAR *path)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>chmod</Name>
        <Symbol>chmod</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Changes the attribute of a file or directory\n
Following attribute flags to be set in one or more combination of the following flags. The specified flags are set and others are cleared.\n
AM_RDO	Read only\n
AM_ARC	Archive\n
AM_SYS	System\n
AM_HID	Hidden</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>FRESULT</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>FileName</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to the file or directory</ParHint>
          <ParUserDeclaration>const TCHAR* FileName</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>Attribute</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Attribute flags. Attribute flags to be set in one or more combination of the following flags. The specified flags are set and others are cleard.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>AttributeMask</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Attribute mask. Attribute mask that specifies which attribute is changed. The specified aattributes are set or cleard.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>FRESULT #M#_#C#(const TCHAR* FileName, byte Attribute, byte AttributeMask)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>truncate</Name>
        <Symbol>truncate</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Truncates the file size.\n
The truncate() function truncates the file size to the current file read/write point. This function has no effect if the file read/write pointer is already pointing end of the file.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>FRESULT</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>FileObject</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to the file object</ParHint>
          <ParUserDeclaration>FIL *FileObject</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>FRESULT #M#_#C#(FIL *FileObject)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>stat</Name>
        <Symbol>stat</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>The f_stat gets the information of a file or directory. For details of the infomation, refer to the FILINFO structure and f_readdir function. This function is not supported in minimization level of &gt;= 1.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>FRESULT</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>FileName</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to the file or directory path</ParHint>
          <ParUserDeclaration>const TCHAR* FileName</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>FileInfo</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to the FILINFO structure</ParHint>
          <ParUserDeclaration>FILINFO* FileInfo</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>FRESULT #M#_#C#(const TCHAR* FileName, FILINFO* FileInfo)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>utime</Name>
        <Symbol>utime</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>The f_utime function changes the timestamp of a file or directory</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>FRESULT</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>FileName</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to the file or directory path</ParHint>
          <ParUserDeclaration>const TCHAR* FileName</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>TimeDate</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to time and data to be set</ParHint>
          <ParUserDeclaration>const FILINFO* TimeDate</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>FRESULT #M#_#C#(const TCHAR* FileName, const FILINFO* TimeDate)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>mkfs</Name>
        <Symbol>mkfs</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>The f_mkfs fucntion creates a file system on the drive.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>FRESULT</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>drive</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Logical drive number</ParHint>
        </Parameter>
        <Parameter>
          <ParName>PartitioningRule</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>When 0 is given, a partition table is created into the master boot record and a primary DOS partition is created and then an FAT volume is created on the partition. This is called FDISK format and used for harddisk and memory cards. When 1 is given, the FAT volume starts from the first sector on the drive without partition table. This is called SFD format and used for floppy disk and most optical disk</ParHint>
        </Parameter>
        <Parameter>
          <ParName>AllocSize</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Size of the allocation unit. Force the allocation unit (cluster) size in unit of byte. The value must be power of 2 and between the sector size and 128 times sector size. When invalid value is specified, the cluster size is determined depends on the volume size.</ParHint>
          <ParUserDeclaration>UINT  AllocSize</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>FRESULT #M#_#C#(byte drive, byte PartitioningRule, UINT  AllocSize)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>forward</Name>
        <Symbol>forward</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>The f_forward function reads the data from the file and forward it to the outgoing stream without data buffer. This is suitable for small memory system because it does not require any data buffer at application module. The file pointer of the file object increases in number of bytes forwarded. In case of *ByteFwd &lt; ByteToFwd without error, it means the requested bytes could not be transferred due to end of file or stream goes busy during data transfer.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>FRESULT</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>4</ParamCount>
        <Parameter>
          <ParName>FileObject</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to the open file object.</ParHint>
          <ParUserDeclaration>FIL* FileObject</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>Func</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to the user-defined data streaming function. For details, refer to the sample code.</ParHint>
          <ParUserDeclaration>UINT (*Func)(const BYTE*,UINT)</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>ByteToFwd</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Number of bytes to forward in range of UINT.</ParHint>
          <ParUserDeclaration>UINT ByteToFwd</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>ByteFwd</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to the UINT variable to return number of bytes forwarded.</ParHint>
          <ParUserDeclaration>UINT* ByteFwd </ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>FRESULT #M#_#C#(FIL* FileObject, UINT (*Func)(const BYTE*,UINT), UINT ByteToFwd, UINT* ByteFwd )</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>chdir</Name>
        <Symbol>chdir</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>The f_chdir function changes the current directory of the logical drive. The current directory of a drive is initialized to the root directory when the drive is auto-mounted. Note that the current directory is retained in the each file system object so that it also affects other tasks that using the drive.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>FRESULT</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>Path</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to the path name</ParHint>
          <ParUserDeclaration>const TCHAR* Path</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>FRESULT #M#_#C#(const TCHAR* Path)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>chdrive</Name>
        <Symbol>chdrive</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>The f_chdrive function changes the current drive. The initial value of the current drive number is 0. Note that the current drive is retained in a static variable so that it also affects other tasks that using the file functions.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>FRESULT</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>Drive</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Logical drive number</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>FRESULT #M#_#C#(byte Drive)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>getcwd</Name>
        <Symbol>getcwd</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>The f_getcwd function retrieves the current directory of the current drive in full path string including drive number.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>FRESULT</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>Buffer</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to the buffer to receive the current directory string.</ParHint>
          <ParUserDeclaration>TCHAR* Buffer</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>BufferLen</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Size of the buffer in unit of TCHAR.</ParHint>
          <ParUserDeclaration>UINT BufferLen</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>FRESULT #M#_#C#(TCHAR* Buffer, UINT BufferLen)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>errFResultMsg</Name>
        <Symbol>errFResultMsg</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Returns for a given FatFs FRESULT error code a string</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>string</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>errNo</ParName>
          <ParType>16bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>FatFs error code</ParHint>
          <ParUserDeclaration>int errNo</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>char* #M#_#C#(int errNo)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>errDResultMsg</Name>
        <Symbol>errDResultMsg</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Returns for a given FatFs DRESULT error code a string</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>string</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>errNo</ParName>
          <ParType>16bit signed</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>FatFs error code</ParHint>
          <ParUserDeclaration>int errNo</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>char* #M#_#C#(int errNo)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>f_gets</Name>
        <Symbol>f_gets</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Get a string from the file</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>CHARP</ReturnType>
        <RetHint>zero (NULL) if failed, otherwise a string to the buffer is returned.</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>buff</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to the string buffer to read </ParHint>
          <ParUserDeclaration>TCHAR* buff</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>len</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Size of string buffer (characters)</ParHint>
          <ParUserDeclaration>int len</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>fil</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to the file object</ParHint>
          <ParUserDeclaration>FIL *fil</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>%'ModuleName'_CHARP #M#_#C#(TCHAR* buff, int len, FIL *fil)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>f_puts</Name>
        <Symbol>f_puts</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Put a string to the file</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>INT</ReturnType>
        <RetHint>number of characters written.</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>buff</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>A character to be output</ParHint>
          <ParUserDeclaration>const TCHAR* str</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>fil</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to the file object</ParHint>
          <ParUserDeclaration>FIL *fil</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>%'ModuleName'_INT #M#_#C#(const TCHAR* str, FIL *fil)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>f_putc</Name>
        <Symbol>f_putc</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Put a character to the file</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>INT</ReturnType>
        <RetHint>1 if ok, EOF otherwise</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>buff</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>A character to be output</ParHint>
          <ParUserDeclaration>TCHAR c</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>fil</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to the file object</ParHint>
          <ParUserDeclaration>FIL *fil</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>%'ModuleName'_INT #M#_#C#(TCHAR c, FIL *fil)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>f_printf</Name>
        <Symbol>f_printf</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Put a formatted string to the file</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>INT</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>Variable_1</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to the file object</ParHint>
          <ParUserDeclaration>FIL* fil</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>str</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to the format string</ParHint>
          <ParUserDeclaration>const TCHAR* str</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>Variable_2</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Optional arguments...</ParHint>
          <ParUserDeclaration>...</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>%'ModuleName'_INT #M#_#C#(FIL* fil, const TCHAR* str, ...)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>f_eof</Name>
        <Symbol>f_eof</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Wrapper to to the f_eof() macro. Returns 1 if at the end of the file, 0 otherwise.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>fp</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to file object</ParHint>
          <ParUserDeclaration>FIL *fil</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(FIL *fil)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>f_error</Name>
        <Symbol>f_error</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Wrapper to to the f_eof() macro. Returns 1 if at the end of the file, 0 otherwise.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>fp</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to file object</ParHint>
          <ParUserDeclaration>FIL *fil</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(FIL *fil)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>f_tell</Name>
        <Symbol>f_tell</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Wrapper to to the f_tell() macro. Returns the file read/write pointer (0 on file open).</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>32bit unsigned</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>fp</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to file object</ParHint>
          <ParUserDeclaration>FIL *fil</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>dword #M#_#C#(FIL *fil)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>f_size</Name>
        <Symbol>f_size</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Wrapper to to the f_size() macro. Returns the file size.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>32bit unsigned</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>fp</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to file object</ParHint>
          <ParUserDeclaration>FIL *fil</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>dword #M#_#C#(FIL *fil)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>Init</Name>
        <Symbol>Init</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Initializes the device driver.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>Deinit</Name>
        <Symbol>Deinit</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Deinitializes the driver.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>get_fattime</Name>
        <Symbol>get_fattime</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Returns the current time</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>32bit unsigned</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>dword #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ParseCommand</Name>
        <Symbol>ParseCommand</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Shell Command Line parser. This method is enabled/disabled depending on if you have the Shell enabled/disabled in the properties.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>cmd</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to command string</ParHint>
          <ParUserDeclaration>const unsigned char *cmd</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>handled</ParName>
          <ParType>Boolean</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to variable which tells if the command has been handled or not</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to I/O structure</ParHint>
          <ParUserDeclaration>const %@Shell@'ModuleName'%.StdIOType *io</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(const unsigned char *cmd, bool *handled, const %@Shell@'ModuleName'%.StdIOType *io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>CheckCardPresence</Name>
        <Symbol>CheckCardPresence</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>This method checks if card has been inserted or removed and mounts or unmounts the file system.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>4</ParamCount>
        <Parameter>
          <ParName>cardMounted</ParName>
          <ParType>Boolean</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to initialize this variable to FALSE on the caller side the first time.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>drive</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>drive number, pass 0 as default drive</ParHint>
        </Parameter>
        <Parameter>
          <ParName>fileSystemObject</ParName>
          <ParType>FATFS</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to file system object</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to io handler to be used. Can be NULL, then no messages are written.</ParHint>
          <ParUserDeclaration>const %@Shell@'ModuleName'%.StdIOType *io</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(bool *cardMounted, byte drive, FATFS *fileSystemObject, const %@Shell@'ModuleName'%.StdIOType *io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>MountFileSystem</Name>
        <Symbol>MountFileSystem</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Mounts a file system</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>fileSystemObject</ParName>
          <ParType>FATFS</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to a file system object</ParHint>
        </Parameter>
        <Parameter>
          <ParName>logicalDrive</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The drive number to be used</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to I/O handler</ParHint>
          <ParUserDeclaration>const %@Shell@'ModuleName'%.StdIOType *io</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(FATFS *fileSystemObject, byte logicalDrive, const %@Shell@'ModuleName'%.StdIOType *io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>UnMountFileSystem</Name>
        <Symbol>UnMountFileSystem</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Mounts a file system</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>logicalDrive</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The drive number to be used</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to I/O handler</ParHint>
          <ParUserDeclaration>const %@Shell@'ModuleName'%.StdIOType *io</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(byte logicalDrive, const %@Shell@'ModuleName'%.StdIOType *io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>PrintDirectory</Name>
        <Symbol>PrintDirectory</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Prints a directory</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>dirName</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Directory folder to be printed</ParHint>
          <ParUserDeclaration>const byte *dirName</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to I/O handler</ParHint>
          <ParUserDeclaration>const %@Shell@'ModuleName'%.StdIOType *io</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(const byte *dirName, const %@Shell@'ModuleName'%.StdIOType *io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>CopyFile</Name>
        <Symbol>CopyFile</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Copy a file</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>srcFileName</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Source file name</ParHint>
          <ParUserDeclaration>const byte *srcFileName</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>dstFileName</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Destination file name</ParHint>
          <ParUserDeclaration>const byte *dstFileName</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to I/O handler</ParHint>
          <ParUserDeclaration>const %@Shell@'ModuleName'%.StdIOType *io</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(const byte *srcFileName, const byte *dstFileName, const %@Shell@'ModuleName'%.StdIOType *io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>DeleteFile</Name>
        <Symbol>DeleteFile</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Deletes a file</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>fileName</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Filename of file to be deleted</ParHint>
          <ParUserDeclaration>const byte *fileName</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to I/O handler</ParHint>
          <ParUserDeclaration>const %@Shell@'ModuleName'%.StdIOType *io</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(const byte *fileName, const %@Shell@'ModuleName'%.StdIOType *io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>PrintFile</Name>
        <Symbol>PrintFile</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Prints the content of a file</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>fileName</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Name of file to be printed</ParHint>
          <ParUserDeclaration>const byte *fileName</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to I/O handler</ParHint>
          <ParUserDeclaration>const %@Shell@'ModuleName'%.StdIOType *io</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(const byte *fileName, const %@Shell@'ModuleName'%.StdIOType *io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>MakeDirectory</Name>
        <Symbol>MakeDirectory</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Creates a directory</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>dirName</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Directory name</ParHint>
          <ParUserDeclaration>const byte *dirName</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to I/O handler</ParHint>
          <ParUserDeclaration>const %@Shell@'ModuleName'%.StdIOType *io</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(const byte *dirName, const %@Shell@'ModuleName'%.StdIOType *io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ChangeDirectory</Name>
        <Symbol>ChangeDirectory</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Changes to a directory</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>dirName</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Directory name</ParHint>
          <ParUserDeclaration>const byte *dirName</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to I/O handler</ParHint>
          <ParUserDeclaration>const %@Shell@'ModuleName'%.StdIOType *io</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(const byte *dirName, const %@Shell@'ModuleName'%.StdIOType *io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>RenameFile</Name>
        <Symbol>RenameFile</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Renames a file</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>srcFileName</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Source file name</ParHint>
          <ParUserDeclaration>const byte *srcFileName</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>dstFileName</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Destination file name</ParHint>
          <ParUserDeclaration>const byte *dstFileName</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to I/O handler</ParHint>
          <ParUserDeclaration>const %@Shell@'ModuleName'%.StdIOType *io</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(const byte *srcFileName, const byte *dstFileName, const %@Shell@'ModuleName'%.StdIOType *io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>PrintSector</Name>
        <Symbol>PrintSector</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Prints information about the current disk</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>drive</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>drive number, starting with zero</ParHint>
        </Parameter>
        <Parameter>
          <ParName>sectorNo</ParName>
          <ParType>32bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>sector number</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to I/O handler</ParHint>
          <ParUserDeclaration>const %@Shell@'ModuleName'%.StdIOType *io</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(byte drive, dword sectorNo, const %@Shell@'ModuleName'%.StdIOType *io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>PrintDiskInfo</Name>
        <Symbol>PrintDiskInfo</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Prints information about the current disk</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>drive</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>drive number, starting with zero</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to I/O handler</ParHint>
          <ParUserDeclaration>const %@Shell@'ModuleName'%.StdIOType *io</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(byte drive, const %@Shell@'ModuleName'%.StdIOType *io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
  </MethodList>
  <EventList>
    <Event>
      <TStrgItem>
        <Name>Event module name</Name>
        <Symbol>EventModule</Symbol>
        <Hint>Name of the user module (without extension), where the events from this bean are placed.</Hint>
        <ItemLevel>ADVANCED</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>Events</DefaultValue>
        <StrDefine>nothing</StrDefine>
        <MinLength>0</MinLength>
        <MaxLength>-1</MaxLength>
      </TStrgItem>
    </Event>
    <Event>
      <TEvntItem>
        <Name>OnIdle</Name>
        <Symbol>OnIdle</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Event called while driver is waiting. Useful to call the OS scheduler.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>don't generate code</Description>
        <Expanded>No</Expanded>
        <DefaultValue>false</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <IsAssembler>false</IsAssembler>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #C#(void)</ANSIC>
        </Declarations>
        <Children>
          <GrupItem>
            <TEvntName>
              <Name>Event procedure name</Name>
              <Symbol>Name</Symbol>
              <Hint>OnIdle procedure name</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue/>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
              <ErrorIfNotSet>true</ErrorIfNotSet>
              <IdentType>EVNT</IdentType>
            </TEvntName>
          </GrupItem>
        </Children>
      </TEvntItem>
    </Event>
    <Event>
      <TEvntItem>
        <Name>OnSchedule</Name>
        <Symbol>OnSchedule</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Event called to give an RTOS scheduler a chance.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>don't generate code</Description>
        <Expanded>No</Expanded>
        <DefaultValue>false</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <IsAssembler>false</IsAssembler>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #C#(void)</ANSIC>
        </Declarations>
        <Children>
          <GrupItem>
            <TEvntName>
              <Name>Event procedure name</Name>
              <Symbol>Name</Symbol>
              <Hint>OnSchedule procedure name</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue/>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
              <ErrorIfNotSet>true</ErrorIfNotSet>
              <IdentType>EVNT</IdentType>
            </TEvntName>
          </GrupItem>
        </Children>
      </TEvntItem>
    </Event>
  </EventList>
  <Links>
    <EmptySection_DummyValue/>
  </Links>
  <Revisions>
    <RevisionVersion>2</RevisionVersion>
  </Revisions>
</Bean>
