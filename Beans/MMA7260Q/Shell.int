<?xml version="1.0" encoding="UTF-8"?>
<Interface>
  <Name>Shell</Name>
  <Description>Interface "MMA7260Q\Shell" for component MMA7260Q, generated by Component Wizard</Description>
  <Author>Author</Author>
  <Version>01.000</Version>
  <FileVersion>2</FileVersion>
  <MethodList>
    <Method>
      <TMthdItem>
        <Name>PrintPrompt</Name>
        <Symbol>PrintPrompt</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Prints the prompt to the stdOut channel</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>io</ParName>
          <ParType>ConstStdIOType</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to IO to be used</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(ConstStdIOType *io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendNum8u</Name>
        <Symbol>SendNum8u</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sends an 8bit unsigned number to the given I/O</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>val</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>number to print</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>StdIO_OutErr_FctType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>I/O callbacks to be used for printing.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(byte val, StdIO_OutErr_FctType io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendNum8s</Name>
        <Symbol>SendNum8s</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sends an 8bit signed number to the given I/O</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>val</ParName>
          <ParType>8bit signed</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>number to print</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>StdIO_OutErr_FctType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>I/O callbacks to be used for printing.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(signed char val, StdIO_OutErr_FctType io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendNum16u</Name>
        <Symbol>SendNum16u</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sends a 16bit unsigned number to the given I/O</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>val</ParName>
          <ParType>16bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>number to print</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>StdIO_OutErr_FctType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>I/O callbacks to be used for printing.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(word val, StdIO_OutErr_FctType io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendNum16s</Name>
        <Symbol>SendNum16s</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sends a 16bit signed number to the given I/O</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>val</ParName>
          <ParType>16bit signed</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>number to print</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>StdIO_OutErr_FctType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>I/O callbacks to be used for printing.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(int16_t val, StdIO_OutErr_FctType io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendNum32u</Name>
        <Symbol>SendNum32u</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sends a 32bit unsigned number to the given I/O</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>val</ParName>
          <ParType>32bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>number to print</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>StdIO_OutErr_FctType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>I/O callbacks to be used for printing.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(dword val, StdIO_OutErr_FctType io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendNum32s</Name>
        <Symbol>SendNum32s</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sends a 32bit signed number to the given I/O</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>val</ParName>
          <ParType>32bit signed</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>number to print</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>StdIO_OutErr_FctType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>I/O callbacks to be used for printing.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(long val, StdIO_OutErr_FctType io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendStr</Name>
        <Symbol>SendStr</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Prints a string using an I/O function</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>str</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>String (zero terminated) to be printed.</ParHint>
          <ParUserDeclaration>const byte *str</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>StdIO_OutErr_FctType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>I/O callbacks to be used for printing.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(const byte *str, StdIO_OutErr_FctType io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>PrintStatus</Name>
        <Symbol>PrintStatus</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Prints various available system status information</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>io</ParName>
          <ParType>ConstStdIOType</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to I/O callbacks</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(ConstStdIOType *io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ParseCommand</Name>
        <Symbol>ParseCommand</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Parses a shell command. Use 'help' to get a list of supported commands.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>cmd</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to command string</ParHint>
          <ParUserDeclaration>const unsigned char *cmd</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>handled</ParName>
          <ParType>Boolean</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to variable to indicate if the command has been handled. The caller passes this variable to the command scanner to find out if the passed command has been handled. The variable is initialized by the caller.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>ConstStdIOType</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to I/O callbacks</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(const unsigned char *cmd, bool *handled, ConstStdIOType *io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ReadLine</Name>
        <Symbol>ReadLine</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Reads a line from stdIn and returns TRUE if we have a line, FALSE otherwise.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>Boolean</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>buf</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to buffer where to read in the information</ParHint>
        </Parameter>
        <Parameter>
          <ParName>bufSize</ParName>
          <ParType>16bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>size of buffer</ParHint>
          <ParUserDeclaration>size_t bufSize</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>ConstStdIOType</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to I/O callbacks</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>bool #M#_#C#(byte *buf, size_t bufSize, ConstStdIOType *io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>PrintCommandFailed</Name>
        <Symbol>PrintCommandFailed</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Prints a standard message for failed or unknown commands</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>cmd</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to command which was failing</ParHint>
          <ParUserDeclaration>const unsigned char *cmd</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>ConstStdIOType</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to I/O callbacks</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(const unsigned char *cmd, ConstStdIOType *io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>IterateTable</Name>
        <Symbol>IterateTable</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Parses a shell command. It handles first the internal commands and will call the provided callback.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>4</ParamCount>
        <Parameter>
          <ParName>cmd</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to command string</ParHint>
          <ParUserDeclaration>const unsigned char *cmd</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>handled</ParName>
          <ParType>Boolean</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to boolean which is set to TRUE if a command parser has handled the command.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>ConstStdIOType</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to I/O callbacks</ParHint>
        </Parameter>
        <Parameter>
          <ParName>parserTable</ParName>
          <ParType>ConstParseCommandCallback</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to callback which will be called to parse commands in the user application, or NULL if not used.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(const unsigned char *cmd, bool *handled, ConstStdIOType *io, ConstParseCommandCallback *parserTable)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>GetStdio</Name>
        <Symbol>GetStdio</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Returns the default stdio channel. This method is only available if a shell is enabled in the component properties.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>ConstStdIOTypePtr</ReturnType>
        <RetHint>Pointer to the stdio descriptor</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>ConstStdIOTypePtr #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>RequestSerial</Name>
        <Symbol>RequestSerial</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Used to get mutual access to the shell console. Only has an effect if using an RTOS with semaphore for the console access.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ReleaseSerial</Name>
        <Symbol>ReleaseSerial</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Used to release mutual access to the shell console. Only has an effect if using an RTOS with semaphore for the console access.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ReadAndParseWithCommandTable</Name>
        <Symbol>ReadAndParseWithCommandTable</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Reads characters from the default input channel and appends it to the buffer. Once a new line has been detected, the line will be parsed using the handlers in the table.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>4</ParamCount>
        <Parameter>
          <ParName>cmdBuf</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to buffer provided by the caller where to store the command to read in. Characters will be appended, so make sure string buffer is initialized with a zero byte at the beginning.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>cmdBufSize</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Size of buffer</ParHint>
          <ParUserDeclaration>size_t cmdBufSize</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>ConstStdIOType</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to I/O channels to be used</ParHint>
        </Parameter>
        <Parameter>
          <ParName>parseCallback</ParName>
          <ParType>ConstParseCommandCallback</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to callback table provided by the user application to parse commands. The table has a NULL sentinel.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(byte *cmdBuf, size_t cmdBufSize, ConstStdIOType *io, ConstParseCommandCallback *parseCallback)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ParseWithCommandTable</Name>
        <Symbol>ParseWithCommandTable</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Parses a shell command. It handles first the internal commands and will call the provided callback.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>cmd</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to command string</ParHint>
          <ParUserDeclaration>const unsigned char *cmd</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>ConstStdIOType</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to I/O callbacks</ParHint>
        </Parameter>
        <Parameter>
          <ParName>parseCallback</ParName>
          <ParType>ConstParseCommandCallback</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to callback which will be called to parse commands in the user application, or NULL if not used.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(const unsigned char *cmd, ConstStdIOType *io, ConstParseCommandCallback *parseCallback)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>GetSemaphore</Name>
        <Symbol>GetSemaphore</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Return the semaphore of the shell.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>pointer</ReturnType>
        <RetHint>semaphore, or NULL if not used or not allocated.</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void* #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendStatusStr</Name>
        <Symbol>SendStatusStr</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Prints a status string using an I/O function, formated for the 'status' command</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>strItem</ParName>
          <ParType>char</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to string of the command</ParHint>
          <ParUserDeclaration>const byte *strItem</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>strStatus</ParName>
          <ParType>char</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to help text string</ParHint>
          <ParUserDeclaration>const byte *strStatus</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>StdIO_OutErr_FctType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>I/O callbacks to be used for printing.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(const byte *strItem, const byte *strStatus, StdIO_OutErr_FctType io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendHelpStr</Name>
        <Symbol>SendHelpStr</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Prints a string using an I/O function, formated for the 'help' command</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>strCmd</ParName>
          <ParType>char</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to string of the command</ParHint>
          <ParUserDeclaration>const byte *strCmd</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>strHelp</ParName>
          <ParType>char</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to help text string</ParHint>
          <ParUserDeclaration>const byte *strHelp</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>StdIO_OutErr_FctType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>I/O callbacks to be used for printing.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(const byte *strCmd, const byte *strHelp, StdIO_OutErr_FctType io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ReadChar</Name>
        <Symbol>ReadChar</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Reads a character (blocking)</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>c</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to character to be used to store the result</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(byte *c)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendChar</Name>
        <Symbol>SendChar</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sends a character (blocking)</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>ch</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>character to be sent</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(byte ch)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>KeyPressed</Name>
        <Symbol>KeyPressed</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Checks if a key has been pressed (a character is present in the input buffer)</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>Boolean</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>bool #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>Init</Name>
        <Symbol>Init</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Initializes the module, especially creates the mutex semaphore if an RTOS is used.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>Deinit</Name>
        <Symbol>Deinit</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>De-Initializes the module, especially frees the mutex semaphore if an RTOS is used.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
  </MethodList>
  <EventList>
    <EmptySection_DummyValue/>
  </EventList>
  <Registration>
    <Template>Shell</Template>
  </Registration>
  <UserTypes>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>StdIO_OutErr_FctType</Name>
      <Hint>Callback for an output or error I/O function</Hint>
      <Generate>yes</Generate>
      <Unique>yes</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>typedef void (*%'ModuleName'%.StdIO_OutErr_FctType)(byte); /* Callback for an output or error I/O function */\n
</PreparedHint>
      <Type>typedef void (*%'ModuleName'%.StdIO_OutErr_FctType)(byte);</Type>
      <HWTestType/>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>StdIO_In_FctType</Name>
      <Hint>Callback for an I/O input function.</Hint>
      <Generate>yes</Generate>
      <Unique>yes</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>typedef void (*%'ModuleName'%.StdIO_In_FctType)(byte *); /* Callback for an I/O input function. */\n
</PreparedHint>
      <Type>typedef void (*%'ModuleName'%.StdIO_In_FctType)(byte *);</Type>
      <HWTestType/>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>StdIO_KeyPressed_FctType</Name>
      <Hint>Callback which returns true if a key has been pressed</Hint>
      <Generate>yes</Generate>
      <Unique>yes</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>typedef bool (*%'ModuleName'%.StdIO_KeyPressed_FctType)(void); /* Callback which returns true if a key has been pressed */\n
</PreparedHint>
      <Type>typedef bool (*%'ModuleName'%.StdIO_KeyPressed_FctType)(void);</Type>
      <HWTestType/>
    </Type>
    <Type>
      <UsrType>TRecordType</UsrType>
      <Name>StdIOType</Name>
      <Hint>Record containing input, output and error callback (stdin, stdout, stderr).</Hint>
      <Generate>yes</Generate>
      <Unique>yes</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>  typedef struct { /* Record containing input, output and error callback (stdin, stdout, stderr). */\n
    StdIO_In_FctType stdIn; /* standard input */\n
    StdIO_OutErr_FctType stdOut; /* standard output */\n
    StdIO_OutErr_FctType stdErr; /* standard error */\n
    StdIO_KeyPressed_FctType keyPressed; /* key pressed callback */\n
  } %'ModuleName'_StdIOType;\n
</PreparedHint>
      <RecordItem>
        <ItemName>stdIn</ItemName>
        <ItemType>StdIO_In_FctType</ItemType>
        <ItemHint>standard input</ItemHint>
        <ItemPointer>no</ItemPointer>
      </RecordItem>
      <RecordItem>
        <ItemName>stdOut</ItemName>
        <ItemType>StdIO_OutErr_FctType</ItemType>
        <ItemHint>standard output</ItemHint>
        <ItemPointer>no</ItemPointer>
      </RecordItem>
      <RecordItem>
        <ItemName>stdErr</ItemName>
        <ItemType>StdIO_OutErr_FctType</ItemType>
        <ItemHint>standard error</ItemHint>
        <ItemPointer>no</ItemPointer>
      </RecordItem>
      <RecordItem>
        <ItemName>keyPressed</ItemName>
        <ItemType>StdIO_KeyPressed_FctType</ItemType>
        <ItemHint>key pressed callback</ItemHint>
        <ItemPointer>no</ItemPointer>
      </RecordItem>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>ConstStdIOType</Name>
      <Hint>constant StdIOType</Hint>
      <Generate>yes</Generate>
      <Unique>yes</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>typedef const %'ModuleName'%.StdIOType %'ModuleName'%.ConstStdIOType; /* constant StdIOType */\n
</PreparedHint>
      <Type>typedef const %'ModuleName'%.StdIOType %'ModuleName'%.ConstStdIOType;</Type>
      <HWTestType/>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>FATFS</Name>
      <Hint>Alias to FATFS type</Hint>
      <Generate>no</Generate>
      <Unique>yes</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>typedef %'ModuleName'%.FS_FATFS %'ModuleName'%.FATFS; /* Alias to FATFS type */\n
</PreparedHint>
      <Type>typedef %'ModuleName'%.FS_FATFS %'ModuleName'%.FATFS;</Type>
      <HWTestType/>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>DRESULT</Name>
      <Hint>Alias to FATFS type</Hint>
      <Generate>no</Generate>
      <Unique>yes</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>typedef %'ModuleName'%.FS_DRESULT %'ModuleName'%.DRESULT; /* Alias to FATFS type */\n
</PreparedHint>
      <Type>typedef %'ModuleName'%.FS_DRESULT %'ModuleName'%.DRESULT;</Type>
      <HWTestType/>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>FRESULT</Name>
      <Hint>Alias to FATFS type</Hint>
      <Generate>no</Generate>
      <Unique>yes</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>typedef %'ModuleName'%.FS_FRESULT %'ModuleName'%.FRESULT; /* Alias to FATFS type */\n
</PreparedHint>
      <Type>typedef %'ModuleName'%.FS_FRESULT %'ModuleName'%.FRESULT;</Type>
      <HWTestType/>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>ParseCommandCallback</Name>
      <Hint>Callback for parsing a shell command</Hint>
      <Generate>yes</Generate>
      <Unique>yes</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>typedef byte (*%'ModuleName'%.ParseCommandCallback)(const byte *cmd, bool *handled, const %'ModuleName'%.StdIOType *io); /* Callback for parsing a shell command */\n
</PreparedHint>
      <Type>typedef byte (*%'ModuleName'%.ParseCommandCallback)(const byte *cmd, bool *handled, const %'ModuleName'%.StdIOType *io);</Type>
      <HWTestType/>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>ConstStdIOTypePtr</Name>
      <Hint>Pointer to constant standard I/O descriptor</Hint>
      <Generate>yes</Generate>
      <Unique>yes</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>typedef const %'ModuleName'%.ConstStdIOType *%'ModuleName'%.ConstStdIOTypePtr; /* Pointer to constant standard I/O descriptor */\n
</PreparedHint>
      <Type>typedef const %'ModuleName'%.ConstStdIOType *%'ModuleName'%.ConstStdIOTypePtr;</Type>
      <HWTestType/>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>ConstParseCommandCallback</Name>
      <Hint>Callback for parsing a shell command</Hint>
      <Generate>yes</Generate>
      <Unique>yes</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>typedef const %'ModuleName'%.ParseCommandCallback %'ModuleName'%.ConstParseCommandCallback; /* Callback for parsing a shell command */\n
</PreparedHint>
      <Type>typedef const %'ModuleName'%.ParseCommandCallback %'ModuleName'%.ConstParseCommandCallback;</Type>
      <HWTestType/>
    </Type>
  </UserTypes>
</Interface>
